# Generated by Haxe 4.0.5
# coding: utf-8
import sys


class _hx_AnonObject:
    _hx_disable_getattr = False

    def __init__(self, fields):
        self.__dict__ = fields

    def __repr__(self):
        return repr(self.__dict__)

    def __getattr__(self, name):
        if self._hx_disable_getattr:
            raise AttributeError("field does not exist")
        else:
            return None

    def _hx_hasattr(self, field):
        self._hx_disable_getattr = True
        try:
            getattr(self, field)
            self._hx_disable_getattr = False
            return True
        except AttributeError:
            self._hx_disable_getattr = False
            return False


class Sieve:
    __slots__ = ()

    def __init__(self):
        pass

    def isPrime(self, num):
        if num < 2:
            return False
        _g = 2
        _g1 = num
        while _g < _g1:
            i = _g
            _g = _g + 1
            if HxOverrides.mod(num, i) == 0:
                return False
        return True

    def contains(self, array, element):
        return python_internal_ArrayImpl.indexOf(array, element, None) != -1

    def sieve(self, upper_bound):
        if (upper_bound == 0) or ((upper_bound == 1)):
            return []
        primes = list()
        non_primes = list()
        _g_min = 2
        _g_max = upper_bound + 1
        while _g_min < _g_max:
            i = _g_min
            _g_min = _g_min + 1
            _g = 0
            _g1 = i
            while _g < _g1:
                j = _g
                _g = _g + 1
                current_num = i * j
                if (current_num > upper_bound) or self.contains(
                    non_primes, current_num
                ):
                    continue
                if self.isPrime(current_num):
                    primes = primes + [current_num]
                else:
                    non_primes = non_primes + [current_num]
        return primes


class Sieve_Run:
    __slots__ = ()

    @staticmethod
    def main():
        _g = haxe_ds_IntMap()
        _g.set(1, 0)
        _g.set(10, 4)
        _g.set(100, 25)
        _g.set(1000, 168)
        _g.set(10000, 1229)
        known = _g
        sieve = Sieve()
        _g1 = haxe_iterators_MapKeyValueIterator(known)
        while _g1.hasNext():
            _g2 = _g1.next()
            k = _g2.key
            _ = _g2.value
            sieve.sieve(k)


class haxe_IMap:
    __slots__ = ()


class python_HaxeIterator:
    __slots__ = ("it", "x", "has", "checked")

    def __init__(self, it):
        self.checked = False
        self.has = False
        self.x = None
        self.it = it

    def next(self):
        if not self.checked:
            self.hasNext()
        self.checked = False
        return self.x

    def hasNext(self):
        if not self.checked:
            try:
                self.x = self.it.__next__()
                self.has = True
            except Exception as _hx_e:
                _hx_e1 = _hx_e
                if isinstance(_hx_e1, StopIteration):
                    s = _hx_e1
                    self.has = False
                    self.x = None
                else:
                    raise _hx_e
            self.checked = True
        return self.has


class haxe_ds_IntMap:
    __slots__ = ("h",)

    def __init__(self):
        self.h = dict()

    def set(self, key, value):
        self.h[key] = value

    def get(self, key):
        return self.h.get(key, None)

    def keys(self):
        return python_HaxeIterator(iter(self.h.keys()))


class haxe_iterators_MapKeyValueIterator:
    __slots__ = ("map", "keys")

    def __init__(self, _hx_map):
        self.map = _hx_map
        self.keys = _hx_map.keys()

    def hasNext(self):
        return self.keys.hasNext()

    def next(self):
        key = self.keys.next()
        return _hx_AnonObject({"value": self.map.get(key), "key": key})


class python_internal_ArrayImpl:
    __slots__ = ()

    @staticmethod
    def indexOf(a, x, fromIndex=None):
        _hx_len = len(a)
        l = (
            0
            if ((fromIndex is None))
            else ((_hx_len + fromIndex) if ((fromIndex < 0)) else fromIndex)
        )
        if l < 0:
            l = 0
        _g = l
        _g1 = _hx_len
        while _g < _g1:
            i = _g
            _g = _g + 1
            if HxOverrides.eq(a[i], x):
                return i
        return -1


class HxOverrides:
    __slots__ = ()

    @staticmethod
    def modf(a, b):
        if b == 0.0:
            return float("nan")
        elif a < 0:
            if b < 0:
                return -(-a % (-b))
            else:
                return -(-a % b)
        elif b < 0:
            return a % (-b)
        else:
            return a % b

    @staticmethod
    def mod(a, b):
        if a < 0:
            if b < 0:
                return -(-a % (-b))
            else:
                return -(-a % b)
        elif b < 0:
            return a % (-b)
        else:
            return a % b

    @staticmethod
    def eq(a, b):
        return a == b


class python_internal_MethodClosure:
    __slots__ = ("obj", "func")

    def __init__(self, obj, func):
        self.obj = obj
        self.func = func

    def __call__(self, *args):
        return self.func(self.obj, *args)


Sieve_Run.main()
