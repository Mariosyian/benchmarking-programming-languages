// Generated by Haxe 4.1.5
(function ($global) { "use strict";
var $estr = function() { return js_Boot.__string_rec(this,''); },$hxEnums = $hxEnums || {},$_;
function $extend(from, fields) {
	var proto = Object.create(from);
	for (var name in fields) proto[name] = fields[name];
	if( fields.toString !== Object.prototype.toString ) proto.toString = fields.toString;
	return proto;
}
var EReg = function(r,opt) {
	this.r = new RegExp(r,opt.split("u").join(""));
};
EReg.__name__ = true;
EReg.prototype = {
	match: function(s) {
		if(this.r.global) {
			this.r.lastIndex = 0;
		}
		this.r.m = this.r.exec(s);
		this.r.s = s;
		return this.r.m != null;
	}
	,matched: function(n) {
		if(this.r.m != null && n >= 0 && n < this.r.m.length) {
			return this.r.m[n];
		} else {
			throw haxe_Exception.thrown("EReg::matched");
		}
	}
	,__class__: EReg
};
var HxOverrides = function() { };
HxOverrides.__name__ = true;
HxOverrides.cca = function(s,index) {
	var x = s.charCodeAt(index);
	if(x != x) {
		return undefined;
	}
	return x;
};
HxOverrides.substr = function(s,pos,len) {
	if(len == null) {
		len = s.length;
	} else if(len < 0) {
		if(pos == 0) {
			len = s.length + len;
		} else {
			return "";
		}
	}
	return s.substr(pos,len);
};
HxOverrides.remove = function(a,obj) {
	var i = a.indexOf(obj);
	if(i == -1) {
		return false;
	}
	a.splice(i,1);
	return true;
};
HxOverrides.now = function() {
	return Date.now();
};
var json2object_reader_BaseParser = function(errors,putils,errorType) {
	this.errors = errors;
	this.putils = putils;
	this.errorType = errorType;
};
json2object_reader_BaseParser.__name__ = true;
json2object_reader_BaseParser.prototype = {
	fromJson: function(jsonString,filename) {
		if(filename == null) {
			filename = "";
		}
		this.putils = new json2object_PositionUtils(jsonString);
		this.errors = [];
		try {
			this.loadJson(new hxjsonast_Parser(jsonString,filename).parseRec());
		} catch( _g ) {
			haxe_NativeStackTrace.lastError = _g;
			var _g1 = haxe_Exception.caught(_g).unwrap();
			if(((_g1) instanceof hxjsonast_Error)) {
				var e = _g1;
				this.errors.push(json2object_Error.ParserError(e.message,this.putils.convertPosition(e.pos)));
			} else {
				throw _g;
			}
		}
		return this.value;
	}
	,loadJson: function(json,variable) {
		if(variable == null) {
			variable = "";
		}
		var pos = this.putils.convertPosition(json.pos);
		var _g = json.value;
		switch(_g._hx_index) {
		case 0:
			this.loadJsonString(_g.s,pos,variable);
			break;
		case 1:
			this.loadJsonNumber(_g.s,pos,variable);
			break;
		case 2:
			this.loadJsonObject(_g.fields,pos,variable);
			break;
		case 3:
			this.loadJsonArray(_g.values,pos,variable);
			break;
		case 4:
			this.loadJsonBool(_g.b,pos,variable);
			break;
		case 5:
			this.loadJsonNull(pos,variable);
			break;
		}
		return this.value;
	}
	,loadJsonNull: function(pos,variable) {
		this.onIncorrectType(pos,variable);
	}
	,loadJsonString: function(s,pos,variable) {
		this.onIncorrectType(pos,variable);
	}
	,loadString: function(s,pos,variable,validValues,defaultValue) {
		if(validValues.indexOf(s) != -1) {
			return s;
		}
		this.onIncorrectType(pos,variable);
		return defaultValue;
	}
	,loadJsonNumber: function(f,pos,variable) {
		this.onIncorrectType(pos,variable);
	}
	,loadJsonInt: function(f,pos,variable,value) {
		if(Std.parseInt(f) != null && Std.parseInt(f) == parseFloat(f)) {
			return Std.parseInt(f);
		}
		this.onIncorrectType(pos,variable);
		return value;
	}
	,loadJsonBool: function(b,pos,variable) {
		this.onIncorrectType(pos,variable);
	}
	,loadJsonArray: function(a,pos,variable) {
		this.onIncorrectType(pos,variable);
	}
	,loadJsonArrayValue: function(a,loadJsonFn,variable) {
		var _g = [];
		var _g1 = 0;
		while(_g1 < a.length) {
			var j = a[_g1++];
			var tmp;
			try {
				tmp = loadJsonFn(j,variable);
			} catch( _g2 ) {
				haxe_NativeStackTrace.lastError = _g2;
				var _g3 = haxe_Exception.caught(_g2).unwrap();
				if(js_Boot.__instanceof(_g3,json2object_InternalError)) {
					var e = _g3;
					if(e != json2object_InternalError.ParsingThrow) {
						throw haxe_Exception.thrown(e);
					}
					continue;
				} else {
					throw _g2;
				}
			}
			_g.push(tmp);
		}
		return _g;
	}
	,loadJsonObject: function(o,pos,variable) {
		this.onIncorrectType(pos,variable);
	}
	,loadObjectField: function(loadJsonFn,field,name,assigned,defaultValue,pos) {
		try {
			var ret = loadJsonFn(field.value,field.name);
			this.mapSet(assigned,name,true);
			return ret;
		} catch( _g ) {
			haxe_NativeStackTrace.lastError = _g;
			var _g1 = haxe_Exception.caught(_g).unwrap();
			if(js_Boot.__instanceof(_g1,json2object_InternalError)) {
				var e = _g1;
				if(e != json2object_InternalError.ParsingThrow) {
					throw haxe_Exception.thrown(e);
				}
			} else {
				this.errors.push(json2object_Error.CustomFunctionException(_g1,pos));
			}
		}
		return defaultValue;
	}
	,objectSetupAssign: function(assigned,keys,values) {
		var _g = 0;
		var _g1 = keys.length;
		while(_g < _g1) {
			var i = _g++;
			this.mapSet(assigned,keys[i],values[i]);
		}
	}
	,objectErrors: function(assigned,pos) {
		var lastPos = this.putils.convertPosition(new hxjsonast_Position(pos.file,pos.max - 1,pos.max - 1));
		var s = haxe_ds_StringMap.keysIterator(assigned.h);
		while(s.hasNext()) {
			var s1 = s.next();
			if(!assigned.h[s1]) {
				this.errors.push(json2object_Error.UninitializedVariable(s1,lastPos));
			}
		}
	}
	,onIncorrectType: function(pos,variable) {
		this.parsingThrow();
	}
	,parsingThrow: function() {
		if(this.errorType != 0) {
			throw haxe_Exception.thrown(json2object_InternalError.ParsingThrow);
		}
	}
	,objectThrow: function(pos,variable) {
		if(this.errorType == 2) {
			throw haxe_Exception.thrown(json2object_InternalError.ParsingThrow);
		}
		if(this.errorType == 1) {
			this.errors.push(json2object_Error.UninitializedVariable(variable,pos));
		}
	}
	,mapSet: function(map,key,value) {
		map.h[key] = value;
	}
	,__class__: json2object_reader_BaseParser
};
var JsonParser_$1 = function(errors,putils,errorType) {
	if(errorType == null) {
		errorType = 0;
	}
	json2object_reader_BaseParser.call(this,errors,putils,errorType);
};
JsonParser_$1.__name__ = true;
JsonParser_$1.__super__ = json2object_reader_BaseParser;
JsonParser_$1.prototype = $extend(json2object_reader_BaseParser.prototype,{
	onIncorrectType: function(pos,variable) {
		this.errors.push(json2object_Error.IncorrectType(variable,"{ ?wrapping : Null<formatter.config.WrapConfig>, ?whitespace : Null<formatter.config.WhitespaceConfig>, ?sameLine : Null<formatter.config.SameLineConfig>, ?lineEnds : Null<formatter.config.LineEndConfig>, ?indentation : Null<formatter.config.IndentationConfig>, ?excludes : Null<Array<String>>, ?emptyLines : Null<formatter.config.EmptyLinesConfig>, ?disableFormatting : Null<Bool> }",pos));
		json2object_reader_BaseParser.prototype.onIncorrectType.call(this,pos,variable);
	}
	,loadJsonNull: function(pos,variable) {
		this.value = null;
	}
	,loadJsonObject: function(o,pos,variable) {
		var assigned = new haxe_ds_StringMap();
		this.objectSetupAssign(assigned,["disableFormatting","emptyLines","excludes","indentation","lineEnds","sameLine","whitespace","wrapping"],[true,true,true,true,true,true,true,true]);
		this.value = this.getAuto();
		var _g = 0;
		while(_g < o.length) {
			var field = o[_g];
			++_g;
			switch(field.name) {
			case "disableFormatting":
				this.value.disableFormatting = this.loadObjectField(($_=new JsonParser_$62(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"disableFormatting",assigned,this.value.disableFormatting,pos);
				break;
			case "emptyLines":
				this.value.emptyLines = this.loadObjectField(($_=new JsonParser_$4(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"emptyLines",assigned,this.value.emptyLines,pos);
				break;
			case "excludes":
				this.value.excludes = this.loadObjectField(($_=new JsonParser_$66(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"excludes",assigned,this.value.excludes,pos);
				break;
			case "indentation":
				this.value.indentation = this.loadObjectField(($_=new JsonParser_$33(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"indentation",assigned,this.value.indentation,pos);
				break;
			case "lineEnds":
				this.value.lineEnds = this.loadObjectField(($_=new JsonParser_$36(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"lineEnds",assigned,this.value.lineEnds,pos);
				break;
			case "sameLine":
				this.value.sameLine = this.loadObjectField(($_=new JsonParser_$39(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"sameLine",assigned,this.value.sameLine,pos);
				break;
			case "whitespace":
				this.value.whitespace = this.loadObjectField(($_=new JsonParser_$42(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"whitespace",assigned,this.value.whitespace,pos);
				break;
			case "wrapping":
				this.value.wrapping = this.loadObjectField(($_=new JsonParser_$60(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"wrapping",assigned,this.value.wrapping,pos);
				break;
			default:
				this.errors.push(json2object_Error.UnknownVariable(field.name,this.putils.convertPosition(field.namePos)));
			}
		}
		this.objectErrors(assigned,pos);
	}
	,getAuto: function() {
		return { disableFormatting : false, emptyLines : new JsonParser_$4([],this.putils,0).getAuto(), excludes : ["\\.haxelib","\\.git","node_modules"], indentation : new JsonParser_$33([],this.putils,0).getAuto(), lineEnds : new JsonParser_$36([],this.putils,0).getAuto(), sameLine : new JsonParser_$39([],this.putils,0).getAuto(), whitespace : new JsonParser_$42([],this.putils,0).getAuto(), wrapping : new JsonParser_$60([],this.putils,0).getAuto()};
	}
	,__class__: JsonParser_$1
});
var JsonParser_$112 = function(errors,putils,errorType) {
	if(errorType == null) {
		errorType = 0;
	}
	json2object_reader_BaseParser.call(this,errors,putils,errorType);
};
JsonParser_$112.__name__ = true;
JsonParser_$112.__super__ = json2object_reader_BaseParser;
JsonParser_$112.prototype = $extend(json2object_reader_BaseParser.prototype,{
	onIncorrectType: function(pos,variable) {
		this.value = "beforeLast";
		this.errors.push(json2object_Error.IncorrectType(variable,"formatter.config.WrappingLocation",pos));
		this.objectThrow(pos,variable);
	}
	,loadJsonNull: function(pos,variable) {
		this.value = null;
	}
	,loadJsonString: function(s,pos,variable) {
		this.value = this.loadString(s,pos,variable,["beforeLast","afterLast"],"beforeLast");
	}
	,__class__: JsonParser_$112
});
var JsonParser_$114 = function(errors,putils,errorType) {
	if(errorType == null) {
		errorType = 0;
	}
	json2object_reader_BaseParser.call(this,errors,putils,errorType);
};
JsonParser_$114.__name__ = true;
JsonParser_$114.__super__ = json2object_reader_BaseParser;
JsonParser_$114.prototype = $extend(json2object_reader_BaseParser.prototype,{
	onIncorrectType: function(pos,variable) {
		this.value = "onePerLine";
		this.errors.push(json2object_Error.IncorrectType(variable,"formatter.config.WrappingType",pos));
		this.objectThrow(pos,variable);
	}
	,loadJsonNull: function(pos,variable) {
		this.value = null;
	}
	,loadJsonString: function(s,pos,variable) {
		this.value = this.loadString(s,pos,variable,["onePerLine","onePerLineAfterFirst","equalNumber","fillLine","fillLineWithLeadingBreak","noWrap","keep"],"onePerLine");
	}
	,__class__: JsonParser_$114
});
var JsonParser_$116 = function(errors,putils,errorType) {
	if(errorType == null) {
		errorType = 0;
	}
	json2object_reader_BaseParser.call(this,errors,putils,errorType);
};
JsonParser_$116.__name__ = true;
JsonParser_$116.__super__ = json2object_reader_BaseParser;
JsonParser_$116.prototype = $extend(json2object_reader_BaseParser.prototype,{
	onIncorrectType: function(pos,variable) {
		this.errors.push(json2object_Error.IncorrectType(variable,"Array<formatter.config.WrapRule>",pos));
		json2object_reader_BaseParser.prototype.onIncorrectType.call(this,pos,variable);
	}
	,loadJsonNull: function(pos,variable) {
		this.value = null;
	}
	,loadJsonArray: function(a,pos,variable) {
		this.value = this.loadJsonArrayValue(a,($_=new JsonParser_$118(this.errors,this.putils,2),$bind($_,$_.loadJson)),variable);
	}
	,__class__: JsonParser_$116
});
var JsonParser_$118 = function(errors,putils,errorType) {
	if(errorType == null) {
		errorType = 0;
	}
	json2object_reader_BaseParser.call(this,errors,putils,errorType);
};
JsonParser_$118.__name__ = true;
JsonParser_$118.__super__ = json2object_reader_BaseParser;
JsonParser_$118.prototype = $extend(json2object_reader_BaseParser.prototype,{
	onIncorrectType: function(pos,variable) {
		this.errors.push(json2object_Error.IncorrectType(variable,"{ type : formatter.config.WrappingType, ?location : Null<formatter.config.WrappingLocation>, conditions : Array<formatter.config.WrapCondition>, ?additionalIndent : Null<Int> }",pos));
		json2object_reader_BaseParser.prototype.onIncorrectType.call(this,pos,variable);
	}
	,loadJsonNull: function(pos,variable) {
		this.value = null;
	}
	,loadJsonObject: function(o,pos,variable) {
		var assigned = new haxe_ds_StringMap();
		this.objectSetupAssign(assigned,["additionalIndent","conditions","location","type"],[true,false,true,false]);
		this.value = this.getAuto();
		var _g = 0;
		while(_g < o.length) {
			var field = o[_g];
			++_g;
			switch(field.name) {
			case "additionalIndent":
				this.value.additionalIndent = this.loadObjectField(($_=new JsonParser_$96(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"additionalIndent",assigned,this.value.additionalIndent,pos);
				break;
			case "conditions":
				this.value.conditions = this.loadObjectField(($_=new JsonParser_$119(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"conditions",assigned,this.value.conditions,pos);
				break;
			case "location":
				this.value.location = this.loadObjectField(($_=new JsonParser_$112(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"location",assigned,this.value.location,pos);
				break;
			case "type":
				this.value.type = this.loadObjectField(($_=new JsonParser_$120(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"type",assigned,this.value.type,pos);
				break;
			default:
				this.errors.push(json2object_Error.UnknownVariable(field.name,this.putils.convertPosition(field.namePos)));
			}
		}
		this.objectErrors(assigned,pos);
	}
	,getAuto: function() {
		return { additionalIndent : 0, conditions : new JsonParser_$119([],this.putils,0).loadJson(new hxjsonast_Json(hxjsonast_JsonValue.JNull,new hxjsonast_Position("",0,1))), location : "afterLast", type : new JsonParser_$120([],this.putils,0).loadJson(new hxjsonast_Json(hxjsonast_JsonValue.JNull,new hxjsonast_Position("",0,1)))};
	}
	,__class__: JsonParser_$118
});
var JsonParser_$119 = function(errors,putils,errorType) {
	if(errorType == null) {
		errorType = 0;
	}
	json2object_reader_BaseParser.call(this,errors,putils,errorType);
};
JsonParser_$119.__name__ = true;
JsonParser_$119.__super__ = json2object_reader_BaseParser;
JsonParser_$119.prototype = $extend(json2object_reader_BaseParser.prototype,{
	onIncorrectType: function(pos,variable) {
		this.errors.push(json2object_Error.IncorrectType(variable,"Array<formatter.config.WrapCondition>",pos));
		json2object_reader_BaseParser.prototype.onIncorrectType.call(this,pos,variable);
	}
	,loadJsonNull: function(pos,variable) {
		this.value = null;
	}
	,loadJsonArray: function(a,pos,variable) {
		this.value = this.loadJsonArrayValue(a,($_=new JsonParser_$122(this.errors,this.putils,2),$bind($_,$_.loadJson)),variable);
	}
	,__class__: JsonParser_$119
});
var JsonParser_$12 = function(errors,putils,errorType) {
	if(errorType == null) {
		errorType = 0;
	}
	json2object_reader_BaseParser.call(this,errors,putils,errorType);
};
JsonParser_$12.__name__ = true;
JsonParser_$12.__super__ = json2object_reader_BaseParser;
JsonParser_$12.prototype = $extend(json2object_reader_BaseParser.prototype,{
	onIncorrectType: function(pos,variable) {
		this.errors.push(json2object_Error.IncorrectType(variable,"{ ?beforeError : Null<Int>, ?beforeEnd : Null<Int>, ?beforeElse : Null<Int>, ?afterIf : Null<Int>, ?afterError : Null<Int>, ?afterElse : Null<Int> }",pos));
		json2object_reader_BaseParser.prototype.onIncorrectType.call(this,pos,variable);
	}
	,loadJsonNull: function(pos,variable) {
		this.value = null;
	}
	,loadJsonObject: function(o,pos,variable) {
		var assigned = new haxe_ds_StringMap();
		this.objectSetupAssign(assigned,["afterElse","afterError","afterIf","beforeElse","beforeEnd","beforeError"],[true,true,true,true,true,true]);
		this.value = this.getAuto();
		var _g = 0;
		while(_g < o.length) {
			var field = o[_g];
			++_g;
			switch(field.name) {
			case "afterElse":
				this.value.afterElse = this.loadObjectField(($_=new JsonParser_$96(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"afterElse",assigned,this.value.afterElse,pos);
				break;
			case "afterError":
				this.value.afterError = this.loadObjectField(($_=new JsonParser_$96(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"afterError",assigned,this.value.afterError,pos);
				break;
			case "afterIf":
				this.value.afterIf = this.loadObjectField(($_=new JsonParser_$96(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"afterIf",assigned,this.value.afterIf,pos);
				break;
			case "beforeElse":
				this.value.beforeElse = this.loadObjectField(($_=new JsonParser_$96(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"beforeElse",assigned,this.value.beforeElse,pos);
				break;
			case "beforeEnd":
				this.value.beforeEnd = this.loadObjectField(($_=new JsonParser_$96(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"beforeEnd",assigned,this.value.beforeEnd,pos);
				break;
			case "beforeError":
				this.value.beforeError = this.loadObjectField(($_=new JsonParser_$96(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"beforeError",assigned,this.value.beforeError,pos);
				break;
			default:
				this.errors.push(json2object_Error.UnknownVariable(field.name,this.putils.convertPosition(field.namePos)));
			}
		}
		this.objectErrors(assigned,pos);
	}
	,getAuto: function() {
		return { afterElse : 0, afterError : 0, afterIf : 0, beforeElse : 0, beforeEnd : 0, beforeError : 0};
	}
	,__class__: JsonParser_$12
});
var JsonParser_$120 = function(errors,putils,errorType) {
	if(errorType == null) {
		errorType = 0;
	}
	json2object_reader_BaseParser.call(this,errors,putils,errorType);
};
JsonParser_$120.__name__ = true;
JsonParser_$120.__super__ = json2object_reader_BaseParser;
JsonParser_$120.prototype = $extend(json2object_reader_BaseParser.prototype,{
	onIncorrectType: function(pos,variable) {
		this.value = "onePerLine";
		this.errors.push(json2object_Error.IncorrectType(variable,"formatter.config.WrappingType",pos));
		this.objectThrow(pos,variable);
	}
	,loadJsonNull: function(pos,variable) {
		this.value = null;
	}
	,loadJsonString: function(s,pos,variable) {
		this.value = this.loadString(s,pos,variable,["onePerLine","onePerLineAfterFirst","equalNumber","fillLine","fillLineWithLeadingBreak","noWrap","keep"],"onePerLine");
	}
	,__class__: JsonParser_$120
});
var JsonParser_$122 = function(errors,putils,errorType) {
	if(errorType == null) {
		errorType = 0;
	}
	json2object_reader_BaseParser.call(this,errors,putils,errorType);
};
JsonParser_$122.__name__ = true;
JsonParser_$122.__super__ = json2object_reader_BaseParser;
JsonParser_$122.prototype = $extend(json2object_reader_BaseParser.prototype,{
	onIncorrectType: function(pos,variable) {
		this.errors.push(json2object_Error.IncorrectType(variable,"{ ?value : Null<Int>, cond : formatter.config.WrapConditionType }",pos));
		json2object_reader_BaseParser.prototype.onIncorrectType.call(this,pos,variable);
	}
	,loadJsonNull: function(pos,variable) {
		this.value = null;
	}
	,loadJsonObject: function(o,pos,variable) {
		var assigned = new haxe_ds_StringMap();
		this.objectSetupAssign(assigned,["cond","value"],[false,true]);
		this.value = this.getAuto();
		var _g = 0;
		while(_g < o.length) {
			var field = o[_g];
			++_g;
			switch(field.name) {
			case "cond":
				this.value.cond = this.loadObjectField(($_=new JsonParser_$123(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"cond",assigned,this.value.cond,pos);
				break;
			case "value":
				this.value.value = this.loadObjectField(($_=new JsonParser_$96(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"value",assigned,this.value.value,pos);
				break;
			default:
				this.errors.push(json2object_Error.UnknownVariable(field.name,this.putils.convertPosition(field.namePos)));
			}
		}
		this.objectErrors(assigned,pos);
	}
	,getAuto: function() {
		return { cond : new JsonParser_$123([],this.putils,0).loadJson(new hxjsonast_Json(hxjsonast_JsonValue.JNull,new hxjsonast_Position("",0,1))), value : 1};
	}
	,__class__: JsonParser_$122
});
var JsonParser_$123 = function(errors,putils,errorType) {
	if(errorType == null) {
		errorType = 0;
	}
	json2object_reader_BaseParser.call(this,errors,putils,errorType);
};
JsonParser_$123.__name__ = true;
JsonParser_$123.__super__ = json2object_reader_BaseParser;
JsonParser_$123.prototype = $extend(json2object_reader_BaseParser.prototype,{
	onIncorrectType: function(pos,variable) {
		this.value = "itemCount >= n";
		this.errors.push(json2object_Error.IncorrectType(variable,"formatter.config.WrapConditionType",pos));
		this.objectThrow(pos,variable);
	}
	,loadJsonNull: function(pos,variable) {
		this.value = null;
	}
	,loadJsonString: function(s,pos,variable) {
		this.value = this.loadString(s,pos,variable,["itemCount >= n","itemCount <= n","anyItemLength >= n","anyItemLength <= n","totalItemLength >= n","totalItemLength <= n","lineLength >= n","lineLength <= n","hasMultilineItems","exceedsMaxLineLength"],"itemCount >= n");
	}
	,__class__: JsonParser_$123
});
var JsonParser_$125 = function(errors,putils,errorType) {
	if(errorType == null) {
		errorType = 0;
	}
	json2object_reader_BaseParser.call(this,errors,putils,errorType);
};
JsonParser_$125.__name__ = true;
JsonParser_$125.__super__ = json2object_reader_BaseParser;
JsonParser_$125.prototype = $extend(json2object_reader_BaseParser.prototype,{
	onIncorrectType: function(pos,variable) {
		this.value = "none";
		this.errors.push(json2object_Error.IncorrectType(variable,"formatter.config.WhitespacePolicy",pos));
		this.objectThrow(pos,variable);
	}
	,loadJsonNull: function(pos,variable) {
		this.value = null;
	}
	,loadJsonString: function(s,pos,variable) {
		this.value = this.loadString(s,pos,variable,["none","before","noneBefore","onlyBefore","after","onlyAfter","noneAfter","around"],"none");
	}
	,__class__: JsonParser_$125
});
var JsonParser_$15 = function(errors,putils,errorType) {
	if(errorType == null) {
		errorType = 0;
	}
	json2object_reader_BaseParser.call(this,errors,putils,errorType);
};
JsonParser_$15.__name__ = true;
JsonParser_$15.__super__ = json2object_reader_BaseParser;
JsonParser_$15.prototype = $extend(json2object_reader_BaseParser.prototype,{
	onIncorrectType: function(pos,variable) {
		this.errors.push(json2object_Error.IncorrectType(variable,"{ ?existingBetweenFields : Null<formatter.config.KeepEmptyLinesPolicy>, ?endType : Null<Int>, ?betweenVars : Null<Int>, ?betweenFunctions : Null<Int>, ?beginType : Null<Int>, ?afterVars : Null<Int> }",pos));
		json2object_reader_BaseParser.prototype.onIncorrectType.call(this,pos,variable);
	}
	,loadJsonNull: function(pos,variable) {
		this.value = null;
	}
	,loadJsonObject: function(o,pos,variable) {
		var assigned = new haxe_ds_StringMap();
		this.objectSetupAssign(assigned,["afterVars","beginType","betweenFunctions","betweenVars","endType","existingBetweenFields"],[true,true,true,true,true,true]);
		this.value = this.getAuto();
		var _g = 0;
		while(_g < o.length) {
			var field = o[_g];
			++_g;
			switch(field.name) {
			case "afterVars":
				this.value.afterVars = this.loadObjectField(($_=new JsonParser_$96(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"afterVars",assigned,this.value.afterVars,pos);
				break;
			case "beginType":
				this.value.beginType = this.loadObjectField(($_=new JsonParser_$96(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"beginType",assigned,this.value.beginType,pos);
				break;
			case "betweenFunctions":
				this.value.betweenFunctions = this.loadObjectField(($_=new JsonParser_$96(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"betweenFunctions",assigned,this.value.betweenFunctions,pos);
				break;
			case "betweenVars":
				this.value.betweenVars = this.loadObjectField(($_=new JsonParser_$96(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"betweenVars",assigned,this.value.betweenVars,pos);
				break;
			case "endType":
				this.value.endType = this.loadObjectField(($_=new JsonParser_$96(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"endType",assigned,this.value.endType,pos);
				break;
			case "existingBetweenFields":
				this.value.existingBetweenFields = this.loadObjectField(($_=new JsonParser_$198(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"existingBetweenFields",assigned,this.value.existingBetweenFields,pos);
				break;
			default:
				this.errors.push(json2object_Error.UnknownVariable(field.name,this.putils.convertPosition(field.namePos)));
			}
		}
		this.objectErrors(assigned,pos);
	}
	,getAuto: function() {
		return { afterVars : 1, beginType : 0, betweenFunctions : 1, betweenVars : 0, endType : 0, existingBetweenFields : "keep"};
	}
	,__class__: JsonParser_$15
});
var JsonParser_$165 = function(errors,putils,errorType) {
	if(errorType == null) {
		errorType = 0;
	}
	json2object_reader_BaseParser.call(this,errors,putils,errorType);
};
JsonParser_$165.__name__ = true;
JsonParser_$165.__super__ = json2object_reader_BaseParser;
JsonParser_$165.prototype = $extend(json2object_reader_BaseParser.prototype,{
	onIncorrectType: function(pos,variable) {
		this.value = "same";
		this.errors.push(json2object_Error.IncorrectType(variable,"formatter.config.SameLinePolicy",pos));
		this.objectThrow(pos,variable);
	}
	,loadJsonNull: function(pos,variable) {
		this.value = null;
	}
	,loadJsonString: function(s,pos,variable) {
		this.value = this.loadString(s,pos,variable,["same","next","keep"],"same");
	}
	,__class__: JsonParser_$165
});
var JsonParser_$168 = function(errors,putils,errorType) {
	if(errorType == null) {
		errorType = 0;
	}
	json2object_reader_BaseParser.call(this,errors,putils,errorType);
};
JsonParser_$168.__name__ = true;
JsonParser_$168.__super__ = json2object_reader_BaseParser;
JsonParser_$168.prototype = $extend(json2object_reader_BaseParser.prototype,{
	onIncorrectType: function(pos,variable) {
		this.errors.push(json2object_Error.IncorrectType(variable,"{ ?rightCurly : Null<formatter.config.RightCurlyLineEndPolicy>, ?leftCurly : Null<formatter.config.LeftCurlyLineEndPolicy>, ?emptyCurly : Null<formatter.config.EmptyCurlyPolicy> }",pos));
		json2object_reader_BaseParser.prototype.onIncorrectType.call(this,pos,variable);
	}
	,loadJsonNull: function(pos,variable) {
		this.value = null;
	}
	,loadJsonObject: function(o,pos,variable) {
		var assigned = new haxe_ds_StringMap();
		this.objectSetupAssign(assigned,["emptyCurly","leftCurly","rightCurly"],[true,true,true]);
		this.value = this.getAuto();
		var _g = 0;
		while(_g < o.length) {
			var field = o[_g];
			++_g;
			switch(field.name) {
			case "emptyCurly":
				this.value.emptyCurly = this.loadObjectField(($_=new JsonParser_$176(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"emptyCurly",assigned,this.value.emptyCurly,pos);
				break;
			case "leftCurly":
				this.value.leftCurly = this.loadObjectField(($_=new JsonParser_$178(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"leftCurly",assigned,this.value.leftCurly,pos);
				break;
			case "rightCurly":
				this.value.rightCurly = this.loadObjectField(($_=new JsonParser_$186(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"rightCurly",assigned,this.value.rightCurly,pos);
				break;
			default:
				this.errors.push(json2object_Error.UnknownVariable(field.name,this.putils.convertPosition(field.namePos)));
			}
		}
		this.objectErrors(assigned,pos);
	}
	,getAuto: function() {
		return { emptyCurly : "noBreak", leftCurly : "after", rightCurly : "both"};
	}
	,__class__: JsonParser_$168
});
var JsonParser_$174 = function(errors,putils,errorType) {
	if(errorType == null) {
		errorType = 0;
	}
	json2object_reader_BaseParser.call(this,errors,putils,errorType);
};
JsonParser_$174.__name__ = true;
JsonParser_$174.__super__ = json2object_reader_BaseParser;
JsonParser_$174.prototype = $extend(json2object_reader_BaseParser.prototype,{
	onIncorrectType: function(pos,variable) {
		this.value = "none";
		this.errors.push(json2object_Error.IncorrectType(variable,"formatter.config.CaseColonLineEndPolicy",pos));
		this.objectThrow(pos,variable);
	}
	,loadJsonNull: function(pos,variable) {
		this.value = null;
	}
	,loadJsonString: function(s,pos,variable) {
		this.value = this.loadString(s,pos,variable,["none","after"],"none");
	}
	,__class__: JsonParser_$174
});
var JsonParser_$176 = function(errors,putils,errorType) {
	if(errorType == null) {
		errorType = 0;
	}
	json2object_reader_BaseParser.call(this,errors,putils,errorType);
};
JsonParser_$176.__name__ = true;
JsonParser_$176.__super__ = json2object_reader_BaseParser;
JsonParser_$176.prototype = $extend(json2object_reader_BaseParser.prototype,{
	onIncorrectType: function(pos,variable) {
		this.value = "noBreak";
		this.errors.push(json2object_Error.IncorrectType(variable,"formatter.config.EmptyCurlyPolicy",pos));
		this.objectThrow(pos,variable);
	}
	,loadJsonNull: function(pos,variable) {
		this.value = null;
	}
	,loadJsonString: function(s,pos,variable) {
		this.value = this.loadString(s,pos,variable,["noBreak","break"],"noBreak");
	}
	,__class__: JsonParser_$176
});
var JsonParser_$178 = function(errors,putils,errorType) {
	if(errorType == null) {
		errorType = 0;
	}
	json2object_reader_BaseParser.call(this,errors,putils,errorType);
};
JsonParser_$178.__name__ = true;
JsonParser_$178.__super__ = json2object_reader_BaseParser;
JsonParser_$178.prototype = $extend(json2object_reader_BaseParser.prototype,{
	onIncorrectType: function(pos,variable) {
		this.value = "none";
		this.errors.push(json2object_Error.IncorrectType(variable,"formatter.config.LeftCurlyLineEndPolicy",pos));
		this.objectThrow(pos,variable);
	}
	,loadJsonNull: function(pos,variable) {
		this.value = null;
	}
	,loadJsonString: function(s,pos,variable) {
		this.value = this.loadString(s,pos,variable,["none","after","before","both"],"none");
	}
	,__class__: JsonParser_$178
});
var JsonParser_$18 = function(errors,putils,errorType) {
	if(errorType == null) {
		errorType = 0;
	}
	json2object_reader_BaseParser.call(this,errors,putils,errorType);
};
JsonParser_$18.__name__ = true;
JsonParser_$18.__super__ = json2object_reader_BaseParser;
JsonParser_$18.prototype = $extend(json2object_reader_BaseParser.prototype,{
	onIncorrectType: function(pos,variable) {
		this.errors.push(json2object_Error.IncorrectType(variable,"{ ?existingBetweenFields : Null<formatter.config.KeepEmptyLinesPolicy>, ?endType : Null<Int>, ?betweenFields : Null<Int>, ?beginType : Null<Int> }",pos));
		json2object_reader_BaseParser.prototype.onIncorrectType.call(this,pos,variable);
	}
	,loadJsonNull: function(pos,variable) {
		this.value = null;
	}
	,loadJsonObject: function(o,pos,variable) {
		var assigned = new haxe_ds_StringMap();
		this.objectSetupAssign(assigned,["beginType","betweenFields","endType","existingBetweenFields"],[true,true,true,true]);
		this.value = this.getAuto();
		var _g = 0;
		while(_g < o.length) {
			var field = o[_g];
			++_g;
			switch(field.name) {
			case "beginType":
				this.value.beginType = this.loadObjectField(($_=new JsonParser_$96(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"beginType",assigned,this.value.beginType,pos);
				break;
			case "betweenFields":
				this.value.betweenFields = this.loadObjectField(($_=new JsonParser_$96(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"betweenFields",assigned,this.value.betweenFields,pos);
				break;
			case "endType":
				this.value.endType = this.loadObjectField(($_=new JsonParser_$96(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"endType",assigned,this.value.endType,pos);
				break;
			case "existingBetweenFields":
				this.value.existingBetweenFields = this.loadObjectField(($_=new JsonParser_$198(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"existingBetweenFields",assigned,this.value.existingBetweenFields,pos);
				break;
			default:
				this.errors.push(json2object_Error.UnknownVariable(field.name,this.putils.convertPosition(field.namePos)));
			}
		}
		this.objectErrors(assigned,pos);
	}
	,getAuto: function() {
		return { beginType : 0, betweenFields : 0, endType : 0, existingBetweenFields : "keep"};
	}
	,__class__: JsonParser_$18
});
var JsonParser_$180 = function(errors,putils,errorType) {
	if(errorType == null) {
		errorType = 0;
	}
	json2object_reader_BaseParser.call(this,errors,putils,errorType);
};
JsonParser_$180.__name__ = true;
JsonParser_$180.__super__ = json2object_reader_BaseParser;
JsonParser_$180.prototype = $extend(json2object_reader_BaseParser.prototype,{
	onIncorrectType: function(pos,variable) {
		this.value = "auto";
		this.errors.push(json2object_Error.IncorrectType(variable,"formatter.config.LineEndCharacter",pos));
		this.objectThrow(pos,variable);
	}
	,loadJsonNull: function(pos,variable) {
		this.value = null;
	}
	,loadJsonString: function(s,pos,variable) {
		this.value = this.loadString(s,pos,variable,["auto","CR","LF","CRLF"],"auto");
	}
	,__class__: JsonParser_$180
});
var JsonParser_$182 = function(errors,putils,errorType) {
	if(errorType == null) {
		errorType = 0;
	}
	json2object_reader_BaseParser.call(this,errors,putils,errorType);
};
JsonParser_$182.__name__ = true;
JsonParser_$182.__super__ = json2object_reader_BaseParser;
JsonParser_$182.prototype = $extend(json2object_reader_BaseParser.prototype,{
	onIncorrectType: function(pos,variable) {
		this.value = "none";
		this.errors.push(json2object_Error.IncorrectType(variable,"formatter.config.AtLineEndPolicy",pos));
		this.objectThrow(pos,variable);
	}
	,loadJsonNull: function(pos,variable) {
		this.value = null;
	}
	,loadJsonString: function(s,pos,variable) {
		this.value = this.loadString(s,pos,variable,["none","after","afterLast","forceAfterLast"],"none");
	}
	,__class__: JsonParser_$182
});
var JsonParser_$186 = function(errors,putils,errorType) {
	if(errorType == null) {
		errorType = 0;
	}
	json2object_reader_BaseParser.call(this,errors,putils,errorType);
};
JsonParser_$186.__name__ = true;
JsonParser_$186.__super__ = json2object_reader_BaseParser;
JsonParser_$186.prototype = $extend(json2object_reader_BaseParser.prototype,{
	onIncorrectType: function(pos,variable) {
		this.value = "none";
		this.errors.push(json2object_Error.IncorrectType(variable,"formatter.config.RightCurlyLineEndPolicy",pos));
		this.objectThrow(pos,variable);
	}
	,loadJsonNull: function(pos,variable) {
		this.value = null;
	}
	,loadJsonString: function(s,pos,variable) {
		this.value = this.loadString(s,pos,variable,["none","before","after","both"],"none");
	}
	,__class__: JsonParser_$186
});
var JsonParser_$188 = function(errors,putils,errorType) {
	if(errorType == null) {
		errorType = 0;
	}
	json2object_reader_BaseParser.call(this,errors,putils,errorType);
};
JsonParser_$188.__name__ = true;
JsonParser_$188.__super__ = json2object_reader_BaseParser;
JsonParser_$188.prototype = $extend(json2object_reader_BaseParser.prototype,{
	onIncorrectType: function(pos,variable) {
		this.value = "none";
		this.errors.push(json2object_Error.IncorrectType(variable,"formatter.config.SharpLineEndPolicy",pos));
		this.objectThrow(pos,variable);
	}
	,loadJsonNull: function(pos,variable) {
		this.value = null;
	}
	,loadJsonString: function(s,pos,variable) {
		this.value = this.loadString(s,pos,variable,["none","after"],"none");
	}
	,__class__: JsonParser_$188
});
var JsonParser_$192 = function(errors,putils,errorType) {
	if(errorType == null) {
		errorType = 0;
	}
	json2object_reader_BaseParser.call(this,errors,putils,errorType);
};
JsonParser_$192.__name__ = true;
JsonParser_$192.__super__ = json2object_reader_BaseParser;
JsonParser_$192.prototype = $extend(json2object_reader_BaseParser.prototype,{
	onIncorrectType: function(pos,variable) {
		this.errors.push(json2object_Error.IncorrectType(variable,"String",pos));
		json2object_reader_BaseParser.prototype.onIncorrectType.call(this,pos,variable);
	}
	,loadJsonNull: function(pos,variable) {
		this.value = null;
	}
	,loadJsonString: function(s,pos,variable) {
		this.value = s;
	}
	,__class__: JsonParser_$192
});
var JsonParser_$194 = function(errors,putils,errorType) {
	if(errorType == null) {
		errorType = 0;
	}
	json2object_reader_BaseParser.call(this,errors,putils,errorType);
};
JsonParser_$194.__name__ = true;
JsonParser_$194.__super__ = json2object_reader_BaseParser;
JsonParser_$194.prototype = $extend(json2object_reader_BaseParser.prototype,{
	onIncorrectType: function(pos,variable) {
		this.value = "fixedZero";
		this.errors.push(json2object_Error.IncorrectType(variable,"formatter.config.ConditionalIndentationPolicy",pos));
		this.objectThrow(pos,variable);
	}
	,loadJsonNull: function(pos,variable) {
		this.value = null;
	}
	,loadJsonString: function(s,pos,variable) {
		this.value = this.loadString(s,pos,variable,["fixedZero","fixedZeroIncrease","fixedZeroIncreaseBlocks","aligned","alignedNestedIncrease","alignedIncrease","alignedDecrease"],"fixedZero");
	}
	,__class__: JsonParser_$194
});
var JsonParser_$196 = function(errors,putils,errorType) {
	if(errorType == null) {
		errorType = 0;
	}
	json2object_reader_BaseParser.call(this,errors,putils,errorType);
};
JsonParser_$196.__name__ = true;
JsonParser_$196.__super__ = json2object_reader_BaseParser;
JsonParser_$196.prototype = $extend(json2object_reader_BaseParser.prototype,{
	onIncorrectType: function(pos,variable) {
		this.value = "all";
		this.errors.push(json2object_Error.IncorrectType(variable,"formatter.config.BetweenImportsEmptyLinesLevel",pos));
		this.objectThrow(pos,variable);
	}
	,loadJsonNull: function(pos,variable) {
		this.value = null;
	}
	,loadJsonString: function(s,pos,variable) {
		this.value = this.loadString(s,pos,variable,["all","firstLevelPackage","secondLevelPackage","thirdLevelPackage","fourthLevelPackage","fifthLevelPackage","fullPackage"],"all");
	}
	,__class__: JsonParser_$196
});
var JsonParser_$198 = function(errors,putils,errorType) {
	if(errorType == null) {
		errorType = 0;
	}
	json2object_reader_BaseParser.call(this,errors,putils,errorType);
};
JsonParser_$198.__name__ = true;
JsonParser_$198.__super__ = json2object_reader_BaseParser;
JsonParser_$198.prototype = $extend(json2object_reader_BaseParser.prototype,{
	onIncorrectType: function(pos,variable) {
		this.value = "keep";
		this.errors.push(json2object_Error.IncorrectType(variable,"formatter.config.KeepEmptyLinesPolicy",pos));
		this.objectThrow(pos,variable);
	}
	,loadJsonNull: function(pos,variable) {
		this.value = null;
	}
	,loadJsonString: function(s,pos,variable) {
		this.value = this.loadString(s,pos,variable,["keep","remove"],"keep");
	}
	,__class__: JsonParser_$198
});
var JsonParser_$202 = function(errors,putils,errorType) {
	if(errorType == null) {
		errorType = 0;
	}
	json2object_reader_BaseParser.call(this,errors,putils,errorType);
};
JsonParser_$202.__name__ = true;
JsonParser_$202.__super__ = json2object_reader_BaseParser;
JsonParser_$202.prototype = $extend(json2object_reader_BaseParser.prototype,{
	onIncorrectType: function(pos,variable) {
		this.value = "ignore";
		this.errors.push(json2object_Error.IncorrectType(variable,"formatter.config.CommentEmptyLinesPolicy",pos));
		this.objectThrow(pos,variable);
	}
	,loadJsonNull: function(pos,variable) {
		this.value = null;
	}
	,loadJsonString: function(s,pos,variable) {
		this.value = this.loadString(s,pos,variable,["ignore","none","one"],"ignore");
	}
	,__class__: JsonParser_$202
});
var JsonParser_$21 = function(errors,putils,errorType) {
	if(errorType == null) {
		errorType = 0;
	}
	json2object_reader_BaseParser.call(this,errors,putils,errorType);
};
JsonParser_$21.__name__ = true;
JsonParser_$21.__super__ = json2object_reader_BaseParser;
JsonParser_$21.prototype = $extend(json2object_reader_BaseParser.prototype,{
	onIncorrectType: function(pos,variable) {
		this.errors.push(json2object_Error.IncorrectType(variable,"{ ?existingBetweenFields : Null<formatter.config.KeepEmptyLinesPolicy>, ?endType : Null<Int>, ?betweenVars : Null<Int>, ?betweenFunctions : Null<Int>, ?beginType : Null<Int>, ?afterVars : Null<Int> }",pos));
		json2object_reader_BaseParser.prototype.onIncorrectType.call(this,pos,variable);
	}
	,loadJsonNull: function(pos,variable) {
		this.value = null;
	}
	,loadJsonObject: function(o,pos,variable) {
		var assigned = new haxe_ds_StringMap();
		this.objectSetupAssign(assigned,["afterVars","beginType","betweenFunctions","betweenVars","endType","existingBetweenFields"],[true,true,true,true,true,true]);
		this.value = this.getAuto();
		var _g = 0;
		while(_g < o.length) {
			var field = o[_g];
			++_g;
			switch(field.name) {
			case "afterVars":
				this.value.afterVars = this.loadObjectField(($_=new JsonParser_$96(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"afterVars",assigned,this.value.afterVars,pos);
				break;
			case "beginType":
				this.value.beginType = this.loadObjectField(($_=new JsonParser_$96(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"beginType",assigned,this.value.beginType,pos);
				break;
			case "betweenFunctions":
				this.value.betweenFunctions = this.loadObjectField(($_=new JsonParser_$96(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"betweenFunctions",assigned,this.value.betweenFunctions,pos);
				break;
			case "betweenVars":
				this.value.betweenVars = this.loadObjectField(($_=new JsonParser_$96(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"betweenVars",assigned,this.value.betweenVars,pos);
				break;
			case "endType":
				this.value.endType = this.loadObjectField(($_=new JsonParser_$96(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"endType",assigned,this.value.endType,pos);
				break;
			case "existingBetweenFields":
				this.value.existingBetweenFields = this.loadObjectField(($_=new JsonParser_$198(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"existingBetweenFields",assigned,this.value.existingBetweenFields,pos);
				break;
			default:
				this.errors.push(json2object_Error.UnknownVariable(field.name,this.putils.convertPosition(field.namePos)));
			}
		}
		this.objectErrors(assigned,pos);
	}
	,getAuto: function() {
		return { afterVars : 0, beginType : 0, betweenFunctions : 0, betweenVars : 0, endType : 0, existingBetweenFields : "keep"};
	}
	,__class__: JsonParser_$21
});
var JsonParser_$218 = function(errors,putils,errorType) {
	if(errorType == null) {
		errorType = 0;
	}
	json2object_reader_BaseParser.call(this,errors,putils,errorType);
};
JsonParser_$218.__name__ = true;
JsonParser_$218.__super__ = json2object_reader_BaseParser;
JsonParser_$218.prototype = $extend(json2object_reader_BaseParser.prototype,{
	onIncorrectType: function(pos,variable) {
		this.value = "keep";
		this.errors.push(json2object_Error.IncorrectType(variable,"formatter.config.LineCommentEmptyLinePolicy",pos));
		this.objectThrow(pos,variable);
	}
	,loadJsonNull: function(pos,variable) {
		this.value = null;
	}
	,loadJsonString: function(s,pos,variable) {
		this.value = this.loadString(s,pos,variable,["keep","one","none"],"keep");
	}
	,__class__: JsonParser_$218
});
var JsonParser_$24 = function(errors,putils,errorType) {
	if(errorType == null) {
		errorType = 0;
	}
	json2object_reader_BaseParser.call(this,errors,putils,errorType);
};
JsonParser_$24.__name__ = true;
JsonParser_$24.__super__ = json2object_reader_BaseParser;
JsonParser_$24.prototype = $extend(json2object_reader_BaseParser.prototype,{
	onIncorrectType: function(pos,variable) {
		this.errors.push(json2object_Error.IncorrectType(variable,"{ ?betweenImportsLevel : Null<formatter.config.BetweenImportsEmptyLinesLevel>, ?betweenImports : Null<Int>, ?beforeUsing : Null<Int>, ?beforeType : Null<Int> }",pos));
		json2object_reader_BaseParser.prototype.onIncorrectType.call(this,pos,variable);
	}
	,loadJsonNull: function(pos,variable) {
		this.value = null;
	}
	,loadJsonObject: function(o,pos,variable) {
		var assigned = new haxe_ds_StringMap();
		this.objectSetupAssign(assigned,["beforeType","beforeUsing","betweenImports","betweenImportsLevel"],[true,true,true,true]);
		this.value = this.getAuto();
		var _g = 0;
		while(_g < o.length) {
			var field = o[_g];
			++_g;
			switch(field.name) {
			case "beforeType":
				this.value.beforeType = this.loadObjectField(($_=new JsonParser_$96(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"beforeType",assigned,this.value.beforeType,pos);
				break;
			case "beforeUsing":
				this.value.beforeUsing = this.loadObjectField(($_=new JsonParser_$96(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"beforeUsing",assigned,this.value.beforeUsing,pos);
				break;
			case "betweenImports":
				this.value.betweenImports = this.loadObjectField(($_=new JsonParser_$96(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"betweenImports",assigned,this.value.betweenImports,pos);
				break;
			case "betweenImportsLevel":
				this.value.betweenImportsLevel = this.loadObjectField(($_=new JsonParser_$196(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"betweenImportsLevel",assigned,this.value.betweenImportsLevel,pos);
				break;
			default:
				this.errors.push(json2object_Error.UnknownVariable(field.name,this.putils.convertPosition(field.namePos)));
			}
		}
		this.objectErrors(assigned,pos);
	}
	,getAuto: function() {
		return { beforeType : 1, beforeUsing : 1, betweenImports : 0, betweenImportsLevel : "all"};
	}
	,__class__: JsonParser_$24
});
var JsonParser_$33 = function(errors,putils,errorType) {
	if(errorType == null) {
		errorType = 0;
	}
	json2object_reader_BaseParser.call(this,errors,putils,errorType);
};
JsonParser_$33.__name__ = true;
JsonParser_$33.__super__ = json2object_reader_BaseParser;
JsonParser_$33.prototype = $extend(json2object_reader_BaseParser.prototype,{
	onIncorrectType: function(pos,variable) {
		this.errors.push(json2object_Error.IncorrectType(variable,"{ ?trailingWhitespace : Null<Bool>, ?tabWidth : Null<Int>, ?indentObjectLiteral : Null<Bool>, ?indentComplexValueExpressions : Null<Bool>, ?indentCaseLabels : Null<Bool>, ?conditionalPolicy : Null<formatter.config.ConditionalIndentationPolicy>, ?character : Null<String> }",pos));
		json2object_reader_BaseParser.prototype.onIncorrectType.call(this,pos,variable);
	}
	,loadJsonNull: function(pos,variable) {
		this.value = null;
	}
	,loadJsonObject: function(o,pos,variable) {
		var assigned = new haxe_ds_StringMap();
		this.objectSetupAssign(assigned,["character","conditionalPolicy","indentCaseLabels","indentComplexValueExpressions","indentObjectLiteral","tabWidth","trailingWhitespace"],[true,true,true,true,true,true,true]);
		this.value = this.getAuto();
		var _g = 0;
		while(_g < o.length) {
			var field = o[_g];
			++_g;
			switch(field.name) {
			case "character":
				this.value.character = this.loadObjectField(($_=new JsonParser_$192(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"character",assigned,this.value.character,pos);
				break;
			case "conditionalPolicy":
				this.value.conditionalPolicy = this.loadObjectField(($_=new JsonParser_$194(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"conditionalPolicy",assigned,this.value.conditionalPolicy,pos);
				break;
			case "indentCaseLabels":
				this.value.indentCaseLabels = this.loadObjectField(($_=new JsonParser_$62(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"indentCaseLabels",assigned,this.value.indentCaseLabels,pos);
				break;
			case "indentComplexValueExpressions":
				this.value.indentComplexValueExpressions = this.loadObjectField(($_=new JsonParser_$62(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"indentComplexValueExpressions",assigned,this.value.indentComplexValueExpressions,pos);
				break;
			case "indentObjectLiteral":
				this.value.indentObjectLiteral = this.loadObjectField(($_=new JsonParser_$62(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"indentObjectLiteral",assigned,this.value.indentObjectLiteral,pos);
				break;
			case "tabWidth":
				this.value.tabWidth = this.loadObjectField(($_=new JsonParser_$96(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"tabWidth",assigned,this.value.tabWidth,pos);
				break;
			case "trailingWhitespace":
				this.value.trailingWhitespace = this.loadObjectField(($_=new JsonParser_$62(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"trailingWhitespace",assigned,this.value.trailingWhitespace,pos);
				break;
			default:
				this.errors.push(json2object_Error.UnknownVariable(field.name,this.putils.convertPosition(field.namePos)));
			}
		}
		this.objectErrors(assigned,pos);
	}
	,getAuto: function() {
		return { character : "tab", conditionalPolicy : "aligned", indentCaseLabels : true, indentComplexValueExpressions : false, indentObjectLiteral : true, tabWidth : 4, trailingWhitespace : false};
	}
	,__class__: JsonParser_$33
});
var JsonParser_$36 = function(errors,putils,errorType) {
	if(errorType == null) {
		errorType = 0;
	}
	json2object_reader_BaseParser.call(this,errors,putils,errorType);
};
JsonParser_$36.__name__ = true;
JsonParser_$36.__super__ = json2object_reader_BaseParser;
JsonParser_$36.prototype = $extend(json2object_reader_BaseParser.prototype,{
	onIncorrectType: function(pos,variable) {
		this.errors.push(json2object_Error.IncorrectType(variable,"{ ?typedefCurly : Null<formatter.config.CurlyLineEndPolicy>, ?sharp : Null<formatter.config.SharpLineEndPolicy>, ?rightCurly : Null<formatter.config.RightCurlyLineEndPolicy>, ?objectLiteralCurly : Null<formatter.config.CurlyLineEndPolicy>, ?metadataVar : Null<formatter.config.AtLineEndPolicy>, ?metadataType : Null<formatter.config.AtLineEndPolicy>, ?metadataOther : Null<formatter.config.AtLineEndPolicy>, ?metadataFunction : Null<formatter.config.AtLineEndPolicy>, ?lineEndCharacter : Null<formatter.config.LineEndCharacter>, ?leftCurly : Null<formatter.config.LeftCurlyLineEndPolicy>, ?emptyCurly : Null<formatter.config.EmptyCurlyPolicy>, ?caseColon : Null<formatter.config.CaseColonLineEndPolicy>, ?blockCurly : Null<formatter.config.CurlyLineEndPolicy>, ?anonTypeCurly : Null<formatter.config.CurlyLineEndPolicy>, ?anonFunctionCurly : Null<formatter.config.CurlyLineEndPolicy> }",pos));
		json2object_reader_BaseParser.prototype.onIncorrectType.call(this,pos,variable);
	}
	,loadJsonNull: function(pos,variable) {
		this.value = null;
	}
	,loadJsonObject: function(o,pos,variable) {
		var assigned = new haxe_ds_StringMap();
		this.objectSetupAssign(assigned,["anonFunctionCurly","anonTypeCurly","blockCurly","caseColon","emptyCurly","leftCurly","lineEndCharacter","metadataFunction","metadataOther","metadataType","metadataVar","objectLiteralCurly","rightCurly","sharp","typedefCurly"],[true,true,true,true,true,true,true,true,true,true,true,true,true,true,true]);
		this.value = this.getAuto();
		var _g = 0;
		while(_g < o.length) {
			var field = o[_g];
			++_g;
			switch(field.name) {
			case "anonFunctionCurly":
				this.value.anonFunctionCurly = this.loadObjectField(($_=new JsonParser_$168(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"anonFunctionCurly",assigned,this.value.anonFunctionCurly,pos);
				break;
			case "anonTypeCurly":
				this.value.anonTypeCurly = this.loadObjectField(($_=new JsonParser_$168(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"anonTypeCurly",assigned,this.value.anonTypeCurly,pos);
				break;
			case "blockCurly":
				this.value.blockCurly = this.loadObjectField(($_=new JsonParser_$168(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"blockCurly",assigned,this.value.blockCurly,pos);
				break;
			case "caseColon":
				this.value.caseColon = this.loadObjectField(($_=new JsonParser_$174(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"caseColon",assigned,this.value.caseColon,pos);
				break;
			case "emptyCurly":
				this.value.emptyCurly = this.loadObjectField(($_=new JsonParser_$176(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"emptyCurly",assigned,this.value.emptyCurly,pos);
				break;
			case "leftCurly":
				this.value.leftCurly = this.loadObjectField(($_=new JsonParser_$178(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"leftCurly",assigned,this.value.leftCurly,pos);
				break;
			case "lineEndCharacter":
				this.value.lineEndCharacter = this.loadObjectField(($_=new JsonParser_$180(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"lineEndCharacter",assigned,this.value.lineEndCharacter,pos);
				break;
			case "metadataFunction":
				this.value.metadataFunction = this.loadObjectField(($_=new JsonParser_$182(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"metadataFunction",assigned,this.value.metadataFunction,pos);
				break;
			case "metadataOther":
				this.value.metadataOther = this.loadObjectField(($_=new JsonParser_$182(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"metadataOther",assigned,this.value.metadataOther,pos);
				break;
			case "metadataType":
				this.value.metadataType = this.loadObjectField(($_=new JsonParser_$182(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"metadataType",assigned,this.value.metadataType,pos);
				break;
			case "metadataVar":
				this.value.metadataVar = this.loadObjectField(($_=new JsonParser_$182(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"metadataVar",assigned,this.value.metadataVar,pos);
				break;
			case "objectLiteralCurly":
				this.value.objectLiteralCurly = this.loadObjectField(($_=new JsonParser_$168(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"objectLiteralCurly",assigned,this.value.objectLiteralCurly,pos);
				break;
			case "rightCurly":
				this.value.rightCurly = this.loadObjectField(($_=new JsonParser_$186(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"rightCurly",assigned,this.value.rightCurly,pos);
				break;
			case "sharp":
				this.value.sharp = this.loadObjectField(($_=new JsonParser_$188(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"sharp",assigned,this.value.sharp,pos);
				break;
			case "typedefCurly":
				this.value.typedefCurly = this.loadObjectField(($_=new JsonParser_$168(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"typedefCurly",assigned,this.value.typedefCurly,pos);
				break;
			default:
				this.errors.push(json2object_Error.UnknownVariable(field.name,this.putils.convertPosition(field.namePos)));
			}
		}
		this.objectErrors(assigned,pos);
	}
	,getAuto: function() {
		return { anonFunctionCurly : null, anonTypeCurly : null, blockCurly : null, caseColon : "after", emptyCurly : "noBreak", leftCurly : "after", lineEndCharacter : "auto", metadataFunction : "none", metadataOther : "none", metadataType : "none", metadataVar : "none", objectLiteralCurly : null, rightCurly : "both", sharp : "after", typedefCurly : null};
	}
	,__class__: JsonParser_$36
});
var JsonParser_$39 = function(errors,putils,errorType) {
	if(errorType == null) {
		errorType = 0;
	}
	json2object_reader_BaseParser.call(this,errors,putils,errorType);
};
JsonParser_$39.__name__ = true;
JsonParser_$39.__super__ = json2object_reader_BaseParser;
JsonParser_$39.prototype = $extend(json2object_reader_BaseParser.prototype,{
	onIncorrectType: function(pos,variable) {
		this.errors.push(json2object_Error.IncorrectType(variable,"{ ?whileBody : Null<formatter.config.SameLinePolicy>, ?untypedBody : Null<formatter.config.SameLinePolicy>, ?tryCatch : Null<formatter.config.SameLinePolicy>, ?tryBody : Null<formatter.config.SameLinePolicy>, ?returnBodySingleLine : Null<formatter.config.SameLinePolicy>, ?returnBody : Null<formatter.config.SameLinePolicy>, ?ifElse : Null<formatter.config.SameLinePolicy>, ?ifBody : Null<formatter.config.SameLinePolicy>, ?functionBody : Null<formatter.config.SameLinePolicy>, ?forBody : Null<formatter.config.SameLinePolicy>, ?expressionTry : Null<formatter.config.SameLinePolicy>, ?expressionIfWithBlocks : Null<Bool>, ?expressionIf : Null<formatter.config.SameLinePolicy>, ?expressionCase : Null<formatter.config.SameLinePolicy>, ?elseIf : Null<formatter.config.SameLinePolicy>, ?elseBody : Null<formatter.config.SameLinePolicy>, ?doWhileBody : Null<formatter.config.SameLinePolicy>, ?doWhile : Null<formatter.config.SameLinePolicy>, ?comprehensionFor : Null<formatter.config.SameLinePolicy>, ?catchBody : Null<formatter.config.SameLinePolicy>, ?caseBody : Null<formatter.config.SameLinePolicy>, ?anonFunctionBody : Null<formatter.config.SameLinePolicy> }",pos));
		json2object_reader_BaseParser.prototype.onIncorrectType.call(this,pos,variable);
	}
	,loadJsonNull: function(pos,variable) {
		this.value = null;
	}
	,loadJsonObject: function(o,pos,variable) {
		var assigned = new haxe_ds_StringMap();
		this.objectSetupAssign(assigned,["anonFunctionBody","caseBody","catchBody","comprehensionFor","doWhile","doWhileBody","elseBody","elseIf","expressionCase","expressionIf","expressionIfWithBlocks","expressionTry","forBody","functionBody","ifBody","ifElse","returnBody","returnBodySingleLine","tryBody","tryCatch","untypedBody","whileBody"],[true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true]);
		this.value = this.getAuto();
		var _g = 0;
		while(_g < o.length) {
			var field = o[_g];
			++_g;
			switch(field.name) {
			case "anonFunctionBody":
				this.value.anonFunctionBody = this.loadObjectField(($_=new JsonParser_$165(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"anonFunctionBody",assigned,this.value.anonFunctionBody,pos);
				break;
			case "caseBody":
				this.value.caseBody = this.loadObjectField(($_=new JsonParser_$165(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"caseBody",assigned,this.value.caseBody,pos);
				break;
			case "catchBody":
				this.value.catchBody = this.loadObjectField(($_=new JsonParser_$165(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"catchBody",assigned,this.value.catchBody,pos);
				break;
			case "comprehensionFor":
				this.value.comprehensionFor = this.loadObjectField(($_=new JsonParser_$165(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"comprehensionFor",assigned,this.value.comprehensionFor,pos);
				break;
			case "doWhile":
				this.value.doWhile = this.loadObjectField(($_=new JsonParser_$165(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"doWhile",assigned,this.value.doWhile,pos);
				break;
			case "doWhileBody":
				this.value.doWhileBody = this.loadObjectField(($_=new JsonParser_$165(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"doWhileBody",assigned,this.value.doWhileBody,pos);
				break;
			case "elseBody":
				this.value.elseBody = this.loadObjectField(($_=new JsonParser_$165(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"elseBody",assigned,this.value.elseBody,pos);
				break;
			case "elseIf":
				this.value.elseIf = this.loadObjectField(($_=new JsonParser_$165(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"elseIf",assigned,this.value.elseIf,pos);
				break;
			case "expressionCase":
				this.value.expressionCase = this.loadObjectField(($_=new JsonParser_$165(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"expressionCase",assigned,this.value.expressionCase,pos);
				break;
			case "expressionIf":
				this.value.expressionIf = this.loadObjectField(($_=new JsonParser_$165(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"expressionIf",assigned,this.value.expressionIf,pos);
				break;
			case "expressionIfWithBlocks":
				this.value.expressionIfWithBlocks = this.loadObjectField(($_=new JsonParser_$62(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"expressionIfWithBlocks",assigned,this.value.expressionIfWithBlocks,pos);
				break;
			case "expressionTry":
				this.value.expressionTry = this.loadObjectField(($_=new JsonParser_$165(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"expressionTry",assigned,this.value.expressionTry,pos);
				break;
			case "forBody":
				this.value.forBody = this.loadObjectField(($_=new JsonParser_$165(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"forBody",assigned,this.value.forBody,pos);
				break;
			case "functionBody":
				this.value.functionBody = this.loadObjectField(($_=new JsonParser_$165(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"functionBody",assigned,this.value.functionBody,pos);
				break;
			case "ifBody":
				this.value.ifBody = this.loadObjectField(($_=new JsonParser_$165(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"ifBody",assigned,this.value.ifBody,pos);
				break;
			case "ifElse":
				this.value.ifElse = this.loadObjectField(($_=new JsonParser_$165(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"ifElse",assigned,this.value.ifElse,pos);
				break;
			case "returnBody":
				this.value.returnBody = this.loadObjectField(($_=new JsonParser_$165(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"returnBody",assigned,this.value.returnBody,pos);
				break;
			case "returnBodySingleLine":
				this.value.returnBodySingleLine = this.loadObjectField(($_=new JsonParser_$165(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"returnBodySingleLine",assigned,this.value.returnBodySingleLine,pos);
				break;
			case "tryBody":
				this.value.tryBody = this.loadObjectField(($_=new JsonParser_$165(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"tryBody",assigned,this.value.tryBody,pos);
				break;
			case "tryCatch":
				this.value.tryCatch = this.loadObjectField(($_=new JsonParser_$165(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"tryCatch",assigned,this.value.tryCatch,pos);
				break;
			case "untypedBody":
				this.value.untypedBody = this.loadObjectField(($_=new JsonParser_$165(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"untypedBody",assigned,this.value.untypedBody,pos);
				break;
			case "whileBody":
				this.value.whileBody = this.loadObjectField(($_=new JsonParser_$165(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"whileBody",assigned,this.value.whileBody,pos);
				break;
			default:
				this.errors.push(json2object_Error.UnknownVariable(field.name,this.putils.convertPosition(field.namePos)));
			}
		}
		this.objectErrors(assigned,pos);
	}
	,getAuto: function() {
		return { anonFunctionBody : "same", caseBody : "next", catchBody : "next", comprehensionFor : "same", doWhile : "same", doWhileBody : "next", elseBody : "next", elseIf : "same", expressionCase : "keep", expressionIf : "same", expressionIfWithBlocks : false, expressionTry : "same", forBody : "next", functionBody : "next", ifBody : "next", ifElse : "same", returnBody : "same", returnBodySingleLine : "same", tryBody : "next", tryCatch : "same", untypedBody : "same", whileBody : "next"};
	}
	,__class__: JsonParser_$39
});
var JsonParser_$4 = function(errors,putils,errorType) {
	if(errorType == null) {
		errorType = 0;
	}
	json2object_reader_BaseParser.call(this,errors,putils,errorType);
};
JsonParser_$4.__name__ = true;
JsonParser_$4.__super__ = json2object_reader_BaseParser;
JsonParser_$4.prototype = $extend(json2object_reader_BaseParser.prototype,{
	onIncorrectType: function(pos,variable) {
		this.errors.push(json2object_Error.IncorrectType(variable,"{ ?typedefEmptyLines : Null<formatter.config.TypedefFieldsEmptyLinesConfig>, ?maxAnywhereInFile : Null<Int>, ?macroClassEmptyLines : Null<formatter.config.ClassFieldsEmptyLinesConfig>, ?lineCommentsBetweenTypes : Null<formatter.config.LineCommentEmptyLinePolicy>, ?lineCommentsBetweenFunctions : Null<formatter.config.LineCommentEmptyLinePolicy>, ?interfaceEmptyLines : Null<formatter.config.InterfaceFieldsEmptyLinesConfig>, ?importAndUsing : Null<formatter.config.ImportsEmptyLinesConfig>, ?finalNewline : Null<Bool>, ?externClassEmptyLines : Null<formatter.config.InterfaceFieldsEmptyLinesConfig>, ?enumEmptyLines : Null<formatter.config.TypedefFieldsEmptyLinesConfig>, ?enumAbstractEmptyLines : Null<formatter.config.EnumAbstractFieldsEmptyLinesConfig>, ?conditionalsEmptyLines : Null<formatter.config.ConditionalEmptyLinesConfig>, ?classEmptyLines : Null<formatter.config.ClassFieldsEmptyLinesConfig>, ?betweenTypes : Null<Int>, ?betweenSingleLineTypes : Null<Int>, ?betweenMultilineComments : Null<Int>, ?beforeRightCurly : Null<formatter.config.KeepEmptyLinesPolicy>, ?beforePackage : Null<Int>, ?beforeDocCommentEmptyLines : Null<formatter.config.CommentEmptyLinesPolicy>, ?beforeBlocks : Null<formatter.config.KeepEmptyLinesPolicy>, ?afterReturn : Null<formatter.config.KeepEmptyLinesPolicy>, ?afterPackage : Null<Int>, ?afterLeftCurly : Null<formatter.config.KeepEmptyLinesPolicy>, ?afterFileHeaderComment : Null<Int>, ?afterFieldsWithDocComments : Null<formatter.config.CommentEmptyLinesPolicy>, ?afterBlocks : Null<formatter.config.KeepEmptyLinesPolicy>, ?abstractEmptyLines : Null<formatter.config.ClassFieldsEmptyLinesConfig> }",pos));
		json2object_reader_BaseParser.prototype.onIncorrectType.call(this,pos,variable);
	}
	,loadJsonNull: function(pos,variable) {
		this.value = null;
	}
	,loadJsonObject: function(o,pos,variable) {
		var assigned = new haxe_ds_StringMap();
		this.objectSetupAssign(assigned,["abstractEmptyLines","afterBlocks","afterFieldsWithDocComments","afterFileHeaderComment","afterLeftCurly","afterPackage","afterReturn","beforeBlocks","beforeDocCommentEmptyLines","beforePackage","beforeRightCurly","betweenMultilineComments","betweenSingleLineTypes","betweenTypes","classEmptyLines","conditionalsEmptyLines","enumAbstractEmptyLines","enumEmptyLines","externClassEmptyLines","finalNewline","importAndUsing","interfaceEmptyLines","lineCommentsBetweenFunctions","lineCommentsBetweenTypes","macroClassEmptyLines","maxAnywhereInFile","typedefEmptyLines"],[true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true]);
		this.value = this.getAuto();
		var _g = 0;
		while(_g < o.length) {
			var field = o[_g];
			++_g;
			switch(field.name) {
			case "abstractEmptyLines":
				this.value.abstractEmptyLines = this.loadObjectField(($_=new JsonParser_$7(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"abstractEmptyLines",assigned,this.value.abstractEmptyLines,pos);
				break;
			case "afterBlocks":
				this.value.afterBlocks = this.loadObjectField(($_=new JsonParser_$198(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"afterBlocks",assigned,this.value.afterBlocks,pos);
				break;
			case "afterFieldsWithDocComments":
				this.value.afterFieldsWithDocComments = this.loadObjectField(($_=new JsonParser_$202(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"afterFieldsWithDocComments",assigned,this.value.afterFieldsWithDocComments,pos);
				break;
			case "afterFileHeaderComment":
				this.value.afterFileHeaderComment = this.loadObjectField(($_=new JsonParser_$96(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"afterFileHeaderComment",assigned,this.value.afterFileHeaderComment,pos);
				break;
			case "afterLeftCurly":
				this.value.afterLeftCurly = this.loadObjectField(($_=new JsonParser_$198(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"afterLeftCurly",assigned,this.value.afterLeftCurly,pos);
				break;
			case "afterPackage":
				this.value.afterPackage = this.loadObjectField(($_=new JsonParser_$96(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"afterPackage",assigned,this.value.afterPackage,pos);
				break;
			case "afterReturn":
				this.value.afterReturn = this.loadObjectField(($_=new JsonParser_$198(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"afterReturn",assigned,this.value.afterReturn,pos);
				break;
			case "beforeBlocks":
				this.value.beforeBlocks = this.loadObjectField(($_=new JsonParser_$198(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"beforeBlocks",assigned,this.value.beforeBlocks,pos);
				break;
			case "beforeDocCommentEmptyLines":
				this.value.beforeDocCommentEmptyLines = this.loadObjectField(($_=new JsonParser_$202(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"beforeDocCommentEmptyLines",assigned,this.value.beforeDocCommentEmptyLines,pos);
				break;
			case "beforePackage":
				this.value.beforePackage = this.loadObjectField(($_=new JsonParser_$96(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"beforePackage",assigned,this.value.beforePackage,pos);
				break;
			case "beforeRightCurly":
				this.value.beforeRightCurly = this.loadObjectField(($_=new JsonParser_$198(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"beforeRightCurly",assigned,this.value.beforeRightCurly,pos);
				break;
			case "betweenMultilineComments":
				this.value.betweenMultilineComments = this.loadObjectField(($_=new JsonParser_$96(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"betweenMultilineComments",assigned,this.value.betweenMultilineComments,pos);
				break;
			case "betweenSingleLineTypes":
				this.value.betweenSingleLineTypes = this.loadObjectField(($_=new JsonParser_$96(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"betweenSingleLineTypes",assigned,this.value.betweenSingleLineTypes,pos);
				break;
			case "betweenTypes":
				this.value.betweenTypes = this.loadObjectField(($_=new JsonParser_$96(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"betweenTypes",assigned,this.value.betweenTypes,pos);
				break;
			case "classEmptyLines":
				this.value.classEmptyLines = this.loadObjectField(($_=new JsonParser_$7(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"classEmptyLines",assigned,this.value.classEmptyLines,pos);
				break;
			case "conditionalsEmptyLines":
				this.value.conditionalsEmptyLines = this.loadObjectField(($_=new JsonParser_$12(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"conditionalsEmptyLines",assigned,this.value.conditionalsEmptyLines,pos);
				break;
			case "enumAbstractEmptyLines":
				this.value.enumAbstractEmptyLines = this.loadObjectField(($_=new JsonParser_$15(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"enumAbstractEmptyLines",assigned,this.value.enumAbstractEmptyLines,pos);
				break;
			case "enumEmptyLines":
				this.value.enumEmptyLines = this.loadObjectField(($_=new JsonParser_$18(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"enumEmptyLines",assigned,this.value.enumEmptyLines,pos);
				break;
			case "externClassEmptyLines":
				this.value.externClassEmptyLines = this.loadObjectField(($_=new JsonParser_$21(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"externClassEmptyLines",assigned,this.value.externClassEmptyLines,pos);
				break;
			case "finalNewline":
				this.value.finalNewline = this.loadObjectField(($_=new JsonParser_$62(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"finalNewline",assigned,this.value.finalNewline,pos);
				break;
			case "importAndUsing":
				this.value.importAndUsing = this.loadObjectField(($_=new JsonParser_$24(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"importAndUsing",assigned,this.value.importAndUsing,pos);
				break;
			case "interfaceEmptyLines":
				this.value.interfaceEmptyLines = this.loadObjectField(($_=new JsonParser_$21(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"interfaceEmptyLines",assigned,this.value.interfaceEmptyLines,pos);
				break;
			case "lineCommentsBetweenFunctions":
				this.value.lineCommentsBetweenFunctions = this.loadObjectField(($_=new JsonParser_$218(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"lineCommentsBetweenFunctions",assigned,this.value.lineCommentsBetweenFunctions,pos);
				break;
			case "lineCommentsBetweenTypes":
				this.value.lineCommentsBetweenTypes = this.loadObjectField(($_=new JsonParser_$218(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"lineCommentsBetweenTypes",assigned,this.value.lineCommentsBetweenTypes,pos);
				break;
			case "macroClassEmptyLines":
				this.value.macroClassEmptyLines = this.loadObjectField(($_=new JsonParser_$7(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"macroClassEmptyLines",assigned,this.value.macroClassEmptyLines,pos);
				break;
			case "maxAnywhereInFile":
				this.value.maxAnywhereInFile = this.loadObjectField(($_=new JsonParser_$96(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"maxAnywhereInFile",assigned,this.value.maxAnywhereInFile,pos);
				break;
			case "typedefEmptyLines":
				this.value.typedefEmptyLines = this.loadObjectField(($_=new JsonParser_$18(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"typedefEmptyLines",assigned,this.value.typedefEmptyLines,pos);
				break;
			default:
				this.errors.push(json2object_Error.UnknownVariable(field.name,this.putils.convertPosition(field.namePos)));
			}
		}
		this.objectErrors(assigned,pos);
	}
	,getAuto: function() {
		return { abstractEmptyLines : new JsonParser_$7([],this.putils,0).getAuto(), afterBlocks : "remove", afterFieldsWithDocComments : "one", afterFileHeaderComment : 1, afterLeftCurly : "remove", afterPackage : 1, afterReturn : "remove", beforeBlocks : "remove", beforeDocCommentEmptyLines : "one", beforePackage : 0, beforeRightCurly : "remove", betweenMultilineComments : 0, betweenSingleLineTypes : 0, betweenTypes : 1, classEmptyLines : new JsonParser_$7([],this.putils,0).getAuto(), conditionalsEmptyLines : new JsonParser_$12([],this.putils,0).getAuto(), enumAbstractEmptyLines : new JsonParser_$15([],this.putils,0).getAuto(), enumEmptyLines : new JsonParser_$18([],this.putils,0).getAuto(), externClassEmptyLines : new JsonParser_$21([],this.putils,0).getAuto(), finalNewline : true, importAndUsing : new JsonParser_$24([],this.putils,0).getAuto(), interfaceEmptyLines : new JsonParser_$21([],this.putils,0).getAuto(), lineCommentsBetweenFunctions : "keep", lineCommentsBetweenTypes : "keep", macroClassEmptyLines : new JsonParser_$7([],this.putils,0).getAuto(), maxAnywhereInFile : 1, typedefEmptyLines : new JsonParser_$18([],this.putils,0).getAuto()};
	}
	,__class__: JsonParser_$4
});
var JsonParser_$42 = function(errors,putils,errorType) {
	if(errorType == null) {
		errorType = 0;
	}
	json2object_reader_BaseParser.call(this,errors,putils,errorType);
};
JsonParser_$42.__name__ = true;
JsonParser_$42.__super__ = json2object_reader_BaseParser;
JsonParser_$42.prototype = $extend(json2object_reader_BaseParser.prototype,{
	onIncorrectType: function(pos,variable) {
		this.errors.push(json2object_Error.IncorrectType(variable,"{ ?whilePolicy : Null<formatter.config.WhitespacePolicy>, ?typeParamOpenPolicy : Null<formatter.config.WhitespacePolicy>, ?typeParamClosePolicy : Null<formatter.config.WhitespacePolicy>, ?typeHintColonPolicy : Null<formatter.config.WhitespacePolicy>, ?typeExtensionPolicy : Null<formatter.config.WhitespacePolicy>, ?typeCheckColonPolicy : Null<formatter.config.WhitespacePolicy>, ?tryPolicy : Null<formatter.config.WhitespacePolicy>, ?ternaryPolicy : Null<formatter.config.WhitespacePolicy>, ?switchPolicy : Null<formatter.config.WhitespacePolicy>, ?semicolonPolicy : Null<formatter.config.WhitespacePolicy>, ?parenConfig : Null<formatter.config.ParenWhitespaceConfig>, ?openingBracketPolicy : Null<formatter.config.WhitespacePolicy>, ?objectFieldColonPolicy : Null<formatter.config.WhitespacePolicy>, ?intervalPolicy : Null<formatter.config.WhitespacePolicy>, ?ifPolicy : Null<formatter.config.WhitespacePolicy>, ?functionTypeHaxe4Policy : Null<formatter.config.WhitespacePolicy>, ?functionTypeHaxe3Policy : Null<formatter.config.WhitespacePolicy>, ?formatStringInterpolation : Null<Bool>, ?forPolicy : Null<formatter.config.WhitespacePolicy>, ?dotPolicy : Null<formatter.config.WhitespacePolicy>, ?doPolicy : Null<formatter.config.WhitespacePolicy>, ?compressSuccessiveParenthesis : Null<Bool>, ?commaPolicy : Null<formatter.config.WhitespacePolicy>, ?colonPolicy : Null<formatter.config.WhitespacePolicy>, ?closingBracketPolicy : Null<formatter.config.WhitespacePolicy>, ?catchPolicy : Null<formatter.config.WhitespacePolicy>, ?caseColonPolicy : Null<formatter.config.WhitespacePolicy>, ?bracesConfig : Null<formatter.config.BracesWhitespaceConfig>, ?binopPolicy : Null<formatter.config.WhitespacePolicy>, ?arrowFunctionsPolicy : Null<formatter.config.WhitespacePolicy>, ?addLineCommentSpace : Null<Bool> }",pos));
		json2object_reader_BaseParser.prototype.onIncorrectType.call(this,pos,variable);
	}
	,loadJsonNull: function(pos,variable) {
		this.value = null;
	}
	,loadJsonObject: function(o,pos,variable) {
		var assigned = new haxe_ds_StringMap();
		this.objectSetupAssign(assigned,["addLineCommentSpace","arrowFunctionsPolicy","binopPolicy","bracesConfig","caseColonPolicy","catchPolicy","closingBracketPolicy","colonPolicy","commaPolicy","compressSuccessiveParenthesis","doPolicy","dotPolicy","forPolicy","formatStringInterpolation","functionTypeHaxe3Policy","functionTypeHaxe4Policy","ifPolicy","intervalPolicy","objectFieldColonPolicy","openingBracketPolicy","parenConfig","semicolonPolicy","switchPolicy","ternaryPolicy","tryPolicy","typeCheckColonPolicy","typeExtensionPolicy","typeHintColonPolicy","typeParamClosePolicy","typeParamOpenPolicy","whilePolicy"],[true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true]);
		this.value = this.getAuto();
		var _g = 0;
		while(_g < o.length) {
			var field = o[_g];
			++_g;
			switch(field.name) {
			case "addLineCommentSpace":
				this.value.addLineCommentSpace = this.loadObjectField(($_=new JsonParser_$62(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"addLineCommentSpace",assigned,this.value.addLineCommentSpace,pos);
				break;
			case "arrowFunctionsPolicy":
				this.value.arrowFunctionsPolicy = this.loadObjectField(($_=new JsonParser_$125(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"arrowFunctionsPolicy",assigned,this.value.arrowFunctionsPolicy,pos);
				break;
			case "binopPolicy":
				this.value.binopPolicy = this.loadObjectField(($_=new JsonParser_$125(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"binopPolicy",assigned,this.value.binopPolicy,pos);
				break;
			case "bracesConfig":
				this.value.bracesConfig = this.loadObjectField(($_=new JsonParser_$45(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"bracesConfig",assigned,this.value.bracesConfig,pos);
				break;
			case "caseColonPolicy":
				this.value.caseColonPolicy = this.loadObjectField(($_=new JsonParser_$125(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"caseColonPolicy",assigned,this.value.caseColonPolicy,pos);
				break;
			case "catchPolicy":
				this.value.catchPolicy = this.loadObjectField(($_=new JsonParser_$125(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"catchPolicy",assigned,this.value.catchPolicy,pos);
				break;
			case "closingBracketPolicy":
				this.value.closingBracketPolicy = this.loadObjectField(($_=new JsonParser_$125(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"closingBracketPolicy",assigned,this.value.closingBracketPolicy,pos);
				break;
			case "colonPolicy":
				this.value.colonPolicy = this.loadObjectField(($_=new JsonParser_$125(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"colonPolicy",assigned,this.value.colonPolicy,pos);
				break;
			case "commaPolicy":
				this.value.commaPolicy = this.loadObjectField(($_=new JsonParser_$125(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"commaPolicy",assigned,this.value.commaPolicy,pos);
				break;
			case "compressSuccessiveParenthesis":
				this.value.compressSuccessiveParenthesis = this.loadObjectField(($_=new JsonParser_$62(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"compressSuccessiveParenthesis",assigned,this.value.compressSuccessiveParenthesis,pos);
				break;
			case "doPolicy":
				this.value.doPolicy = this.loadObjectField(($_=new JsonParser_$125(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"doPolicy",assigned,this.value.doPolicy,pos);
				break;
			case "dotPolicy":
				this.value.dotPolicy = this.loadObjectField(($_=new JsonParser_$125(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"dotPolicy",assigned,this.value.dotPolicy,pos);
				break;
			case "forPolicy":
				this.value.forPolicy = this.loadObjectField(($_=new JsonParser_$125(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"forPolicy",assigned,this.value.forPolicy,pos);
				break;
			case "formatStringInterpolation":
				this.value.formatStringInterpolation = this.loadObjectField(($_=new JsonParser_$62(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"formatStringInterpolation",assigned,this.value.formatStringInterpolation,pos);
				break;
			case "functionTypeHaxe3Policy":
				this.value.functionTypeHaxe3Policy = this.loadObjectField(($_=new JsonParser_$125(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"functionTypeHaxe3Policy",assigned,this.value.functionTypeHaxe3Policy,pos);
				break;
			case "functionTypeHaxe4Policy":
				this.value.functionTypeHaxe4Policy = this.loadObjectField(($_=new JsonParser_$125(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"functionTypeHaxe4Policy",assigned,this.value.functionTypeHaxe4Policy,pos);
				break;
			case "ifPolicy":
				this.value.ifPolicy = this.loadObjectField(($_=new JsonParser_$125(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"ifPolicy",assigned,this.value.ifPolicy,pos);
				break;
			case "intervalPolicy":
				this.value.intervalPolicy = this.loadObjectField(($_=new JsonParser_$125(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"intervalPolicy",assigned,this.value.intervalPolicy,pos);
				break;
			case "objectFieldColonPolicy":
				this.value.objectFieldColonPolicy = this.loadObjectField(($_=new JsonParser_$125(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"objectFieldColonPolicy",assigned,this.value.objectFieldColonPolicy,pos);
				break;
			case "openingBracketPolicy":
				this.value.openingBracketPolicy = this.loadObjectField(($_=new JsonParser_$125(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"openingBracketPolicy",assigned,this.value.openingBracketPolicy,pos);
				break;
			case "parenConfig":
				this.value.parenConfig = this.loadObjectField(($_=new JsonParser_$48(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"parenConfig",assigned,this.value.parenConfig,pos);
				break;
			case "semicolonPolicy":
				this.value.semicolonPolicy = this.loadObjectField(($_=new JsonParser_$125(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"semicolonPolicy",assigned,this.value.semicolonPolicy,pos);
				break;
			case "switchPolicy":
				this.value.switchPolicy = this.loadObjectField(($_=new JsonParser_$125(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"switchPolicy",assigned,this.value.switchPolicy,pos);
				break;
			case "ternaryPolicy":
				this.value.ternaryPolicy = this.loadObjectField(($_=new JsonParser_$125(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"ternaryPolicy",assigned,this.value.ternaryPolicy,pos);
				break;
			case "tryPolicy":
				this.value.tryPolicy = this.loadObjectField(($_=new JsonParser_$125(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"tryPolicy",assigned,this.value.tryPolicy,pos);
				break;
			case "typeCheckColonPolicy":
				this.value.typeCheckColonPolicy = this.loadObjectField(($_=new JsonParser_$125(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"typeCheckColonPolicy",assigned,this.value.typeCheckColonPolicy,pos);
				break;
			case "typeExtensionPolicy":
				this.value.typeExtensionPolicy = this.loadObjectField(($_=new JsonParser_$125(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"typeExtensionPolicy",assigned,this.value.typeExtensionPolicy,pos);
				break;
			case "typeHintColonPolicy":
				this.value.typeHintColonPolicy = this.loadObjectField(($_=new JsonParser_$125(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"typeHintColonPolicy",assigned,this.value.typeHintColonPolicy,pos);
				break;
			case "typeParamClosePolicy":
				this.value.typeParamClosePolicy = this.loadObjectField(($_=new JsonParser_$125(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"typeParamClosePolicy",assigned,this.value.typeParamClosePolicy,pos);
				break;
			case "typeParamOpenPolicy":
				this.value.typeParamOpenPolicy = this.loadObjectField(($_=new JsonParser_$125(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"typeParamOpenPolicy",assigned,this.value.typeParamOpenPolicy,pos);
				break;
			case "whilePolicy":
				this.value.whilePolicy = this.loadObjectField(($_=new JsonParser_$125(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"whilePolicy",assigned,this.value.whilePolicy,pos);
				break;
			default:
				this.errors.push(json2object_Error.UnknownVariable(field.name,this.putils.convertPosition(field.namePos)));
			}
		}
		this.objectErrors(assigned,pos);
	}
	,getAuto: function() {
		return { addLineCommentSpace : true, arrowFunctionsPolicy : "around", binopPolicy : "around", bracesConfig : new JsonParser_$45([],this.putils,0).getAuto(), caseColonPolicy : "onlyAfter", catchPolicy : "after", closingBracketPolicy : "none", colonPolicy : "none", commaPolicy : "onlyAfter", compressSuccessiveParenthesis : true, doPolicy : "after", dotPolicy : "none", forPolicy : "after", formatStringInterpolation : true, functionTypeHaxe3Policy : "none", functionTypeHaxe4Policy : "around", ifPolicy : "after", intervalPolicy : "none", objectFieldColonPolicy : "after", openingBracketPolicy : "noneAfter", parenConfig : new JsonParser_$48([],this.putils,0).getAuto(), semicolonPolicy : "onlyAfter", switchPolicy : "after", ternaryPolicy : "around", tryPolicy : "after", typeCheckColonPolicy : "around", typeExtensionPolicy : "after", typeHintColonPolicy : "none", typeParamClosePolicy : "none", typeParamOpenPolicy : "none", whilePolicy : "after"};
	}
	,__class__: JsonParser_$42
});
var JsonParser_$45 = function(errors,putils,errorType) {
	if(errorType == null) {
		errorType = 0;
	}
	json2object_reader_BaseParser.call(this,errors,putils,errorType);
};
JsonParser_$45.__name__ = true;
JsonParser_$45.__super__ = json2object_reader_BaseParser;
JsonParser_$45.prototype = $extend(json2object_reader_BaseParser.prototype,{
	onIncorrectType: function(pos,variable) {
		this.errors.push(json2object_Error.IncorrectType(variable,"{ ?unknownBraces : Null<formatter.config.OpenClosePolicy>, ?typedefBraces : Null<formatter.config.OpenClosePolicy>, ?objectLiteralBraces : Null<formatter.config.OpenClosePolicy>, ?blockBraces : Null<formatter.config.OpenClosePolicy>, ?anonTypeBraces : Null<formatter.config.OpenClosePolicy> }",pos));
		json2object_reader_BaseParser.prototype.onIncorrectType.call(this,pos,variable);
	}
	,loadJsonNull: function(pos,variable) {
		this.value = null;
	}
	,loadJsonObject: function(o,pos,variable) {
		var assigned = new haxe_ds_StringMap();
		this.objectSetupAssign(assigned,["anonTypeBraces","blockBraces","objectLiteralBraces","typedefBraces","unknownBraces"],[true,true,true,true,true]);
		this.value = this.getAuto();
		var _g = 0;
		while(_g < o.length) {
			var field = o[_g];
			++_g;
			switch(field.name) {
			case "anonTypeBraces":
				this.value.anonTypeBraces = this.loadObjectField(($_=new JsonParser_$51(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"anonTypeBraces",assigned,this.value.anonTypeBraces,pos);
				break;
			case "blockBraces":
				this.value.blockBraces = this.loadObjectField(($_=new JsonParser_$51(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"blockBraces",assigned,this.value.blockBraces,pos);
				break;
			case "objectLiteralBraces":
				this.value.objectLiteralBraces = this.loadObjectField(($_=new JsonParser_$51(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"objectLiteralBraces",assigned,this.value.objectLiteralBraces,pos);
				break;
			case "typedefBraces":
				this.value.typedefBraces = this.loadObjectField(($_=new JsonParser_$51(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"typedefBraces",assigned,this.value.typedefBraces,pos);
				break;
			case "unknownBraces":
				this.value.unknownBraces = this.loadObjectField(($_=new JsonParser_$51(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"unknownBraces",assigned,this.value.unknownBraces,pos);
				break;
			default:
				this.errors.push(json2object_Error.UnknownVariable(field.name,this.putils.convertPosition(field.namePos)));
			}
		}
		this.objectErrors(assigned,pos);
	}
	,getAuto: function() {
		return { anonTypeBraces : { openingPolicy : "before", closingPolicy : "onlyAfter", removeInnerWhenEmpty : true}, blockBraces : { openingPolicy : "before", closingPolicy : "onlyAfter", removeInnerWhenEmpty : true}, objectLiteralBraces : { openingPolicy : "before", closingPolicy : "onlyAfter", removeInnerWhenEmpty : true}, typedefBraces : { openingPolicy : "before", closingPolicy : "onlyAfter", removeInnerWhenEmpty : true}, unknownBraces : { openingPolicy : "before", closingPolicy : "onlyAfter", removeInnerWhenEmpty : true}};
	}
	,__class__: JsonParser_$45
});
var JsonParser_$48 = function(errors,putils,errorType) {
	if(errorType == null) {
		errorType = 0;
	}
	json2object_reader_BaseParser.call(this,errors,putils,errorType);
};
JsonParser_$48.__name__ = true;
JsonParser_$48.__super__ = json2object_reader_BaseParser;
JsonParser_$48.prototype = $extend(json2object_reader_BaseParser.prototype,{
	onIncorrectType: function(pos,variable) {
		this.errors.push(json2object_Error.IncorrectType(variable,"{ ?whileConditionParens : Null<formatter.config.OpenClosePolicy>, ?switchConditionParens : Null<formatter.config.OpenClosePolicy>, ?sharpConditionParens : Null<formatter.config.OpenClosePolicy>, ?metadataParens : Null<formatter.config.OpenClosePolicy>, ?ifConditionParens : Null<formatter.config.OpenClosePolicy>, ?funcParamParens : Null<formatter.config.OpenClosePolicy>, ?forLoopParens : Null<formatter.config.OpenClosePolicy>, ?expressionParens : Null<formatter.config.OpenClosePolicy>, ?conditionParens : Null<formatter.config.OpenClosePolicy>, ?catchParens : Null<formatter.config.OpenClosePolicy>, ?callParens : Null<formatter.config.OpenClosePolicy>, ?anonFuncParamParens : Null<formatter.config.OpenClosePolicy> }",pos));
		json2object_reader_BaseParser.prototype.onIncorrectType.call(this,pos,variable);
	}
	,loadJsonNull: function(pos,variable) {
		this.value = null;
	}
	,loadJsonObject: function(o,pos,variable) {
		var assigned = new haxe_ds_StringMap();
		this.objectSetupAssign(assigned,["anonFuncParamParens","callParens","catchParens","conditionParens","expressionParens","forLoopParens","funcParamParens","ifConditionParens","metadataParens","sharpConditionParens","switchConditionParens","whileConditionParens"],[true,true,true,true,true,true,true,true,true,true,true,true]);
		this.value = this.getAuto();
		var _g = 0;
		while(_g < o.length) {
			var field = o[_g];
			++_g;
			switch(field.name) {
			case "anonFuncParamParens":
				this.value.anonFuncParamParens = this.loadObjectField(($_=new JsonParser_$51(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"anonFuncParamParens",assigned,this.value.anonFuncParamParens,pos);
				break;
			case "callParens":
				this.value.callParens = this.loadObjectField(($_=new JsonParser_$51(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"callParens",assigned,this.value.callParens,pos);
				break;
			case "catchParens":
				this.value.catchParens = this.loadObjectField(($_=new JsonParser_$51(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"catchParens",assigned,this.value.catchParens,pos);
				break;
			case "conditionParens":
				this.value.conditionParens = this.loadObjectField(($_=new JsonParser_$51(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"conditionParens",assigned,this.value.conditionParens,pos);
				break;
			case "expressionParens":
				this.value.expressionParens = this.loadObjectField(($_=new JsonParser_$51(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"expressionParens",assigned,this.value.expressionParens,pos);
				break;
			case "forLoopParens":
				this.value.forLoopParens = this.loadObjectField(($_=new JsonParser_$51(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"forLoopParens",assigned,this.value.forLoopParens,pos);
				break;
			case "funcParamParens":
				this.value.funcParamParens = this.loadObjectField(($_=new JsonParser_$51(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"funcParamParens",assigned,this.value.funcParamParens,pos);
				break;
			case "ifConditionParens":
				this.value.ifConditionParens = this.loadObjectField(($_=new JsonParser_$51(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"ifConditionParens",assigned,this.value.ifConditionParens,pos);
				break;
			case "metadataParens":
				this.value.metadataParens = this.loadObjectField(($_=new JsonParser_$51(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"metadataParens",assigned,this.value.metadataParens,pos);
				break;
			case "sharpConditionParens":
				this.value.sharpConditionParens = this.loadObjectField(($_=new JsonParser_$51(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"sharpConditionParens",assigned,this.value.sharpConditionParens,pos);
				break;
			case "switchConditionParens":
				this.value.switchConditionParens = this.loadObjectField(($_=new JsonParser_$51(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"switchConditionParens",assigned,this.value.switchConditionParens,pos);
				break;
			case "whileConditionParens":
				this.value.whileConditionParens = this.loadObjectField(($_=new JsonParser_$51(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"whileConditionParens",assigned,this.value.whileConditionParens,pos);
				break;
			default:
				this.errors.push(json2object_Error.UnknownVariable(field.name,this.putils.convertPosition(field.namePos)));
			}
		}
		this.objectErrors(assigned,pos);
	}
	,getAuto: function() {
		var tmp = new JsonParser_$51([],this.putils,0).getAuto();
		var tmp1 = new JsonParser_$51([],this.putils,0).getAuto();
		var tmp2 = new JsonParser_$51([],this.putils,0).getAuto();
		var tmp3 = new JsonParser_$51([],this.putils,0).getAuto();
		return { anonFuncParamParens : tmp, callParens : tmp1, catchParens : null, conditionParens : { openingPolicy : "noneAfter", closingPolicy : "onlyAfter", removeInnerWhenEmpty : true}, expressionParens : { openingPolicy : "noneAfter", closingPolicy : "onlyAfter", removeInnerWhenEmpty : true}, forLoopParens : { openingPolicy : "noneAfter", closingPolicy : "onlyAfter", removeInnerWhenEmpty : true}, funcParamParens : tmp2, ifConditionParens : null, metadataParens : tmp3, sharpConditionParens : null, switchConditionParens : null, whileConditionParens : null};
	}
	,__class__: JsonParser_$48
});
var JsonParser_$51 = function(errors,putils,errorType) {
	if(errorType == null) {
		errorType = 0;
	}
	json2object_reader_BaseParser.call(this,errors,putils,errorType);
};
JsonParser_$51.__name__ = true;
JsonParser_$51.__super__ = json2object_reader_BaseParser;
JsonParser_$51.prototype = $extend(json2object_reader_BaseParser.prototype,{
	onIncorrectType: function(pos,variable) {
		this.errors.push(json2object_Error.IncorrectType(variable,"{ ?removeInnerWhenEmpty : Null<Bool>, ?openingPolicy : Null<formatter.config.WhitespacePolicy>, ?closingPolicy : Null<formatter.config.WhitespacePolicy> }",pos));
		json2object_reader_BaseParser.prototype.onIncorrectType.call(this,pos,variable);
	}
	,loadJsonNull: function(pos,variable) {
		this.value = null;
	}
	,loadJsonObject: function(o,pos,variable) {
		var assigned = new haxe_ds_StringMap();
		this.objectSetupAssign(assigned,["closingPolicy","openingPolicy","removeInnerWhenEmpty"],[true,true,true]);
		this.value = this.getAuto();
		var _g = 0;
		while(_g < o.length) {
			var field = o[_g];
			++_g;
			switch(field.name) {
			case "closingPolicy":
				this.value.closingPolicy = this.loadObjectField(($_=new JsonParser_$125(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"closingPolicy",assigned,this.value.closingPolicy,pos);
				break;
			case "openingPolicy":
				this.value.openingPolicy = this.loadObjectField(($_=new JsonParser_$125(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"openingPolicy",assigned,this.value.openingPolicy,pos);
				break;
			case "removeInnerWhenEmpty":
				this.value.removeInnerWhenEmpty = this.loadObjectField(($_=new JsonParser_$62(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"removeInnerWhenEmpty",assigned,this.value.removeInnerWhenEmpty,pos);
				break;
			default:
				this.errors.push(json2object_Error.UnknownVariable(field.name,this.putils.convertPosition(field.namePos)));
			}
		}
		this.objectErrors(assigned,pos);
	}
	,getAuto: function() {
		return { closingPolicy : "onlyAfter", openingPolicy : "none", removeInnerWhenEmpty : true};
	}
	,__class__: JsonParser_$51
});
var JsonParser_$60 = function(errors,putils,errorType) {
	if(errorType == null) {
		errorType = 0;
	}
	json2object_reader_BaseParser.call(this,errors,putils,errorType);
};
JsonParser_$60.__name__ = true;
JsonParser_$60.__super__ = json2object_reader_BaseParser;
JsonParser_$60.prototype = $extend(json2object_reader_BaseParser.prototype,{
	onIncorrectType: function(pos,variable) {
		this.errors.push(json2object_Error.IncorrectType(variable,"{ ?typeParameter : Null<formatter.config.WrapRules>, ?opBoolChain : Null<formatter.config.WrapRules>, ?opAddSubChain : Null<formatter.config.WrapRules>, ?objectLiteral : Null<formatter.config.WrapRules>, ?multiVar : Null<formatter.config.WrapRules>, ?methodChain : Null<formatter.config.WrapRules>, ?metadataCallParameter : Null<formatter.config.WrapRules>, ?maxLineLength : Null<Int>, ?implementsExtends : Null<formatter.config.WrapRules>, ?functionSignature : Null<formatter.config.WrapRules>, ?casePattern : Null<formatter.config.WrapRules>, ?callParameter : Null<formatter.config.WrapRules>, ?arrayWrap : Null<formatter.config.WrapRules>, ?arrayMatrixWrap : Null<formatter.config.ArrayMatrixWrap>, ?anonType : Null<formatter.config.WrapRules>, ?anonFunctionSignature : Null<formatter.config.WrapRules> }",pos));
		json2object_reader_BaseParser.prototype.onIncorrectType.call(this,pos,variable);
	}
	,loadJsonNull: function(pos,variable) {
		this.value = null;
	}
	,loadJsonObject: function(o,pos,variable) {
		var assigned = new haxe_ds_StringMap();
		this.objectSetupAssign(assigned,["anonFunctionSignature","anonType","arrayMatrixWrap","arrayWrap","callParameter","casePattern","functionSignature","implementsExtends","maxLineLength","metadataCallParameter","methodChain","multiVar","objectLiteral","opAddSubChain","opBoolChain","typeParameter"],[true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true]);
		this.value = this.getAuto();
		var _g = 0;
		while(_g < o.length) {
			var field = o[_g];
			++_g;
			switch(field.name) {
			case "anonFunctionSignature":
				this.value.anonFunctionSignature = this.loadObjectField(($_=new JsonParser_$80(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"anonFunctionSignature",assigned,this.value.anonFunctionSignature,pos);
				break;
			case "anonType":
				this.value.anonType = this.loadObjectField(($_=new JsonParser_$80(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"anonType",assigned,this.value.anonType,pos);
				break;
			case "arrayMatrixWrap":
				this.value.arrayMatrixWrap = this.loadObjectField(($_=new JsonParser_$84(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"arrayMatrixWrap",assigned,this.value.arrayMatrixWrap,pos);
				break;
			case "arrayWrap":
				this.value.arrayWrap = this.loadObjectField(($_=new JsonParser_$80(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"arrayWrap",assigned,this.value.arrayWrap,pos);
				break;
			case "callParameter":
				this.value.callParameter = this.loadObjectField(($_=new JsonParser_$80(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"callParameter",assigned,this.value.callParameter,pos);
				break;
			case "casePattern":
				this.value.casePattern = this.loadObjectField(($_=new JsonParser_$80(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"casePattern",assigned,this.value.casePattern,pos);
				break;
			case "functionSignature":
				this.value.functionSignature = this.loadObjectField(($_=new JsonParser_$80(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"functionSignature",assigned,this.value.functionSignature,pos);
				break;
			case "implementsExtends":
				this.value.implementsExtends = this.loadObjectField(($_=new JsonParser_$80(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"implementsExtends",assigned,this.value.implementsExtends,pos);
				break;
			case "maxLineLength":
				this.value.maxLineLength = this.loadObjectField(($_=new JsonParser_$96(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"maxLineLength",assigned,this.value.maxLineLength,pos);
				break;
			case "metadataCallParameter":
				this.value.metadataCallParameter = this.loadObjectField(($_=new JsonParser_$80(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"metadataCallParameter",assigned,this.value.metadataCallParameter,pos);
				break;
			case "methodChain":
				this.value.methodChain = this.loadObjectField(($_=new JsonParser_$80(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"methodChain",assigned,this.value.methodChain,pos);
				break;
			case "multiVar":
				this.value.multiVar = this.loadObjectField(($_=new JsonParser_$80(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"multiVar",assigned,this.value.multiVar,pos);
				break;
			case "objectLiteral":
				this.value.objectLiteral = this.loadObjectField(($_=new JsonParser_$80(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"objectLiteral",assigned,this.value.objectLiteral,pos);
				break;
			case "opAddSubChain":
				this.value.opAddSubChain = this.loadObjectField(($_=new JsonParser_$80(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"opAddSubChain",assigned,this.value.opAddSubChain,pos);
				break;
			case "opBoolChain":
				this.value.opBoolChain = this.loadObjectField(($_=new JsonParser_$80(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"opBoolChain",assigned,this.value.opBoolChain,pos);
				break;
			case "typeParameter":
				this.value.typeParameter = this.loadObjectField(($_=new JsonParser_$80(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"typeParameter",assigned,this.value.typeParameter,pos);
				break;
			default:
				this.errors.push(json2object_Error.UnknownVariable(field.name,this.putils.convertPosition(field.namePos)));
			}
		}
		this.objectErrors(assigned,pos);
	}
	,getAuto: function() {
		return { anonFunctionSignature : { defaultWrap : "noWrap", rules : [{ conditions : [{ cond : "itemCount >= n", value : 7}], type : "fillLine", additionalIndent : 1},{ conditions : [{ cond : "totalItemLength >= n", value : 80}], type : "fillLine", additionalIndent : 1},{ conditions : [{ cond : "exceedsMaxLineLength", value : 1}], type : "fillLine", additionalIndent : 1}]}, anonType : { defaultWrap : "noWrap", rules : [{ conditions : [{ cond : "itemCount <= n", value : 3},{ cond : "exceedsMaxLineLength", value : 0}], type : "noWrap"},{ conditions : [{ cond : "anyItemLength >= n", value : 30}], type : "onePerLine"},{ conditions : [{ cond : "totalItemLength >= n", value : 60}], type : "onePerLine"},{ conditions : [{ cond : "itemCount >= n", value : 4}], type : "onePerLine"},{ conditions : [{ cond : "exceedsMaxLineLength", value : 1}], type : "fillLine"}]}, arrayMatrixWrap : "matrixWrapWithAlign", arrayWrap : { defaultWrap : "noWrap", rules : [{ conditions : [{ cond : "hasMultilineItems", value : 1}], type : "onePerLine"},{ conditions : [{ cond : "totalItemLength <= n", value : 80}], type : "noWrap"},{ conditions : [{ cond : "itemCount >= n", value : 10}], type : "fillLineWithLeadingBreak"},{ conditions : [{ cond : "anyItemLength >= n", value : 30}], type : "onePerLine"},{ conditions : [{ cond : "itemCount >= n", value : 4}], type : "onePerLine"},{ conditions : [{ cond : "exceedsMaxLineLength", value : 1}], type : "onePerLine"}]}, callParameter : { defaultWrap : "noWrap", rules : [{ conditions : [{ cond : "itemCount >= n", value : 7}], type : "fillLine"},{ conditions : [{ cond : "totalItemLength >= n", value : 140}], type : "fillLine"},{ conditions : [{ cond : "anyItemLength >= n", value : 80}], type : "fillLine"},{ conditions : [{ cond : "lineLength >= n", value : 160}], type : "fillLine"},{ conditions : [{ cond : "exceedsMaxLineLength", value : 1}], type : "fillLine"}]}, casePattern : { defaultWrap : "noWrap", rules : [{ conditions : [{ cond : "itemCount >= n", value : 2}], type : "fillLine"},{ conditions : [{ cond : "exceedsMaxLineLength", value : 1}], type : "fillLine"}]}, functionSignature : { defaultWrap : "fillLine", defaultAdditionalIndent : 1, rules : []}, implementsExtends : { defaultWrap : "noWrap", rules : [{ conditions : [{ cond : "lineLength >= n", value : 140}], type : "fillLine", additionalIndent : 2},{ conditions : [{ cond : "itemCount >= n", value : 4}], type : "fillLine", additionalIndent : 2},{ conditions : [{ cond : "exceedsMaxLineLength", value : 1}], type : "fillLine", additionalIndent : 2}]}, maxLineLength : 160, metadataCallParameter : { defaultWrap : "noWrap", rules : [{ conditions : [{ cond : "totalItemLength >= n", value : 140}], type : "fillLine"},{ conditions : [{ cond : "lineLength >= n", value : 160}], type : "fillLine"},{ conditions : [{ cond : "exceedsMaxLineLength", value : 1}], type : "fillLine"}]}, methodChain : { defaultWrap : "noWrap", rules : [{ conditions : [{ cond : "lineLength >= n", value : 160}], type : "onePerLineAfterFirst"},{ conditions : [{ cond : "itemCount <= n", value : 3},{ cond : "exceedsMaxLineLength", value : 0}], type : "noWrap"},{ conditions : [{ cond : "totalItemLength <= n", value : 80},{ cond : "exceedsMaxLineLength", value : 0}], type : "noWrap"},{ conditions : [{ cond : "anyItemLength >= n", value : 30},{ cond : "itemCount >= n", value : 4}], type : "onePerLineAfterFirst"},{ conditions : [{ cond : "itemCount >= n", value : 7}], type : "onePerLineAfterFirst"},{ conditions : [{ cond : "exceedsMaxLineLength", value : 1}], type : "onePerLineAfterFirst"}]}, multiVar : { defaultWrap : "noWrap", rules : [{ conditions : [{ cond : "anyItemLength <= n", value : 15}], type : "fillLine"},{ conditions : [{ cond : "lineLength >= n", value : 80}], type : "onePerLineAfterFirst"},{ conditions : [{ cond : "exceedsMaxLineLength", value : 1}], type : "onePerLineAfterFirst"}]}, objectLiteral : { defaultWrap : "noWrap", rules : [{ conditions : [{ cond : "itemCount <= n", value : 3},{ cond : "exceedsMaxLineLength", value : 0}], type : "noWrap"},{ conditions : [{ cond : "anyItemLength >= n", value : 30}], type : "onePerLine"},{ conditions : [{ cond : "totalItemLength >= n", value : 60}], type : "onePerLine"},{ conditions : [{ cond : "itemCount >= n", value : 4}], type : "onePerLine"},{ conditions : [{ cond : "exceedsMaxLineLength", value : 1}], type : "onePerLine"}]}, opAddSubChain : { defaultWrap : "noWrap", rules : [{ conditions : [{ cond : "lineLength >= n", value : 160},{ cond : "anyItemLength >= n", value : 60}], location : "beforeLast", type : "onePerLineAfterFirst"},{ conditions : [{ cond : "lineLength >= n", value : 160}], location : "beforeLast", type : "fillLine"},{ conditions : [{ cond : "itemCount <= n", value : 3},{ cond : "exceedsMaxLineLength", value : 0}], type : "noWrap"},{ conditions : [{ cond : "totalItemLength <= n", value : 120},{ cond : "exceedsMaxLineLength", value : 0}], type : "noWrap"},{ conditions : [{ cond : "itemCount >= n", value : 4}], location : "beforeLast", type : "onePerLineAfterFirst"},{ conditions : [{ cond : "exceedsMaxLineLength", value : 1}], location : "beforeLast", type : "onePerLineAfterFirst"}]}, opBoolChain : { defaultWrap : "noWrap", rules : [{ conditions : [{ cond : "lineLength >= n", value : 140},{ cond : "anyItemLength >= n", value : 40}], location : "beforeLast", type : "onePerLineAfterFirst"},{ conditions : [{ cond : "lineLength >= n", value : 140}], location : "beforeLast", type : "fillLine"},{ conditions : [{ cond : "itemCount <= n", value : 3},{ cond : "exceedsMaxLineLength", value : 0}], type : "noWrap"},{ conditions : [{ cond : "totalItemLength <= n", value : 120},{ cond : "exceedsMaxLineLength", value : 0}], type : "noWrap"},{ conditions : [{ cond : "itemCount >= n", value : 4}], location : "beforeLast", type : "onePerLineAfterFirst"},{ conditions : [{ cond : "exceedsMaxLineLength", value : 1}], location : "beforeLast", type : "fillLine"}]}, typeParameter : { defaultWrap : "noWrap", rules : [{ conditions : [{ cond : "anyItemLength >= n", value : 50}], type : "fillLine"},{ conditions : [{ cond : "totalItemLength >= n", value : 70}], type : "fillLine"}]}};
	}
	,__class__: JsonParser_$60
});
var JsonParser_$62 = function(errors,putils,errorType) {
	if(errorType == null) {
		errorType = 0;
	}
	json2object_reader_BaseParser.call(this,errors,putils,errorType);
};
JsonParser_$62.__name__ = true;
JsonParser_$62.__super__ = json2object_reader_BaseParser;
JsonParser_$62.prototype = $extend(json2object_reader_BaseParser.prototype,{
	onIncorrectType: function(pos,variable) {
		this.errors.push(json2object_Error.IncorrectType(variable,"Bool",pos));
		json2object_reader_BaseParser.prototype.onIncorrectType.call(this,pos,variable);
	}
	,loadJsonNull: function(pos,variable) {
		this.value = null;
	}
	,loadJsonBool: function(b,pos,variable) {
		this.value = b;
	}
	,__class__: JsonParser_$62
});
var JsonParser_$66 = function(errors,putils,errorType) {
	if(errorType == null) {
		errorType = 0;
	}
	json2object_reader_BaseParser.call(this,errors,putils,errorType);
};
JsonParser_$66.__name__ = true;
JsonParser_$66.__super__ = json2object_reader_BaseParser;
JsonParser_$66.prototype = $extend(json2object_reader_BaseParser.prototype,{
	onIncorrectType: function(pos,variable) {
		this.errors.push(json2object_Error.IncorrectType(variable,"Array<String>",pos));
		json2object_reader_BaseParser.prototype.onIncorrectType.call(this,pos,variable);
	}
	,loadJsonNull: function(pos,variable) {
		this.value = null;
	}
	,loadJsonArray: function(a,pos,variable) {
		this.value = this.loadJsonArrayValue(a,($_=new JsonParser_$77(this.errors,this.putils,2),$bind($_,$_.loadJson)),variable);
	}
	,__class__: JsonParser_$66
});
var JsonParser_$7 = function(errors,putils,errorType) {
	if(errorType == null) {
		errorType = 0;
	}
	json2object_reader_BaseParser.call(this,errors,putils,errorType);
};
JsonParser_$7.__name__ = true;
JsonParser_$7.__super__ = json2object_reader_BaseParser;
JsonParser_$7.prototype = $extend(json2object_reader_BaseParser.prototype,{
	onIncorrectType: function(pos,variable) {
		this.errors.push(json2object_Error.IncorrectType(variable,"{ ?existingBetweenFields : Null<formatter.config.KeepEmptyLinesPolicy>, ?endType : Null<Int>, ?betweenVars : Null<Int>, ?betweenStaticVars : Null<Int>, ?betweenStaticFunctions : Null<Int>, ?betweenFunctions : Null<Int>, ?beginType : Null<Int>, ?afterVars : Null<Int>, ?afterStaticVars : Null<Int>, ?afterStaticFunctions : Null<Int>, ?afterPrivateVars : Null<Int>, ?afterPrivateFunctions : Null<Int> }",pos));
		json2object_reader_BaseParser.prototype.onIncorrectType.call(this,pos,variable);
	}
	,loadJsonNull: function(pos,variable) {
		this.value = null;
	}
	,loadJsonObject: function(o,pos,variable) {
		var assigned = new haxe_ds_StringMap();
		this.objectSetupAssign(assigned,["afterPrivateFunctions","afterPrivateVars","afterStaticFunctions","afterStaticVars","afterVars","beginType","betweenFunctions","betweenStaticFunctions","betweenStaticVars","betweenVars","endType","existingBetweenFields"],[true,true,true,true,true,true,true,true,true,true,true,true]);
		this.value = this.getAuto();
		var _g = 0;
		while(_g < o.length) {
			var field = o[_g];
			++_g;
			switch(field.name) {
			case "afterPrivateFunctions":
				this.value.afterPrivateFunctions = this.loadObjectField(($_=new JsonParser_$96(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"afterPrivateFunctions",assigned,this.value.afterPrivateFunctions,pos);
				break;
			case "afterPrivateVars":
				this.value.afterPrivateVars = this.loadObjectField(($_=new JsonParser_$96(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"afterPrivateVars",assigned,this.value.afterPrivateVars,pos);
				break;
			case "afterStaticFunctions":
				this.value.afterStaticFunctions = this.loadObjectField(($_=new JsonParser_$96(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"afterStaticFunctions",assigned,this.value.afterStaticFunctions,pos);
				break;
			case "afterStaticVars":
				this.value.afterStaticVars = this.loadObjectField(($_=new JsonParser_$96(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"afterStaticVars",assigned,this.value.afterStaticVars,pos);
				break;
			case "afterVars":
				this.value.afterVars = this.loadObjectField(($_=new JsonParser_$96(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"afterVars",assigned,this.value.afterVars,pos);
				break;
			case "beginType":
				this.value.beginType = this.loadObjectField(($_=new JsonParser_$96(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"beginType",assigned,this.value.beginType,pos);
				break;
			case "betweenFunctions":
				this.value.betweenFunctions = this.loadObjectField(($_=new JsonParser_$96(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"betweenFunctions",assigned,this.value.betweenFunctions,pos);
				break;
			case "betweenStaticFunctions":
				this.value.betweenStaticFunctions = this.loadObjectField(($_=new JsonParser_$96(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"betweenStaticFunctions",assigned,this.value.betweenStaticFunctions,pos);
				break;
			case "betweenStaticVars":
				this.value.betweenStaticVars = this.loadObjectField(($_=new JsonParser_$96(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"betweenStaticVars",assigned,this.value.betweenStaticVars,pos);
				break;
			case "betweenVars":
				this.value.betweenVars = this.loadObjectField(($_=new JsonParser_$96(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"betweenVars",assigned,this.value.betweenVars,pos);
				break;
			case "endType":
				this.value.endType = this.loadObjectField(($_=new JsonParser_$96(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"endType",assigned,this.value.endType,pos);
				break;
			case "existingBetweenFields":
				this.value.existingBetweenFields = this.loadObjectField(($_=new JsonParser_$198(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"existingBetweenFields",assigned,this.value.existingBetweenFields,pos);
				break;
			default:
				this.errors.push(json2object_Error.UnknownVariable(field.name,this.putils.convertPosition(field.namePos)));
			}
		}
		this.objectErrors(assigned,pos);
	}
	,getAuto: function() {
		return { afterPrivateFunctions : 1, afterPrivateVars : 1, afterStaticFunctions : 1, afterStaticVars : 1, afterVars : 1, beginType : 0, betweenFunctions : 1, betweenStaticFunctions : 1, betweenStaticVars : 0, betweenVars : 0, endType : 0, existingBetweenFields : "keep"};
	}
	,__class__: JsonParser_$7
});
var JsonParser_$77 = function(errors,putils,errorType) {
	if(errorType == null) {
		errorType = 0;
	}
	json2object_reader_BaseParser.call(this,errors,putils,errorType);
};
JsonParser_$77.__name__ = true;
JsonParser_$77.__super__ = json2object_reader_BaseParser;
JsonParser_$77.prototype = $extend(json2object_reader_BaseParser.prototype,{
	onIncorrectType: function(pos,variable) {
		this.errors.push(json2object_Error.IncorrectType(variable,"String",pos));
		json2object_reader_BaseParser.prototype.onIncorrectType.call(this,pos,variable);
	}
	,loadJsonNull: function(pos,variable) {
		this.value = null;
	}
	,loadJsonString: function(s,pos,variable) {
		this.value = s;
	}
	,__class__: JsonParser_$77
});
var JsonParser_$80 = function(errors,putils,errorType) {
	if(errorType == null) {
		errorType = 0;
	}
	json2object_reader_BaseParser.call(this,errors,putils,errorType);
};
JsonParser_$80.__name__ = true;
JsonParser_$80.__super__ = json2object_reader_BaseParser;
JsonParser_$80.prototype = $extend(json2object_reader_BaseParser.prototype,{
	onIncorrectType: function(pos,variable) {
		this.errors.push(json2object_Error.IncorrectType(variable,"{ ?rules : Null<Array<formatter.config.WrapRule>>, ?defaultWrap : Null<formatter.config.WrappingType>, ?defaultLocation : Null<formatter.config.WrappingLocation>, ?defaultAdditionalIndent : Null<Int> }",pos));
		json2object_reader_BaseParser.prototype.onIncorrectType.call(this,pos,variable);
	}
	,loadJsonNull: function(pos,variable) {
		this.value = null;
	}
	,loadJsonObject: function(o,pos,variable) {
		var assigned = new haxe_ds_StringMap();
		this.objectSetupAssign(assigned,["defaultAdditionalIndent","defaultLocation","defaultWrap","rules"],[true,true,true,true]);
		this.value = this.getAuto();
		var _g = 0;
		while(_g < o.length) {
			var field = o[_g];
			++_g;
			switch(field.name) {
			case "defaultAdditionalIndent":
				this.value.defaultAdditionalIndent = this.loadObjectField(($_=new JsonParser_$96(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"defaultAdditionalIndent",assigned,this.value.defaultAdditionalIndent,pos);
				break;
			case "defaultLocation":
				this.value.defaultLocation = this.loadObjectField(($_=new JsonParser_$112(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"defaultLocation",assigned,this.value.defaultLocation,pos);
				break;
			case "defaultWrap":
				this.value.defaultWrap = this.loadObjectField(($_=new JsonParser_$114(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"defaultWrap",assigned,this.value.defaultWrap,pos);
				break;
			case "rules":
				this.value.rules = this.loadObjectField(($_=new JsonParser_$116(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"rules",assigned,this.value.rules,pos);
				break;
			default:
				this.errors.push(json2object_Error.UnknownVariable(field.name,this.putils.convertPosition(field.namePos)));
			}
		}
		this.objectErrors(assigned,pos);
	}
	,getAuto: function() {
		return { defaultAdditionalIndent : 0, defaultLocation : "afterLast", defaultWrap : "noWrap", rules : []};
	}
	,__class__: JsonParser_$80
});
var JsonParser_$84 = function(errors,putils,errorType) {
	if(errorType == null) {
		errorType = 0;
	}
	json2object_reader_BaseParser.call(this,errors,putils,errorType);
};
JsonParser_$84.__name__ = true;
JsonParser_$84.__super__ = json2object_reader_BaseParser;
JsonParser_$84.prototype = $extend(json2object_reader_BaseParser.prototype,{
	onIncorrectType: function(pos,variable) {
		this.value = "noMatrixWrap";
		this.errors.push(json2object_Error.IncorrectType(variable,"formatter.config.ArrayMatrixWrap",pos));
		this.objectThrow(pos,variable);
	}
	,loadJsonNull: function(pos,variable) {
		this.value = null;
	}
	,loadJsonString: function(s,pos,variable) {
		this.value = this.loadString(s,pos,variable,["noMatrixWrap","matrixWrapNoAlign","matrixWrapWithAlign"],"noMatrixWrap");
	}
	,__class__: JsonParser_$84
});
var JsonParser_$96 = function(errors,putils,errorType) {
	if(errorType == null) {
		errorType = 0;
	}
	json2object_reader_BaseParser.call(this,errors,putils,errorType);
};
JsonParser_$96.__name__ = true;
JsonParser_$96.__super__ = json2object_reader_BaseParser;
JsonParser_$96.prototype = $extend(json2object_reader_BaseParser.prototype,{
	onIncorrectType: function(pos,variable) {
		this.errors.push(json2object_Error.IncorrectType(variable,"Int",pos));
		json2object_reader_BaseParser.prototype.onIncorrectType.call(this,pos,variable);
	}
	,loadJsonNull: function(pos,variable) {
		this.value = null;
	}
	,loadJsonNumber: function(f,pos,variable) {
		this.value = this.loadJsonInt(f,pos,variable,this.value);
	}
	,__class__: JsonParser_$96
});
Math.__name__ = true;
var Std = function() { };
Std.__name__ = true;
Std.string = function(s) {
	return js_Boot.__string_rec(s,"");
};
Std.parseInt = function(x) {
	if(x != null) {
		var _g = 0;
		var _g1 = x.length;
		while(_g < _g1) {
			var i = _g++;
			var c = x.charCodeAt(i);
			if(c <= 8 || c >= 14 && c != 32 && c != 45) {
				var nc = x.charCodeAt(i + 1);
				var v = parseInt(x,nc == 120 || nc == 88 ? 16 : 10);
				if(isNaN(v)) {
					return null;
				} else {
					return v;
				}
			}
		}
	}
	return null;
};
var StringBuf = function() {
	this.b = "";
};
StringBuf.__name__ = true;
StringBuf.prototype = {
	__class__: StringBuf
};
var StringTools = function() { };
StringTools.__name__ = true;
StringTools.startsWith = function(s,start) {
	if(s.length >= start.length) {
		return s.lastIndexOf(start,0) == 0;
	} else {
		return false;
	}
};
StringTools.endsWith = function(s,end) {
	var elen = end.length;
	var slen = s.length;
	if(slen >= elen) {
		return s.indexOf(end,slen - elen) == slen - elen;
	} else {
		return false;
	}
};
StringTools.isSpace = function(s,pos) {
	var c = HxOverrides.cca(s,pos);
	if(!(c > 8 && c < 14)) {
		return c == 32;
	} else {
		return true;
	}
};
StringTools.ltrim = function(s) {
	var l = s.length;
	var r = 0;
	while(r < l && StringTools.isSpace(s,r)) ++r;
	if(r > 0) {
		return HxOverrides.substr(s,r,l - r);
	} else {
		return s;
	}
};
StringTools.rtrim = function(s) {
	var l = s.length;
	var r = 0;
	while(r < l && StringTools.isSpace(s,l - r - 1)) ++r;
	if(r > 0) {
		return HxOverrides.substr(s,0,l - r);
	} else {
		return s;
	}
};
StringTools.trim = function(s) {
	return StringTools.ltrim(StringTools.rtrim(s));
};
StringTools.lpad = function(s,c,l) {
	if(c.length <= 0) {
		return s;
	}
	var buf_b = "";
	l -= s.length;
	while(buf_b.length < l) buf_b += c == null ? "null" : "" + c;
	buf_b += s == null ? "null" : "" + s;
	return buf_b;
};
StringTools.replace = function(s,sub,by) {
	return s.split(sub).join(by);
};
var haxe_io_Output = function() { };
haxe_io_Output.__name__ = true;
haxe_io_Output.prototype = {
	writeByte: function(c) {
		throw haxe_Exception.thrown("Not implemented");
	}
	,writeBytes: function(s,pos,len) {
		if(pos < 0 || len < 0 || pos + len > s.length) {
			throw haxe_Exception.thrown(haxe_io_Error.OutsideBounds);
		}
		var b = s.b;
		var k = len;
		while(k > 0) {
			this.writeByte(b[pos]);
			++pos;
			--k;
		}
		return len;
	}
	,writeFullBytes: function(s,pos,len) {
		while(len > 0) {
			var k = this.writeBytes(s,pos,len);
			pos += k;
			len -= k;
		}
	}
	,writeString: function(s,encoding) {
		var b = haxe_io_Bytes.ofString(s,encoding);
		this.writeFullBytes(b,0,b.length);
	}
	,__class__: haxe_io_Output
};
var _$Sys_FileOutput = function(fd) {
	this.fd = fd;
};
_$Sys_FileOutput.__name__ = true;
_$Sys_FileOutput.__super__ = haxe_io_Output;
_$Sys_FileOutput.prototype = $extend(haxe_io_Output.prototype,{
	writeByte: function(c) {
		js_node_Fs.writeSync(this.fd,String.fromCodePoint(c));
	}
	,writeBytes: function(s,pos,len) {
		var data = s.b;
		return js_node_Fs.writeSync(this.fd,js_node_buffer_Buffer.from(data.buffer,data.byteOffset,s.length),pos,len);
	}
	,writeString: function(s,encoding) {
		js_node_Fs.writeSync(this.fd,s);
	}
	,__class__: _$Sys_FileOutput
});
var haxe_io_Input = function() { };
haxe_io_Input.__name__ = true;
haxe_io_Input.prototype = {
	readByte: function() {
		throw haxe_Exception.thrown("Not implemented");
	}
	,readBytes: function(s,pos,len) {
		var k = len;
		var b = s.b;
		if(pos < 0 || len < 0 || pos + len > s.length) {
			throw haxe_Exception.thrown(haxe_io_Error.OutsideBounds);
		}
		try {
			while(k > 0) {
				b[pos] = this.readByte();
				++pos;
				--k;
			}
		} catch( _g ) {
			haxe_NativeStackTrace.lastError = _g;
			if(!((haxe_Exception.caught(_g).unwrap()) instanceof haxe_io_Eof)) {
				throw _g;
			}
		}
		return len - k;
	}
	,__class__: haxe_io_Input
};
var _$Sys_FileInput = function(fd) {
	this.fd = fd;
};
_$Sys_FileInput.__name__ = true;
_$Sys_FileInput.__super__ = haxe_io_Input;
_$Sys_FileInput.prototype = $extend(haxe_io_Input.prototype,{
	readByte: function() {
		var buf = js_node_buffer_Buffer.alloc(1);
		try {
			js_node_Fs.readSync(this.fd,buf,0,1,null);
		} catch( _g ) {
			haxe_NativeStackTrace.lastError = _g;
			var _g1 = haxe_Exception.caught(_g).unwrap();
			if(_g1.code == "EOF") {
				throw haxe_Exception.thrown(new haxe_io_Eof());
			} else {
				throw haxe_Exception.thrown(haxe_io_Error.Custom(_g1));
			}
		}
		return buf[0];
	}
	,readBytes: function(s,pos,len) {
		var data = s.b;
		var buf = js_node_buffer_Buffer.from(data.buffer,data.byteOffset,s.length);
		try {
			return js_node_Fs.readSync(this.fd,buf,pos,len,null);
		} catch( _g ) {
			haxe_NativeStackTrace.lastError = _g;
			var _g1 = haxe_Exception.caught(_g).unwrap();
			if(_g1.code == "EOF") {
				throw haxe_Exception.thrown(new haxe_io_Eof());
			} else {
				throw haxe_Exception.thrown(haxe_io_Error.Custom(_g1));
			}
		}
	}
	,__class__: _$Sys_FileInput
});
var Type = function() { };
Type.__name__ = true;
Type.enumEq = function(a,b) {
	if(a == b) {
		return true;
	}
	try {
		var e = a.__enum__;
		if(e == null || e != b.__enum__) {
			return false;
		}
		if(a._hx_index != b._hx_index) {
			return false;
		}
		var enm = $hxEnums[e];
		var ctorName = enm.__constructs__[a._hx_index];
		var params = enm[ctorName].__params__;
		var _g = 0;
		while(_g < params.length) {
			var f = params[_g];
			++_g;
			if(!Type.enumEq(a[f],b[f])) {
				return false;
			}
		}
	} catch( _g ) {
		haxe_NativeStackTrace.lastError = _g;
		return false;
	}
	return true;
};
var formatter_Cli = function() {
	this.exitCode = 0;
	this.mode = formatter_Mode.Format;
	this.verbose = false;
	var _gthis = this;
	var args = process.argv.slice(2);
	if(process.env["HAXELIB_RUN"] == "1") {
		if(args.length > 0) {
			var s = args.pop();
			process.chdir(s);
		}
	}
	var paths = [];
	var help = false;
	var pipemode = false;
	var argHandler_getDoc = function() {
		return "[-s | --source] <path>    : File or directory with .hx files to format (multiple allowed)\n[--stdin]                 : Read code from stdin and print formatted output to stdout (needs _one_ -s <path> for reference in configuration detection)\n[-v]                      : Print additional information\n[--check]                 : Don't format, only check if files are formatted correctly\n[--default-config] <path> : Generate a default hxformat.json to a file and exit\n[--help]                  : Display this list of options";
	};
	var argHandler_parse = function(__args) {
		var __index = 0;
		while(__index < __args.length) {
			var _g = __args[__index++];
			switch(_g) {
			case "--check":
				if(__index > __args.length) {
					if(![][__args.length - 1]) {
						throw haxe_Exception.thrown("Not enough arguments: " + Std.string(__args[__index - 1]) + " expects " + 0);
					}
				}
				_gthis.mode = formatter_Mode.Check;
				__index += 0;
				break;
			case "--default-config":
				if(__index + 1 > __args.length) {
					if(![false][__args.length - 1]) {
						throw haxe_Exception.thrown("Not enough arguments: " + Std.string(__args[__index - 1]) + " expects " + 1);
					}
				}
				_gthis.generateDefaultConfig(__args[__index]);
				++__index;
				break;
			case "--help":
				if(__index > __args.length) {
					if(![][__args.length - 1]) {
						throw haxe_Exception.thrown("Not enough arguments: " + Std.string(__args[__index - 1]) + " expects " + 0);
					}
				}
				help = true;
				__index += 0;
				break;
			case "--stdin":
				if(__index > __args.length) {
					if(![][__args.length - 1]) {
						throw haxe_Exception.thrown("Not enough arguments: " + Std.string(__args[__index - 1]) + " expects " + 0);
					}
				}
				pipemode = true;
				__index += 0;
				break;
			case "--source":case "-s":
				if(__index + 1 > __args.length) {
					if(![false][__args.length - 1]) {
						throw haxe_Exception.thrown("Not enough arguments: " + Std.string(__args[__index - 1]) + " expects " + 1);
					}
				}
				paths.push(__args[__index]);
				++__index;
				break;
			case "-v":
				if(__index > __args.length) {
					if(![][__args.length - 1]) {
						throw haxe_Exception.thrown("Not enough arguments: " + Std.string(__args[__index - 1]) + " expects " + 0);
					}
				}
				_gthis.verbose = true;
				__index += 0;
				break;
			default:
				throw haxe_Exception.thrown("Unknown command: " + Std.string(_g));
			}
		}
	};
	var printHelp = function() {
		process.stdout.write(Std.string("Haxe Formatter " + "1.12.0"));
		process.stdout.write("\n");
		var v = argHandler_getDoc();
		process.stdout.write(Std.string(v));
		process.stdout.write("\n");
	};
	try {
		argHandler_parse(args);
	} catch( _g ) {
		haxe_NativeStackTrace.lastError = _g;
		var _g1 = haxe_Exception.caught(_g).unwrap();
		new _$Sys_FileOutput(2).writeString((_g1 == null ? "null" : Std.string(_g1)) + "\n");
		printHelp();
		process.exit(1);
	}
	if(args.length == 0 || help) {
		printHelp();
		process.exit(0);
	}
	if(pipemode) {
		this.runPipe(paths);
		process.exit(0);
	}
	var hrtime = process.hrtime();
	var startTime = hrtime[0] + hrtime[1] / 1e9;
	this.run(paths);
	var hrtime = process.hrtime();
	this.printStats(hrtime[0] + hrtime[1] / 1e9 - startTime);
	var code = this.exitCode;
	process.exit(code);
};
formatter_Cli.__name__ = true;
formatter_Cli.main = function() {
	new formatter_Cli();
};
formatter_Cli.prototype = {
	printStats: function(duration) {
		var seconds = Math.round(duration * 1000) / 1000;
		var action = this.mode == formatter_Mode.Format ? "Formatted" : "Checked";
		process.stdout.write("");
		process.stdout.write("\n");
		var fileNumber;
		if(formatter_FormatStats.successFiles != formatter_FormatStats.totalFiles) {
			fileNumber = "" + formatter_FormatStats.successFiles + "/" + formatter_FormatStats.totalFiles;
		} else {
			fileNumber = "" + formatter_FormatStats.successFiles;
		}
		process.stdout.write(Std.string("" + action + " " + fileNumber + " files in " + seconds + " s."));
		process.stdout.write("\n");
		if(formatter_FormatStats.failedFiles > 0) {
			var v = "Format failed on " + formatter_FormatStats.failedFiles + " files";
			process.stdout.write(Std.string(v));
			process.stdout.write("\n");
		}
		if(formatter_FormatStats.disabledFiles > 0) {
			var v = "Number of disabled files: " + formatter_FormatStats.disabledFiles;
			process.stdout.write(Std.string(v));
			process.stdout.write("\n");
		}
		process.stdout.write("-------------------------");
		process.stdout.write("\n");
		var v = "Input lines:  " + formatter_FormatStats.totalLinesOrig;
		process.stdout.write(Std.string(v));
		process.stdout.write("\n");
		var v = "Output lines: " + formatter_FormatStats.totalLinesFormatted;
		process.stdout.write(Std.string(v));
		process.stdout.write("\n");
		process.stdout.write("-------------------------");
		process.stdout.write("\n");
	}
	,generateDefaultConfig: function(path) {
		if(sys_FileSystem.isDirectory(path)) {
			process.stdout.write(Std.string("\"" + path + "\" is a directory, not a file"));
			process.stdout.write("\n");
			process.exit(1);
		}
		js_node_Fs.writeFileSync(path,JSON.stringify(new JsonParser_$1().fromJson("{}","default-hxformat.json"),null,"\t"));
		process.exit(0);
	}
	,run: function(paths) {
		var _g = 0;
		while(_g < paths.length) {
			var path = StringTools.trim(paths[_g++]);
			if(!sys_FileSystem.exists(path)) {
				process.stdout.write(Std.string("Skipping '" + path + "' (path does not exist)"));
				process.stdout.write("\n");
				continue;
			}
			if(sys_FileSystem.isDirectory(path)) {
				var _g1 = [];
				var _g2 = 0;
				var _g3 = js_node_Fs.readdirSync(path);
				while(_g2 < _g3.length) _g1.push(haxe_io_Path.join([path,_g3[_g2++]]));
				this.run(_g1);
			} else {
				this.formatFile(path);
			}
		}
	}
	,runPipe: function(paths) {
		var content = null;
		try {
			content = this.readNodeJsBytes(new _$Sys_FileInput(0));
			if(content == null) {
				new _$Sys_FileOutput(2).writeString("Could not read anything from STDIN");
				process.exit(-1);
			}
			if(paths.length != 1) {
				process.stdout.write(Std.string(content));
				process.stdout.write("\n");
				new _$Sys_FileOutput(2).writeString("Please use exactly one `--source <path>` parameter when calling formatter with `--stdin`");
				process.exit(3);
			}
			if(!sys_FileSystem.exists(paths[0])) {
				process.stdout.write(Std.string(content));
				process.stdout.write("\n");
				new _$Sys_FileOutput(2).writeString("Could not find \"" + paths[0] + "\"");
				process.exit(3);
			}
			var config = formatter_Formatter.loadConfig(paths[0]);
			var result = formatter_Formatter.format(formatter_FormatterInput.Code(content.toString()),config);
			switch(result._hx_index) {
			case 0:
				process.stdout.write(Std.string(result.formattedCode));
				process.stdout.write("\n");
				process.exit(0);
				break;
			case 1:
				process.stdout.write(Std.string(content));
				process.stdout.write("\n");
				new _$Sys_FileOutput(2).writeString("Format failed: " + result.errorMessage);
				process.exit(2);
				break;
			case 2:
				process.stdout.write(Std.string(content));
				process.stdout.write("\n");
				process.exit(1);
				break;
			}
		} catch( _g ) {
			haxe_NativeStackTrace.lastError = _g;
			var _g1 = haxe_Exception.caught(_g).unwrap();
			if(content != null) {
				process.stdout.write(Std.string(content));
				process.stdout.write("\n");
			}
			new _$Sys_FileOutput(2).writeString("Format failed: " + (_g1 == null ? "null" : Std.string(_g1)));
			process.exit(-1);
		}
	}
	,formatFile: function(path) {
		var _gthis = this;
		if(StringTools.endsWith(path,".hx")) {
			var config = formatter_Formatter.loadConfig(path);
			if(this.verbose) {
				this.verboseLogFile(path,config);
			}
			var content = js_node_Fs.readFileSync(path,{ encoding : "utf8"});
			var result = formatter_Formatter.format(formatter_FormatterInput.Code(content),config);
			switch(result._hx_index) {
			case 0:
				var _g = result.formattedCode;
				formatter_FormatStats.totalFiles++;
				formatter_FormatStats.successFiles++;
				switch(this.mode._hx_index) {
				case 0:
					js_node_Fs.writeFileSync(path,_g);
					break;
				case 1:
					if(_g != content.toString()) {
						process.stdout.write(Std.string("Incorrect formatting in " + path));
						process.stdout.write("\n");
						this.exitCode = 1;
					}
					break;
				case 2:
					var secondResult = formatter_Formatter.format(formatter_FormatterInput.Code(_g),config);
					var unstable = function() {
						process.stdout.write(Std.string("Unstable formatting in " + path));
						process.stdout.write("\n");
						_gthis.exitCode = 1;
					};
					switch(secondResult._hx_index) {
					case 0:
						if(_g != secondResult.formattedCode) {
							unstable();
						}
						break;
					case 1:
						unstable();
						break;
					default:
					}
					break;
				}
				break;
			case 1:
				formatter_FormatStats.totalFiles++;
				formatter_FormatStats.failedFiles++;
				new _$Sys_FileOutput(2).writeString("Failed to format " + path + ": " + result.errorMessage + "\n");
				this.exitCode = 1;
				break;
			case 2:
				formatter_FormatStats.totalFiles++;
				formatter_FormatStats.disabledFiles++;
				break;
			}
		}
	}
	,verboseLogFile: function(path,config) {
		if(config != null) {
			if(this.lastConfigFileName == null || this.lastConfigFileName != config.configFileName) {
				if(this.lastConfigFileName != null) {
					process.stdout.write("");
					process.stdout.write("\n");
				}
				this.lastConfigFileName = config.configFileName;
				var v = "Using " + this.lastConfigFileName + ":";
				process.stdout.write(Std.string(v));
				process.stdout.write("\n");
			}
		}
		var action = this.mode == formatter_Mode.Format ? "Formatting" : "Checking";
		process.stdout.write(Std.string("" + action + " " + path));
		process.stdout.write("\n");
	}
	,readNodeJsBytes: function(stdIn) {
		var buf = new haxe_io_Bytes(new ArrayBuffer(16384));
		var total = new haxe_io_BytesBuffer();
		try {
			while(true) {
				var len = stdIn.readBytes(buf,0,16384);
				if(len == 0) {
					break;
				}
				total.addBytes(buf,0,len);
			}
		} catch( _g ) {
			haxe_NativeStackTrace.lastError = _g;
		}
		return total.getBytes();
	}
	,__class__: formatter_Cli
};
var formatter_Mode = $hxEnums["formatter.Mode"] = { __ename__ : true, __constructs__ : ["Format","Check","CheckStability"]
	,Format: {_hx_index:0,__enum__:"formatter.Mode",toString:$estr}
	,Check: {_hx_index:1,__enum__:"formatter.Mode",toString:$estr}
	,CheckStability: {_hx_index:2,__enum__:"formatter.Mode",toString:$estr}
};
var formatter_FormatStats = function() { };
formatter_FormatStats.__name__ = true;
var formatter_Result = $hxEnums["formatter.Result"] = { __ename__ : true, __constructs__ : ["Success","Failure","Disabled"]
	,Success: ($_=function(formattedCode) { return {_hx_index:0,formattedCode:formattedCode,__enum__:"formatter.Result",toString:$estr}; },$_.__params__ = ["formattedCode"],$_)
	,Failure: ($_=function(errorMessage) { return {_hx_index:1,errorMessage:errorMessage,__enum__:"formatter.Result",toString:$estr}; },$_.__params__ = ["errorMessage"],$_)
	,Disabled: {_hx_index:2,__enum__:"formatter.Result",toString:$estr}
};
var formatter_Formatter = function() { };
formatter_Formatter.__name__ = true;
formatter_Formatter.format = function(input,config,lineSeparator,entryPoint,range) {
	if(config == null) {
		config = new formatter_config_Config();
	}
	var inputData;
	switch(input._hx_index) {
	case 0:
		var _g = input.fileName;
		if(!sys_FileSystem.exists(_g)) {
			process.stdout.write(Std.string("Skipping '" + _g + "' (path does not exist)"));
			process.stdout.write("\n");
			return formatter_Result.Failure("File \"" + _g + "\" not found");
		}
		inputData = { fileName : _g, content : js_node_buffer__$Buffer_Helper.bytesOfBuffer(js_node_Fs.readFileSync(_g)), config : config, lineSeparator : lineSeparator, entryPoint : entryPoint, range : range};
		return formatter_Formatter.formatInputData(inputData);
	case 1:
		inputData = { fileName : "code snippet", content : haxe_io_Bytes.ofString(input.code), config : config, lineSeparator : lineSeparator, entryPoint : entryPoint, range : range};
		return formatter_Formatter.formatInputData(inputData);
	case 2:
		inputData = { fileName : "<unknown.hx>", content : input.code, tokenList : input.tokenList, tokenTree : input.tokenTree, config : config, lineSeparator : lineSeparator, entryPoint : entryPoint, range : range};
		return formatter_Formatter.formatInputData(inputData);
	}
};
formatter_Formatter.loadConfig = function(path) {
	var configFileName = formatter_Formatter.determineConfig(path);
	if(configFileName == null) {
		return null;
	}
	var config = new formatter_config_Config();
	config.readConfig(configFileName);
	return config;
};
formatter_Formatter.formatInputData = function(inputData) {
	try {
		var config = inputData.config;
		if(config.disableFormatting) {
			return formatter_Result.Disabled;
		}
		if(config.isExcluded(inputData.fileName)) {
			return formatter_Result.Disabled;
		}
		tokentree_TokenStream.MODE = tokentree_TokenStreamMode.Relaxed;
		var parsedCode = new formatter_codedata_ParsedCode(inputData);
		formatter_FormatStats.totalLinesOrig += parsedCode.lines.length;
		var indenter = new formatter_marker_Indenter(config.indentation);
		indenter.setParsedCode(parsedCode);
		var markTokenText = new formatter_marker_MarkTokenText(config,parsedCode,indenter);
		var markWhitespace = new formatter_marker_MarkWhitespace(config,parsedCode,indenter);
		var markLineEnds = new formatter_marker_MarkLineEnds(config,parsedCode,indenter);
		var markSameLine = new formatter_marker_MarkSameLine(config,parsedCode,indenter);
		var markWrapping = new formatter_marker_wrapping_MarkWrapping(config,parsedCode,indenter);
		var markEmptyLines = new formatter_marker_MarkEmptyLines(config,parsedCode,indenter);
		var markAdditionalIndent = new formatter_marker_MarkAdditionalIndentation(config,parsedCode,indenter);
		markTokenText.run();
		markWhitespace.run();
		markLineEnds.run();
		markSameLine.run();
		markWrapping.run();
		markEmptyLines.run();
		markTokenText.finalRun();
		markAdditionalIndent.run();
		var outputLineEnds = formatter_marker_MarkLineEnds.outputLineSeparator(config.lineEnds,parsedCode);
		var lines = new formatter_codedata_CodeLines(parsedCode,indenter,inputData.range);
		lines.applyWrapping(config.wrapping,outputLineEnds);
		markEmptyLines.finalRun(lines);
		var formatted = lines.print(outputLineEnds);
		formatter_FormatStats.totalLinesFormatted += formatted.split(outputLineEnds).length;
		return formatter_Result.Success(formatted);
	} catch( _g ) {
		haxe_NativeStackTrace.lastError = _g;
		var _g1 = haxe_Exception.caught(_g).unwrap();
		var callstack = haxe_CallStack.toString(haxe_CallStack.exceptionStack());
		return formatter_Result.Failure((_g1 == null ? "null" : Std.string(_g1)) + "\n" + callstack + "\n\n");
	}
};
formatter_Formatter.determineConfig = function(fileName) {
	var path = js_node_Path.resolve(fileName);
	if(!sys_FileSystem.isDirectory(path)) {
		path = haxe_io_Path.directory(path);
	}
	while(path.length > 0) {
		var configFile = haxe_io_Path.join([path,"hxformat.json"]);
		if(sys_FileSystem.exists(configFile)) {
			return configFile;
		}
		path = haxe_io_Path.normalize(haxe_io_Path.join([path,".."]));
	}
	return null;
};
var formatter_FormatterInput = $hxEnums["formatter.FormatterInput"] = { __ename__ : true, __constructs__ : ["FileInput","Code","Tokens"]
	,FileInput: ($_=function(fileName) { return {_hx_index:0,fileName:fileName,__enum__:"formatter.FormatterInput",toString:$estr}; },$_.__params__ = ["fileName"],$_)
	,Code: ($_=function(code) { return {_hx_index:1,code:code,__enum__:"formatter.FormatterInput",toString:$estr}; },$_.__params__ = ["code"],$_)
	,Tokens: ($_=function(tokenList,tokenTree,code) { return {_hx_index:2,tokenList:tokenList,tokenTree:tokenTree,code:code,__enum__:"formatter.FormatterInput",toString:$estr}; },$_.__params__ = ["tokenList","tokenTree","code"],$_)
};
var formatter_codedata_CodeLine = function(indent) {
	this.indent = indent;
	this.parts = [];
	this.emptyLinesAfter = 0;
	this.verbatim = false;
	this.partialLine = false;
};
formatter_codedata_CodeLine.__name__ = true;
formatter_codedata_CodeLine.prototype = {
	addToken: function(tokenInfo) {
		if(tokenInfo.emptyLinesAfter > this.emptyLinesAfter) {
			this.emptyLinesAfter = tokenInfo.emptyLinesAfter;
		}
		if(this.currentPart == null) {
			this.currentPart = { firstToken : tokenInfo.token, lastToken : tokenInfo.token, text : "", multiLine : false, firstLineLength : -1, lastLineLength : -1};
			this.parts.push(this.currentPart);
		}
		this.currentPart.lastToken = tokenInfo.token;
		if(tokenInfo.spacesBefore > 0) {
			this.currentPart.text += StringTools.lpad(""," ",tokenInfo.spacesBefore);
		}
		if(tokenInfo.whitespaceAfter == formatter_codedata_WhitespaceAfterType.Space && tokenInfo.spacesAfter > 0) {
			this.currentPart.text += tokenInfo.text + StringTools.lpad(""," ",tokenInfo.spacesAfter);
		} else {
			this.currentPart.text += tokenInfo.text;
		}
		if(tokenInfo.wrapAfter) {
			this.currentPart = null;
		}
	}
	,applyWrapping: function(config,parsedCode,indenter,lineSeparator) {
		var lineLength = indenter.calcAbsoluteIndent(this.indent);
		var _g = 0;
		var _g1 = this.parts;
		while(_g < _g1.length) this.calcLineLengths(_g1[_g++],lineSeparator);
		var _g = 0;
		var _g1 = this.parts.length;
		while(_g < _g1) {
			var index = _g++;
			var part = this.parts[index];
			if(part.multiLine) {
				if(lineLength + part.firstLineLength > config.maxLineLength) {
					return this.wrappedAt(index,config,parsedCode,indenter);
				}
				lineLength = part.lastLineLength;
				continue;
			}
			lineLength += part.text.length;
			if(lineLength > config.maxLineLength) {
				return this.wrappedAt(index,config,parsedCode,indenter);
			}
		}
		return [this];
	}
	,calcLineLengths: function(part,lineSeparator) {
		var lines = part.text.split(lineSeparator);
		part.multiLine = lines.length > 1;
		if(part.multiLine) {
			part.firstLineLength = lines[0].length;
			part.lastLineLength = lines[lines.length - 1].length;
		} else {
			part.firstLineLength = part.text.length;
			part.lastLineLength = -1;
		}
	}
	,wrappedAt: function(index,config,parsedCode,indenter) {
		return this.wrapNormal(config,parsedCode,indenter);
	}
	,wrapNormal: function(config,parsedCode,indenter) {
		if(this.parts.length <= 0) {
			return [this];
		}
		var line = new formatter_codedata_CodeLine(this.indent);
		var part = this.parts.shift();
		line.parts = [part];
		var lineLength = indenter.calcAbsoluteIndent(this.indent) + part.text.length;
		var lines = [line];
		var lastPart = part;
		while(this.parts.length > 0) {
			var p = this.parts.shift();
			var partLength = p.firstLineLength;
			if(!p.multiLine) {
				partLength = StringTools.rtrim(p.text).length;
			}
			if(lineLength + partLength >= config.maxLineLength) {
				parsedCode.tokenList.lineEndAfter(lastPart.lastToken);
				var info = parsedCode.tokenList.getTokenAt(p.firstToken.index);
				var additionalIndent = 0;
				if(info != null) {
					additionalIndent = info.additionalIndent;
				}
				var newIndent = indenter.calcIndent(p.firstToken) + additionalIndent;
				line = new formatter_codedata_CodeLine(newIndent);
				lineLength = indenter.calcAbsoluteIndent(newIndent);
				lines.push(line);
			}
			line.parts.push(p);
			if(p.lastLineLength <= 0) {
				lineLength += p.firstLineLength;
			} else {
				lineLength += p.lastLineLength;
			}
			lastPart = p;
		}
		line.emptyLinesAfter = this.emptyLinesAfter;
		return lines;
	}
	,print: function(indenter,lineSeparator) {
		var line = "";
		var _g = 0;
		var _g1 = this.parts;
		while(_g < _g1.length) line += _g1[_g++].text;
		if(this.partialLine) {
			line = indenter.makeIndentString(this.indent) + line;
		} else {
			line = indenter.makeIndentString(this.indent) + StringTools.rtrim(line);
		}
		var _g = 0;
		var _g1 = this.emptyLinesAfter;
		while(_g < _g1) {
			++_g;
			if(indenter.shouldAddTrailingWhitespace()) {
				line += indenter.makeIndentString(this.indent);
			}
			line += lineSeparator;
		}
		return line;
	}
	,__class__: formatter_codedata_CodeLine
};
var formatter_codedata_CodeLines = function(parsedCode,indenter,range) {
	this.lines = [];
	this.indenter = indenter;
	this.parsedCode = parsedCode;
	this.range = null;
	this.posRange = range;
	this.trailingWhitespaceAfterRange = "";
	this.rangeStartOffset = 0;
	this.rangeEndOffset = 0;
	if(range != null) {
		var start = parsedCode.tokenList.getTokenAtOffset(range.startPos);
		var end = parsedCode.tokenList.getTokenAtOffset(range.endPos);
		if(end != null && range.endPos - 1 < end.token.pos.min) {
			end = parsedCode.tokenList.getPreviousToken(end.token);
		}
		if(start != null && end != null) {
			if(start.token.tok._hx_index == 7) {
				this.rangeStartOffset = this.calcStartCommentOffset(start);
			} else {
				var startLine = parsedCode.getLinePos(start.token.pos.min);
				var rangeStartLine = parsedCode.getLinePos(range.startPos);
				parsedCode.getLinePos(start.token.pos.max);
				if(startLine.line != rangeStartLine.line) {
					this.rangeStartOffset = range.startPos - rangeStartLine.ofs - start.token.pos.min;
				}
			}
			if(end.token.tok._hx_index == 7) {
				this.rangeEndOffset = this.calcEndCommentOffset(end);
			} else if(this.posRange.endPos >= end.token.pos.min && this.posRange.endPos < end.token.pos.max) {
				this.rangeEndOffset = end.text.length - (end.token.pos.max - this.posRange.endPos);
			}
			this.range = { startPos : start.token.index, endPos : end.token.index};
		}
	}
	this.buildLines();
};
formatter_codedata_CodeLines.__name__ = true;
formatter_codedata_CodeLines.prototype = {
	calcStartCommentOffset: function(info) {
		var commentLines = this.parsedCode.getString(info.token.pos.min,info.token.pos.max).split(this.parsedCode.lineSeparator);
		var index = 0;
		var offset = 0;
		var sepLength = this.parsedCode.lineSeparator.length;
		var pos = this.posRange.startPos - info.token.pos.min;
		var _g = 0;
		while(_g < commentLines.length) {
			var line = commentLines[_g];
			++_g;
			if(line.length + offset + sepLength > pos) {
				break;
			}
			offset += line.length + sepLength;
			++index;
		}
		commentLines = info.text.split(this.parsedCode.lineSeparator);
		offset = 0;
		var _g = 0;
		var _g1 = index;
		while(_g < _g1) offset += commentLines[_g++].length + sepLength;
		return offset;
	}
	,calcEndCommentOffset: function(info) {
		var commentLines = this.parsedCode.getString(info.token.pos.min,info.token.pos.max).split(this.parsedCode.lineSeparator);
		var index = 0;
		var offset = 0;
		var trailCount = 0;
		var pos = this.posRange.endPos - info.token.pos.min;
		var sepLength = this.parsedCode.lineSeparator.length;
		var _g = 0;
		while(_g < commentLines.length) {
			var line = commentLines[_g];
			++_g;
			if(line.length + offset + sepLength > pos) {
				trailCount = line.length - (pos - offset);
				break;
			}
			offset += line.length + sepLength;
			++index;
		}
		commentLines = info.text.split(this.parsedCode.lineSeparator);
		offset = 0;
		var _g = 0;
		var _g1 = index;
		while(_g < _g1) offset += commentLines[_g++].length + sepLength;
		return offset + commentLines[index].length - trailCount;
	}
	,buildLines: function() {
		var line = null;
		var index = 0;
		while(index < this.parsedCode.tokenList.tokens.length) {
			if(this.range != null) {
				if(index > this.range.endPos) {
					break;
				}
			}
			var tokenInfo = this.parsedCode.tokenList.getTokenAt(index);
			if(tokenInfo == null) {
				++index;
				continue;
			}
			var _g = tokenInfo.token.tok;
			if(_g._hx_index == 8) {
				if(_g.s == " @formatter:off") {
					line = null;
					index = this.skipFormatterOff(index);
					continue;
				}
			}
			if(this.range != null) {
				if(index < this.range.startPos) {
					++index;
					continue;
				}
			}
			if(line == null) {
				line = new formatter_codedata_CodeLine(this.indenter.calcIndent(tokenInfo.token) + tokenInfo.additionalIndent);
				this.lines.push(line);
			}
			if(this.range != null) {
				if(index == this.range.startPos && this.rangeStartOffset > 0) {
					tokenInfo.text = HxOverrides.substr(tokenInfo.text,this.rangeStartOffset,null);
					line.indent = 0;
				}
			}
			if(this.range != null && index == this.range.endPos) {
				if(this.posRange.endPos >= tokenInfo.token.pos.min && this.posRange.endPos < tokenInfo.token.pos.max) {
					var index1 = 0;
					if(this.range.endPos == this.range.startPos) {
						index1 = this.rangeStartOffset;
					}
					tokenInfo.text = HxOverrides.substr(tokenInfo.text,0,this.rangeEndOffset - index1);
					tokenInfo.spacesAfter = 0;
					tokenInfo.whitespaceAfter = formatter_codedata_WhitespaceAfterType.None;
					tokenInfo.emptyLinesAfter = 0;
					line.partialLine = true;
				}
				if(this.posRange.endPos > tokenInfo.token.pos.max) {
					this.trailingWhitespaceAfterRange = this.parsedCode.getString(tokenInfo.token.pos.max,this.posRange.endPos);
					line.partialLine = true;
				}
			}
			line.addToken(tokenInfo);
			if(tokenInfo.whitespaceAfter == formatter_codedata_WhitespaceAfterType.Newline) {
				line = null;
			}
			++index;
		}
	}
	,skipFormatterOff: function(index) {
		var startIndex = index++;
		var startInfo = this.parsedCode.tokenList.getTokenAt(startIndex);
		var startLine = this.parsedCode.getLinePos(startInfo.token.pos.min).line;
		while(index < this.parsedCode.tokenList.tokens.length) {
			var endIndex = index++;
			var tokenInfo = this.parsedCode.tokenList.getTokenAt(endIndex);
			if(tokenInfo == null) {
				continue;
			}
			if(this.range != null) {
				if(endIndex < this.range.startPos) {
					continue;
				}
				if(endIndex == this.range.startPos) {
					startInfo = this.parsedCode.tokenList.getTokenAt(endIndex);
					startLine = this.parsedCode.getLinePos(startInfo.token.pos.min).line;
				}
				if(endIndex >= this.range.endPos) {
					this.copyVerbatimChars(startInfo.token.pos.min,tokenInfo.token.pos.max);
					return index;
				}
			}
			var _g = tokenInfo.token.tok;
			if(_g._hx_index == 8) {
				if(_g.s == " @formatter:on") {
					if(this.range != null) {
						if(startIndex < this.range.startPos) {
							this.copyVerbatimChars(startInfo.token.pos.min,tokenInfo.token.pos.max);
							return index;
						}
					}
					this.copyVerbatimLines(startLine,this.parsedCode.getLinePos(tokenInfo.token.pos.max).line);
					return index;
				}
			}
		}
		this.copyVerbatimLines(startLine,this.parsedCode.lines.length - 1);
		return index;
	}
	,copyVerbatimLines: function(startLine,endLine) {
		var content = this.parsedCode.getString(this.parsedCode.linesIdx[startLine].l,this.parsedCode.linesIdx[endLine].r);
		if(endLine < this.parsedCode.lines.length - 1) {
			content = StringTools.rtrim(content);
		}
		this.lines.push(new formatter_codedata_VerbatimCodeLine(content));
	}
	,copyVerbatimChars: function(startPos,endPos) {
		var content = this.parsedCode.getString(startPos,endPos);
		this.lines.push(new formatter_codedata_VerbatimCodeLine(content));
	}
	,applyWrapping: function(config,lineSeparator) {
		var wrappedLines = [];
		var _g = 0;
		var _g1 = this.lines;
		while(_g < _g1.length) wrappedLines = wrappedLines.concat(_g1[_g++].applyWrapping(config,this.parsedCode,this.indenter,lineSeparator));
		this.lines = wrappedLines;
	}
	,print: function(lineSeparator) {
		var _gthis = this;
		var prefix = "";
		if(this.parsedCode.tokenList.leadingEmptyLInes > 0) {
			prefix = StringTools.lpad("",lineSeparator,lineSeparator.length * this.parsedCode.tokenList.leadingEmptyLInes);
		}
		if(this.range != null) {
			if(this.range.startPos > 0) {
				prefix = "";
			}
			if(this.lines.length > 0) {
				this.lines[this.lines.length - 1].emptyLinesAfter = 0;
			}
		}
		var _this = this.lines;
		var result = new Array(_this.length);
		var _g = 0;
		var _g1 = _this.length;
		while(_g < _g1) {
			var i = _g++;
			result[i] = _this[i].print(_gthis.indenter,lineSeparator);
		}
		return prefix + result.join(lineSeparator) + this.trailingWhitespaceAfterRange;
	}
	,__class__: formatter_codedata_CodeLines
};
var formatter_codedata_ParsedCode = function(inputData) {
	this.file = { name : inputData.fileName, content : inputData.content};
	try {
		this.removeBOM();
		if(inputData.lineSeparator == null) {
			this.detectLineSeparator();
		} else {
			this.lineSeparator = inputData.lineSeparator;
		}
		this.makeLines();
		this.makePosIndices();
		if(inputData.tokenList == null) {
			this.makeTokens();
			this.getTokenTree(inputData.entryPoint);
		} else {
			this.tokens = inputData.tokenList;
			this.root = inputData.tokenTree;
			this.makeTokenList();
		}
		this.checkTokens();
	} catch( _g ) {
		haxe_NativeStackTrace.lastError = _g;
		var _g1 = haxe_Exception.caught(_g).unwrap();
		throw haxe_Exception.thrown("failed to create parser context: " + (_g1 == null ? "null" : Std.string(_g1)));
	}
};
formatter_codedata_ParsedCode.__name__ = true;
formatter_codedata_ParsedCode.prototype = {
	checkTokens: function() {
		if(this.tokens.length != this.tokenList.tokens.length) {
			throw haxe_Exception.thrown("token count mismatch");
		}
		var skipCount = 0;
		var _g = 0;
		var _g1 = this.tokens.length;
		while(_g < _g1) {
			var index = _g++;
			var info = this.tokenList.tokens[index];
			if(info == null) {
				if(skipCount <= 0) {
					throw haxe_Exception.thrown("missing token \"" + Std.string(this.tokens[index]) + "\" [" + index + "] detected!");
				}
				--skipCount;
				continue;
			}
			var _g2 = info.token.tok;
			switch(_g2._hx_index) {
			case 2:
				var _g3 = _g2.c;
				switch(_g3._hx_index) {
				case 0:
					if(StringTools.startsWith(_g3.v,"-")) {
						skipCount = 1;
					}
					break;
				case 1:
					if(StringTools.startsWith(_g3.f,"-")) {
						skipCount = 1;
					}
					break;
				default:
					skipCount = 0;
				}
				break;
			case 6:
				var _g4 = _g2.op;
				switch(_g4._hx_index) {
				case 8:
					skipCount = 1;
					break;
				case 17:
					skipCount = 1;
					break;
				case 18:
					skipCount = 2;
					break;
				case 20:
					switch(_g4.op._hx_index) {
					case 17:
						skipCount = 2;
						break;
					case 18:
						skipCount = 3;
						break;
					default:
						skipCount = 0;
					}
					break;
				default:
					skipCount = 0;
				}
				break;
			default:
				skipCount = 0;
			}
		}
	}
	,getTokenTree: function(entryPoint) {
		if(this.tokens == null) {
			return null;
		}
		if(entryPoint == null) {
			entryPoint = tokentree_TokenTreeEntryPoint.TypeLevel;
		}
		if(this.root == null) {
			this.root = tokentree_TokenTreeBuilder.buildTokenTree(this.tokens,this.file.content,entryPoint);
			this.makeTokenList();
		}
		return this.root;
	}
	,removeBOM: function() {
		if(this.file.content == null || this.file.content.length <= 2) {
			return;
		}
		if(this.file.content.b[0] == 239 && this.file.content.b[1] == 187 && this.file.content.b[2] == 191) {
			this.file.content = this.file.content.sub(3,this.file.content.length - 3);
		}
	}
	,makeTokenList: function() {
		this.tokenList = new formatter_codedata_TokenList();
		this.tokenList.buildList(this.root);
	}
	,makePosIndices: function() {
		var code = this.file.content;
		this.linesIdx = [];
		var last = 0;
		var left = false;
		var skip0A = false;
		var _g = 0;
		var _g1 = code.length;
		while(_g < _g1) {
			var i = _g++;
			var charCode = code.b[i];
			if(skip0A && charCode == 10) {
				skip0A = false;
				continue;
			}
			if(charCode == 10 || charCode == 13) {
				if(charCode == 13 && i + 1 < code.length && code.b[i + 1] == 10) {
					skip0A = true;
					this.linesIdx.push({ l : last, r : i + 1});
					last = i + 2;
				} else {
					this.linesIdx.push({ l : last, r : i});
					last = i + 1;
				}
			}
			left = true;
		}
		if(left) {
			this.linesIdx.push({ l : last, r : code.length});
		}
	}
	,getLinePos: function(off) {
		var lowerBound = 0;
		var upperBound = this.linesIdx.length - 1;
		if(this.linesIdx.length <= 0) {
			throw haxe_Exception.thrown("Bad offset");
		}
		if(off < 0) {
			throw haxe_Exception.thrown("Bad offset");
		}
		if(off > this.linesIdx[upperBound].r) {
			throw haxe_Exception.thrown("Bad offset");
		}
		while(true) {
			if(lowerBound > upperBound) {
				throw haxe_Exception.thrown("Bad offset");
			}
			var center = lowerBound + Math.floor((upperBound - lowerBound) / 2);
			var matchLeft = this.linesIdx[center].l <= off;
			var matchRight = this.linesIdx[center].r >= off;
			if(matchLeft && matchRight) {
				return { line : center, ofs : off - this.linesIdx[center].l};
			}
			if(matchLeft) {
				lowerBound = center + 1;
				continue;
			}
			if(matchRight) {
				upperBound = center - 1;
				continue;
			}
		}
	}
	,getString: function(off,off2) {
		var code = this.file.content;
		if(off >= code.length || off + (off2 - off) > code.length) {
			return "";
		}
		return code.sub(off,off2 - off).toString();
	}
	,isOriginalNewlineBefore: function(token) {
		if(token == null) {
			return false;
		}
		var prev = this.tokenList.getPreviousToken(token);
		if(prev == null) {
			return false;
		}
		return !this.isOriginalSameLine(prev.token,token);
	}
	,isOriginalSameLine: function(first,second) {
		return this.getLinePos(first.pos.max).line == this.getLinePos(second.pos.min).line;
	}
	,linesBetweenOriginal: function(first,second) {
		var startLine = this.getLinePos(first.pos.min).line;
		return this.getLinePos(second.pos.min).line - startLine;
	}
	,detectLineSeparator: function() {
		var code = this.file.content.toString();
		var _g = 0;
		var _g1 = code.length;
		while(_g < _g1) {
			var i = _g++;
			var char = code.charAt(i);
			if(char == "\r" || char == "\n") {
				this.lineSeparator = char;
				if(char == "\r" && i + 1 < code.length) {
					char = code.charAt(i + 1);
					if(char == "\n") {
						this.lineSeparator += char;
					}
				}
				return;
			}
		}
		this.lineSeparator = "\n";
	}
	,makeLines: function() {
		this.lines = this.file.content.toString().split(this.lineSeparator);
		this.emptyLines = [];
		var _g = 0;
		var _g1 = this.lines.length;
		while(_g < _g1) {
			var index = _g++;
			var line = this.lines[index];
			if(StringTools.startsWith(line,"<<<<<<<")) {
				throw haxe_Exception.thrown("not formatting \"" + this.file.name + "\" - file contains a merge conflict");
			}
			if(new EReg("^\\s*$","").match(line)) {
				this.emptyLines.push(index);
			}
		}
	}
	,makeTokens: function() {
		try {
			this.tokens = [];
			this.root = null;
			var lexer = new haxeparser_HaxeLexer(this.file.content,this.file.name);
			var t = lexer.token(haxeparser_HaxeLexer.tok);
			while(t.tok != haxeparser_TokenDef.Eof) {
				this.tokens.push(t);
				t = lexer.token(haxeparser_HaxeLexer.tok);
			}
		} catch( _g ) {
			haxe_NativeStackTrace.lastError = _g;
			var _g1 = haxe_Exception.caught(_g).unwrap();
			if(((_g1) instanceof hxparse_ParserError)) {
				var e = _g1;
				throw haxe_Exception.thrown("failed to make tokens - ParserError: " + Std.string(e) + " (" + Std.string(e.pos) + ")");
			} else if(((_g1) instanceof haxeparser_LexerError)) {
				var e = _g1;
				throw haxe_Exception.thrown("failed to make tokens - LexerError: " + Std.string(e.msg) + " (" + Std.string(e.pos) + ")");
			} else {
				throw haxe_Exception.thrown("failed to make tokens " + (_g1 == null ? "null" : Std.string(_g1)));
			}
		}
	}
	,__class__: formatter_codedata_ParsedCode
};
var formatter_codedata_TokenList = function() {
	this.tokens = [];
	this.leadingEmptyLInes = 0;
	this.closeTokenCache = new haxe_ds_IntMap();
};
formatter_codedata_TokenList.__name__ = true;
formatter_codedata_TokenList.prototype = {
	buildList: function(token) {
		if(token.children == null) {
			return;
		}
		var _g = 0;
		var _g1 = token.children;
		while(_g < _g1.length) {
			var child = _g1[_g];
			++_g;
			var index = child.index;
			if(index < 0 || child.inserted) {
				continue;
			}
			if(child.index >= this.tokens.length) {
				this.fill(child.index - this.tokens.length);
			}
			this.tokens[index] = { token : child, whitespaceAfter : formatter_codedata_WhitespaceAfterType.None, spacesBefore : 0, spacesAfter : 0, emptyLinesAfter : 0, wrapAfter : false, text : null, additionalIndent : 0};
			this.buildList(child);
		}
	}
	,fill: function(count) {
		while(count-- > 0) this.tokens.push(null);
	}
	,getCloseToken: function(token) {
		if(token == null || token.tok == tokentree_TokenTreeDef.Root) {
			return null;
		}
		if(token.index < 0 || token.index >= this.tokens.length) {
			return null;
		}
		if(this.closeTokenCache.h.hasOwnProperty(token.index)) {
			return this.closeTokenCache.h[token.index];
		}
		var result;
		switch(token.tok._hx_index) {
		case 15:
			result = tokentree_TokenTreeAccessHelper.firstOf(token,tokentree_TokenTreeDef.BkClose);
			break;
		case 17:
			result = tokentree_TokenTreeAccessHelper.firstOf(token,tokentree_TokenTreeDef.BrClose);
			break;
		case 19:
			result = tokentree_TokenTreeAccessHelper.firstOf(token,tokentree_TokenTreeDef.PClose);
			break;
		default:
			return null;
		}
		if(result == null) {
			return null;
		}
		this.closeTokenCache.h[token.index] = result;
		return result;
	}
	,getTokenAtOffset: function(off) {
		if(this.tokens.length <= 0) {
			throw haxe_Exception.thrown("Bad offset");
		}
		if(off < 0) {
			throw haxe_Exception.thrown("Bad offset");
		}
		if(off > this.tokens[this.tokens.length - 1].token.pos.max) {
			throw haxe_Exception.thrown("Bad offset");
		}
		var _g = 0;
		var _g1 = this.tokens;
		while(_g < _g1.length) {
			var token = _g1[_g];
			++_g;
			if(token == null) {
				continue;
			}
			if(token.token.pos.max >= off) {
				return token;
			}
		}
		throw haxe_Exception.thrown("Bad offset");
	}
	,getTokenAt: function(index) {
		if(index < 0 || index >= this.tokens.length) {
			return null;
		}
		return this.tokens[index];
	}
	,getPreviousToken: function(token) {
		if(token == null || token.index <= 0) {
			return null;
		}
		var prevToken = null;
		var prevIndex = token.index - 1;
		if(prevIndex >= this.tokens.length) {
			return null;
		}
		while(prevToken == null) {
			prevToken = this.tokens[prevIndex--];
			if(prevIndex < 0) {
				return null;
			}
		}
		return prevToken;
	}
	,getNextToken: function(token) {
		if(token == null || token.index <= 0) {
			return null;
		}
		var nextToken = null;
		var nextIndex = token.index + 1;
		if(nextIndex >= this.tokens.length) {
			return null;
		}
		while(nextToken == null) {
			nextToken = this.tokens[nextIndex++];
			if(nextIndex < 0) {
				return null;
			}
		}
		return nextToken;
	}
	,whitespace: function(token,where) {
		if(token.index < 0) {
			return;
		}
		var info = this.tokens[token.index];
		if(info == null) {
			return;
		}
		var prev = null;
		var prevIndex = token.index - 1;
		while(prev == null) {
			if(prevIndex < 0) {
				break;
			}
			prev = this.tokens[prevIndex--];
		}
		if(prev != null && this.needsLineBreak(prev.token)) {
			prev = null;
		}
		switch(where) {
		case "after":
			this.applyWhitespace(info,formatter_codedata_WhitespaceAfterType.Space);
			break;
		case "around":
			this.applyWhitespace(info,formatter_codedata_WhitespaceAfterType.Space);
			this.applyWhitespace(prev,formatter_codedata_WhitespaceAfterType.Space);
			break;
		case "before":
			this.applyWhitespace(prev,formatter_codedata_WhitespaceAfterType.Space);
			break;
		case "none":
			this.applyWhitespace(info,formatter_codedata_WhitespaceAfterType.None);
			this.applyWhitespace(prev,formatter_codedata_WhitespaceAfterType.None);
			break;
		case "noneAfter":
			this.applyWhitespace(info,formatter_codedata_WhitespaceAfterType.None);
			break;
		case "noneBefore":
			this.applyWhitespace(prev,formatter_codedata_WhitespaceAfterType.None);
			break;
		case "onlyAfter":
			this.applyWhitespace(prev,formatter_codedata_WhitespaceAfterType.None);
			this.applyWhitespace(info,formatter_codedata_WhitespaceAfterType.Space);
			break;
		case "onlyBefore":
			this.applyWhitespace(prev,formatter_codedata_WhitespaceAfterType.Space);
			this.applyWhitespace(info,formatter_codedata_WhitespaceAfterType.None);
			break;
		}
	}
	,applyWhitespace: function(info,policy) {
		if(info == null) {
			return;
		}
		switch(info.whitespaceAfter._hx_index) {
		case 0:
			info.whitespaceAfter = policy;
			switch(policy._hx_index) {
			case 0:
				info.spacesAfter = 0;
				break;
			case 1:
				this.shouldHaveOneSpaceAfter(info);
				break;
			case 2:
				break;
			}
			break;
		case 1:
			switch(policy._hx_index) {
			case 0:
				info.whitespaceAfter = formatter_codedata_WhitespaceAfterType.None;
				info.spacesAfter = 0;
				break;
			case 1:
				this.shouldHaveOneSpaceAfter(info);
				break;
			case 2:
				info.whitespaceAfter = policy;
				break;
			}
			break;
		case 2:
			switch(policy._hx_index) {
			case 0:
				if(info.spacesAfter > 0) {
					info.whitespaceAfter = formatter_codedata_WhitespaceAfterType.Space;
				} else {
					info.whitespaceAfter = formatter_codedata_WhitespaceAfterType.None;
					info.spacesAfter = 0;
				}
				break;
			case 1:
				info.whitespaceAfter = policy;
				this.shouldHaveOneSpaceAfter(info);
				break;
			case 2:
				break;
			}
			break;
		}
	}
	,shouldHaveOneSpaceAfter: function(info) {
		if(info == null) {
			return;
		}
		if(info.spacesAfter <= 0) {
			info.spacesAfter = 1;
		}
	}
	,spacesBefore: function(token,count) {
		if(token.index < 0) {
			return;
		}
		var info = this.tokens[token.index];
		if(info == null) {
			return;
		}
		info.spacesBefore = count;
	}
	,lineEndAfter: function(token) {
		if(token.index < 0) {
			return;
		}
		var info = this.tokens[token.index];
		if(info == null) {
			return;
		}
		switch(info.whitespaceAfter._hx_index) {
		case 0:
			info.whitespaceAfter = formatter_codedata_WhitespaceAfterType.Newline;
			break;
		case 1:
			info.whitespaceAfter = formatter_codedata_WhitespaceAfterType.Newline;
			break;
		case 2:
			break;
		}
	}
	,lineEndBefore: function(token) {
		var info = this.getPreviousToken(token);
		if(info == null) {
			return;
		}
		switch(info.whitespaceAfter._hx_index) {
		case 0:
			info.whitespaceAfter = formatter_codedata_WhitespaceAfterType.Newline;
			break;
		case 1:
			info.whitespaceAfter = formatter_codedata_WhitespaceAfterType.Newline;
			break;
		case 2:
			break;
		}
	}
	,needsLineBreak: function(token) {
		if(token == null) {
			return false;
		}
		if(token.tok._hx_index == 8) {
			return true;
		}
		return false;
	}
	,noLineEndAfter: function(token) {
		if(token.index < 0) {
			return;
		}
		var info = this.tokens[token.index];
		if(info == null) {
			return;
		}
		if(this.needsLineBreak(info.token)) {
			info.whitespaceAfter = formatter_codedata_WhitespaceAfterType.Newline;
			return;
		}
		switch(info.whitespaceAfter._hx_index) {
		case 0:
			return;
		case 1:
			break;
		case 2:
			if(info.spacesAfter <= 0) {
				info.whitespaceAfter = formatter_codedata_WhitespaceAfterType.None;
			} else {
				info.whitespaceAfter = formatter_codedata_WhitespaceAfterType.Space;
				this.shouldHaveOneSpaceAfter(info);
			}
			break;
		}
	}
	,noLineEndBefore: function(token) {
		var info = this.getPreviousToken(token);
		if(info == null) {
			return;
		}
		if(this.needsLineBreak(info.token)) {
			info.whitespaceAfter = formatter_codedata_WhitespaceAfterType.Newline;
			return;
		}
		switch(info.whitespaceAfter._hx_index) {
		case 0:
			return;
		case 1:
			break;
		case 2:
			if(info.spacesAfter <= 0) {
				info.whitespaceAfter = formatter_codedata_WhitespaceAfterType.None;
			} else {
				info.whitespaceAfter = formatter_codedata_WhitespaceAfterType.Space;
				this.shouldHaveOneSpaceAfter(info);
			}
			break;
		}
	}
	,emptyLinesAfter: function(token,count) {
		if(token.index < 0) {
			return;
		}
		var info = this.tokens[token.index];
		if(info == null) {
			return;
		}
		info.emptyLinesAfter = count;
	}
	,emptyLinesBefore: function(token,count) {
		if(token.index <= 0) {
			this.leadingEmptyLInes = count;
			return;
		}
		var info = this.getPreviousToken(token);
		if(info == null) {
			return;
		}
		info.emptyLinesAfter = count;
	}
	,emptyLinesAfterSubTree: function(token,count) {
		var lastToken = tokentree_utils_TokenTreeCheckUtils.getLastToken(token);
		if(lastToken == null) {
			return;
		}
		var info = this.tokens[lastToken.index];
		if(info == null) {
			return;
		}
		info.emptyLinesAfter = count;
	}
	,tokenText: function(token,text) {
		if(token.index < 0) {
			return;
		}
		var info = this.tokens[token.index];
		if(info == null) {
			return;
		}
		info.text = text;
	}
	,wrapAfter: function(token,wrap) {
		if(token.index < 0) {
			return;
		}
		var info = this.tokens[token.index];
		if(info == null) {
			return;
		}
		info.wrapAfter = wrap;
	}
	,wrapBefore: function(token,wrap) {
		var prev = this.getPreviousToken(token);
		if(prev == null) {
			return;
		}
		prev.wrapAfter = wrap;
	}
	,noWrappingBetween: function(tokenStart,tokenEnd,config,allowCommas) {
		if(allowCommas == null) {
			allowCommas = true;
		}
		if(tokenStart == null || tokenEnd == null) {
			return;
		}
		var index = tokenStart.index;
		while(index < tokenEnd.index) {
			var first = index == tokenStart.index;
			var info = this.tokens[index++];
			var next = this.tokens[index];
			if(info == null) {
				continue;
			}
			var _g = info.token.tok;
			switch(_g._hx_index) {
			case 1:
				switch(_g.k._hx_index) {
				case 0:case 40:
					var lastChild = tokentree_utils_TokenTreeCheckUtils.getLastToken(info.token);
					if(lastChild != null) {
						if(lastChild.index > index) {
							index = lastChild.index;
						}
						continue;
					}
					break;
				default:
				}
				break;
			case 7:
				continue;
			case 8:
				continue;
			case 13:
				var lastChild1 = tokentree_utils_TokenTreeCheckUtils.getLastToken(info.token);
				if(lastChild1 != null) {
					if(lastChild1.index > index) {
						index = lastChild1.index;
					}
					continue;
				}
				break;
			case 14:
				if(allowCommas) {
					continue;
				}
				break;
			case 15:
				if(!first) {
					var close = this.getCloseToken(info.token);
					if(close != null) {
						index = close.index;
						continue;
					}
				}
				break;
			case 17:
				if(!first) {
					var close1 = this.getCloseToken(info.token);
					if(close1 != null) {
						index = close1.index;
						continue;
					}
				}
				break;
			case 19:
				if(!first) {
					var close2 = this.getCloseToken(info.token);
					if(close2 != null) {
						index = close2.index;
						continue;
					}
				}
				break;
			default:
			}
			info.wrapAfter = false;
			if(next != null) {
				if(next.token.tok._hx_index == 17) {
					switch(config.lineEnds.leftCurly) {
					case "after":case "none":
						break;
					case "before":case "both":
						continue;
					}
				}
			}
			switch(info.whitespaceAfter._hx_index) {
			case 0:
				break;
			case 1:
				break;
			case 2:
				if(info.spacesAfter <= 0) {
					info.whitespaceAfter = formatter_codedata_WhitespaceAfterType.None;
				} else {
					info.whitespaceAfter = formatter_codedata_WhitespaceAfterType.Space;
					this.shouldHaveOneSpaceAfter(info);
				}
				break;
			}
		}
	}
	,additionalIndent: function(token,indent) {
		if(indent == null || token == null || token.index < 0) {
			return;
		}
		var info = this.tokens[token.index];
		if(info == null) {
			return;
		}
		info.additionalIndent = indent;
	}
	,increaseIndentBetween: function(start,end,depth) {
		if(depth == 0 || start == null || start.index < 0 || end == null || end.index < 0) {
			return;
		}
		var startIndex = start.index;
		if(depth > 0) {
			++startIndex;
		}
		var endIndex = end.index;
		var _g = startIndex;
		while(_g < endIndex) {
			var info = this.tokens[_g++];
			if(info == null) {
				continue;
			}
			info.additionalIndent += depth;
		}
	}
	,findTokenAtOffset: function(offset) {
		var lastInfo = null;
		var _g = 0;
		var _g1 = this.tokens;
		while(_g < _g1.length) {
			var info = _g1[_g];
			++_g;
			if(info == null) {
				continue;
			}
			if(info.token.pos.min >= offset) {
				return lastInfo;
			}
			lastInfo = info;
		}
		return lastInfo;
	}
	,isSameLine: function(first,second) {
		var startIndex = first.index;
		var endIndex = second.index;
		if(startIndex == endIndex) {
			return true;
		}
		if(startIndex < 0 || endIndex < 0) {
			return false;
		}
		if(startIndex > endIndex) {
			startIndex = second.index;
			endIndex = first.index;
		}
		while(startIndex < endIndex) {
			var currTok = this.tokens[startIndex++];
			if(currTok == null) {
				continue;
			}
			if(currTok.whitespaceAfter == formatter_codedata_WhitespaceAfterType.Newline) {
				return false;
			}
		}
		return true;
	}
	,findLowestIndex: function(start) {
		var lowest = start;
		if(!start.hasChildren()) {
			return start;
		}
		var _g = 0;
		var _g1 = start.children;
		while(_g < _g1.length) {
			var token = this.findLowestIndex(_g1[_g++]);
			if(token.index < lowest.index) {
				lowest = token;
			}
		}
		return lowest;
	}
	,calcLength: function(token) {
		if(token == null || token.index < 0) {
			return 0;
		}
		var current = this.tokens[token.index];
		if(current == null) {
			return 0;
		}
		var spaceAdd = 0;
		if(current.whitespaceAfter == formatter_codedata_WhitespaceAfterType.Space) {
			spaceAdd = 1;
		}
		if(current.text == null) {
			current.text = "" + Std.string(current.token);
		}
		var length = current.text.length + spaceAdd;
		if(token.children == null || token.children.length <= 0) {
			return length;
		}
		var _g = 0;
		var _g1 = token.children;
		while(_g < _g1.length) length += this.calcLength(_g1[_g++]);
		return length;
	}
	,isMultilineToken: function(token) {
		if(token == null || token.index < 0) {
			return false;
		}
		var current = this.tokens[token.index];
		if(current == null) {
			return false;
		}
		if(current.text.indexOf("\r") >= 0 || current.text.indexOf("\n") >= 0) {
			return true;
		}
		return false;
	}
	,calcLengthUntilNewline: function(token,stop) {
		if(token == null || token.index < 0) {
			return 0;
		}
		var endIndex = this.tokens.length - 1;
		if(stop != null) {
			endIndex = stop.index;
		}
		var index = token.index;
		var length = 0;
		while(index <= endIndex) {
			var current = this.tokens[index++];
			if(current == null) {
				continue;
			}
			if(current.text == null) {
				current.text = "" + Std.string(current.token);
			}
			if(current.text.indexOf("\r") >= 0) {
				length += current.text.indexOf("\r");
				break;
			}
			if(current.text.indexOf("\n") >= 0) {
				length += current.text.indexOf("\n");
				break;
			}
			length += current.spacesBefore;
			if(current.whitespaceAfter == formatter_codedata_WhitespaceAfterType.Space) {
				length += current.spacesAfter;
			}
			length += current.text.length;
			if(current.whitespaceAfter == formatter_codedata_WhitespaceAfterType.Newline) {
				break;
			}
		}
		return length;
	}
	,calcLengthBetween: function(tokenStart,tokenEnd) {
		if(tokenStart == null || tokenEnd == null) {
			return 0;
		}
		if(tokenStart.index < 0 || tokenEnd.index < 0) {
			return 0;
		}
		var length = 0;
		var _g = tokenStart.index;
		var _g1 = tokenEnd.index;
		while(_g < _g1) {
			var current = this.tokens[_g++];
			if(current == null) {
				continue;
			}
			if(current.text == null) {
				current.text = "" + Std.string(current.token);
			}
			length += current.text.length;
			if(current.whitespaceAfter == formatter_codedata_WhitespaceAfterType.Space) {
				++length;
			}
		}
		return length;
	}
	,calcLineLength: function(token) {
		if(token == null || token.index < 0) {
			return 0;
		}
		var start = token.index - 1;
		while(start >= 0) {
			var info = this.tokens[start--];
			if(info == null) {
				continue;
			}
			if(info.whitespaceAfter == formatter_codedata_WhitespaceAfterType.Newline) {
				start += 2;
				break;
			}
		}
		var length = 0;
		_hx_loop2: while(start < this.tokens.length) {
			var info = this.tokens[start++];
			if(info == null) {
				continue;
			}
			length += info.text.length;
			switch(info.whitespaceAfter._hx_index) {
			case 0:
				break;
			case 1:
				length += info.spacesAfter;
				break;
			case 2:
				break _hx_loop2;
			}
		}
		return length;
	}
	,calcLineLengthBefore: function(token) {
		if(token == null || token.index < 0) {
			return 0;
		}
		var start = token.index - 1;
		var length = 0;
		_hx_loop1: while(start >= 0) {
			var info = this.tokens[start--];
			if(info == null) {
				continue;
			}
			switch(info.whitespaceAfter._hx_index) {
			case 0:
				break;
			case 1:
				length += info.spacesAfter;
				break;
			case 2:
				break _hx_loop1;
			}
			length += info.text.length;
		}
		return length;
	}
	,calcLineLengthAfter: function(token) {
		if(token == null || token.index < 0) {
			return 0;
		}
		var start = token.index + 1;
		var length = 0;
		_hx_loop1: while(start < this.tokens.length) {
			var info = this.tokens[start++];
			if(info == null) {
				continue;
			}
			var tokenLength = info.text.length;
			var linefeed = info.text.lastIndexOf("\r");
			if(linefeed >= 0) {
				tokenLength -= linefeed;
			}
			linefeed = info.text.lastIndexOf("\n");
			if(linefeed >= 0) {
				tokenLength -= linefeed;
			}
			length += tokenLength;
			switch(info.whitespaceAfter._hx_index) {
			case 0:
				break;
			case 1:
				length += info.spacesAfter;
				break;
			case 2:
				break _hx_loop1;
			}
		}
		return length;
	}
	,calcTokenLength: function(token) {
		if(token == null || token.index < 0) {
			return 0;
		}
		var info = this.tokens[token.index];
		if(info == null) {
			return 0;
		}
		var length = info.text.length;
		switch(info.whitespaceAfter._hx_index) {
		case 0:
			break;
		case 1:
			length += info.spacesAfter;
			break;
		case 2:
			break;
		}
		return length;
	}
	,isNewLineBefore: function(token) {
		var info = this.getPreviousToken(token);
		if(info == null) {
			return false;
		}
		return info.whitespaceAfter == formatter_codedata_WhitespaceAfterType.Newline;
	}
	,isNewLineAfter: function(token) {
		var info = this.getTokenAt(token.index);
		if(info == null) {
			return false;
		}
		return info.whitespaceAfter == formatter_codedata_WhitespaceAfterType.Newline;
	}
	,isSameLineBetween: function(tokenStart,tokenEnd,exclude) {
		if(tokenStart == null || tokenEnd == null) {
			return true;
		}
		var start = tokenStart.index;
		var end = tokenEnd.index;
		if(exclude) {
			++start;
		}
		var _g = start;
		while(_g < end) {
			var info = this.tokens[_g++];
			if(info == null) {
				continue;
			}
			if(info.whitespaceAfter == formatter_codedata_WhitespaceAfterType.Newline) {
				return false;
			}
			if(info.text == null) {
				continue;
			}
			if(info.text.indexOf("\r") >= 0 || info.text.indexOf("\n") >= 0) {
				return false;
			}
		}
		return true;
	}
	,findLineStartToken: function(token) {
		if(token == null || token.index < 0) {
			return null;
		}
		var start = token.index - 1;
		while(true) {
			if(start < 0) {
				return this.tokens[0].token;
			}
			var info = this.tokens[start--];
			if(info == null) {
				continue;
			}
			switch(info.whitespaceAfter._hx_index) {
			case 0:
				break;
			case 1:
				break;
			case 2:
				return token;
			}
			token = info.token;
		}
	}
	,__class__: formatter_codedata_TokenList
};
var formatter_codedata_VerbatimCodeLine = function(content) {
	formatter_codedata_CodeLine.call(this,0);
	this.content = content;
	this.verbatim = true;
};
formatter_codedata_VerbatimCodeLine.__name__ = true;
formatter_codedata_VerbatimCodeLine.__super__ = formatter_codedata_CodeLine;
formatter_codedata_VerbatimCodeLine.prototype = $extend(formatter_codedata_CodeLine.prototype,{
	applyWrapping: function(config,parsedCode,indenter,lineSeparator) {
		return [this];
	}
	,print: function(indenter,lineSeparator) {
		return this.content;
	}
	,__class__: formatter_codedata_VerbatimCodeLine
});
var formatter_codedata_WhitespaceAfterType = $hxEnums["formatter.codedata.WhitespaceAfterType"] = { __ename__ : true, __constructs__ : ["None","Space","Newline"]
	,None: {_hx_index:0,__enum__:"formatter.codedata.WhitespaceAfterType",toString:$estr}
	,Space: {_hx_index:1,__enum__:"formatter.codedata.WhitespaceAfterType",toString:$estr}
	,Newline: {_hx_index:2,__enum__:"formatter.codedata.WhitespaceAfterType",toString:$estr}
};
var formatter_config_Config = function() {
	this.excludes = [];
	this.readConfigFromString("{}","hxformat.json");
};
formatter_config_Config.__name__ = true;
formatter_config_Config.prototype = {
	readConfig: function(fileName) {
		if(!sys_FileSystem.exists(fileName)) {
			return;
		}
		this.readConfigFromString(js_node_Fs.readFileSync(fileName,{ encoding : "utf8"}),fileName);
	}
	,readConfigFromString: function(jsonContent,fileName) {
		var data = new JsonParser_$1().fromJson(jsonContent,fileName);
		this.emptyLines = data.emptyLines;
		this.indentation = data.indentation;
		this.lineEnds = data.lineEnds;
		this.sameLine = data.sameLine;
		this.whitespace = data.whitespace;
		this.wrapping = data.wrapping;
		this.disableFormatting = data.disableFormatting;
		this.excludes = [];
		this.configFileName = fileName;
		var _g = 0;
		var _g1 = data.excludes;
		while(_g < _g1.length) this.excludes.push(new EReg(_g1[_g++],""));
	}
	,isExcluded: function(fileName) {
		var _g = 0;
		var _g1 = this.excludes;
		while(_g < _g1.length) if(_g1[_g++].match(fileName)) {
			return true;
		}
		return false;
	}
	,__class__: formatter_config_Config
};
var formatter_config_WhitespacePolicy = {};
formatter_config_WhitespacePolicy.remove = function(policy,removePolicy) {
	switch(removePolicy) {
	case "after":
		break;
	case "around":
		return "none";
	case "before":
		break;
	case "none":
		return policy;
	case "noneAfter":
		removePolicy = "after";
		break;
	case "noneBefore":
		removePolicy = "before";
		break;
	case "onlyAfter":
		removePolicy = "after";
		break;
	case "onlyBefore":
		removePolicy = "before";
		break;
	}
	switch(policy) {
	case "after":
		if(removePolicy == "after") {
			return "none";
		}
		break;
	case "around":
		if(removePolicy == "before") {
			return "after";
		}
		if(removePolicy == "after") {
			return "before";
		}
		break;
	case "before":
		if(removePolicy == "before") {
			return "none";
		}
		break;
	case "none":
		return "none";
	case "noneAfter":
		return "noneAfter";
	case "noneBefore":
		return "noneBefore";
	case "onlyAfter":
		if(removePolicy == "after") {
			return "none";
		}
		break;
	case "onlyBefore":
		if(removePolicy == "before") {
			return "none";
		}
		break;
	}
	return policy;
};
formatter_config_WhitespacePolicy.add = function(policy,addPolicy) {
	switch(addPolicy) {
	case "after":
		break;
	case "around":
		return "none";
	case "before":
		break;
	case "none":
		return policy;
	case "noneAfter":
		addPolicy = "after";
		break;
	case "noneBefore":
		addPolicy = "before";
		break;
	case "onlyAfter":
		addPolicy = "after";
		break;
	case "onlyBefore":
		addPolicy = "before";
		break;
	}
	switch(policy) {
	case "after":
		if(addPolicy == "before") {
			return "around";
		}
		break;
	case "around":
		break;
	case "before":
		if(addPolicy == "after") {
			return "around";
		}
		break;
	case "none":
		return addPolicy;
	case "noneAfter":
		if(addPolicy == "before") {
			return "onlyBefore";
		}
		if(addPolicy == "after") {
			return "onlyAfter";
		}
		break;
	case "noneBefore":
		if(addPolicy == "before") {
			return "onlyBefore";
		}
		if(addPolicy == "after") {
			return "onlyAfter";
		}
		break;
	case "onlyAfter":
		if(addPolicy == "before") {
			return "around";
		}
		break;
	case "onlyBefore":
		if(addPolicy == "after") {
			return "around";
		}
		break;
	}
	return policy;
};
var formatter_marker_Indenter = function(config) {
	this.config = config;
	if(config.character.toLowerCase() == "tab") {
		config.character = "\t";
	}
};
formatter_marker_Indenter.__name__ = true;
formatter_marker_Indenter.prototype = {
	setParsedCode: function(parsedCode) {
		this.parsedCode = parsedCode;
	}
	,makeIndentString: function(count) {
		return StringTools.lpad("",this.config.character,this.config.character.length * count);
	}
	,calcAbsoluteIndent: function(indent) {
		if(this.config.character == "\t") {
			return indent * this.config.tabWidth;
		}
		return indent * this.config.character.length;
	}
	,calcIndent: function(token) {
		if(token == null) {
			return 0;
		}
		if(token.tok._hx_index == 3) {
			if(this.config.conditionalPolicy == "fixedZero") {
				return 0;
			}
			if(this.config.conditionalPolicy == "fixedZeroIncrease") {
				return this.calcConditionalLevel(token);
			}
			if(this.config.conditionalPolicy == "fixedZeroIncreaseBlocks") {
				if(this.hasBlockParent(token)) {
					return this.calcConditionalLevel(token);
				}
				return 0;
			}
		}
		return this.calcFromCandidates(this.findEffectiveParent(token));
	}
	,calcConditionalLevel: function(token) {
		var count = -1;
		while(token != null && token.tok != tokentree_TokenTreeDef.Root) {
			var _g = token.tok;
			if(_g._hx_index == 3) {
				if(_g.s == "if") {
					++count;
				}
			}
			token = token.parent;
		}
		if(count <= 0) {
			return 0;
		}
		return count;
	}
	,calcConsecutiveConditionalLevel: function(token) {
		var count = -1;
		var maxCount = -1;
		while(token != null && token.tok != tokentree_TokenTreeDef.Root) {
			var _g = token.tok;
			if(_g._hx_index == 3) {
				if(_g.s == "if") {
					++count;
				}
			} else {
				if(count > maxCount) {
					maxCount = count;
				}
				count = -1;
			}
			token = token.parent;
		}
		if(count > maxCount) {
			maxCount = count;
		}
		if(maxCount <= 0) {
			return 0;
		}
		return maxCount;
	}
	,shouldAddTrailingWhitespace: function() {
		return this.config.trailingWhitespace;
	}
	,findEffectiveParent: function(token) {
		if(token.tok == tokentree_TokenTreeDef.Root) {
			return token.getFirstChild();
		}
		var _g = token.tok;
		switch(_g._hx_index) {
		case 1:
			switch(_g.k._hx_index) {
			case 0:
				var parent = token.parent;
				if(parent.tok == tokentree_TokenTreeDef.Root) {
					return token;
				}
				if(parent.tok._hx_index == 19) {
					if(this.parsedCode.tokenList.isNewLineBefore(token)) {
						return token;
					}
					return this.findEffectiveParent(token.parent);
				}
				break;
			case 3:
				var prev = this.parsedCode.tokenList.getPreviousToken(token);
				if(prev == null) {
					return token;
				}
				if(prev.whitespaceAfter == formatter_codedata_WhitespaceAfterType.Newline) {
					return token;
				}
				var this1 = tokentree_TokenTreeAccessHelper.firstOf(token,tokentree_TokenTreeDef.At);
				if(this1 != null) {
					if(!this.parsedCode.tokenList.isSameLineBetween(this1,token,false)) {
						return token;
					}
					prev = this.parsedCode.tokenList.getPreviousToken(this1);
					if(prev == null) {
						return token;
					}
					if(prev.whitespaceAfter == formatter_codedata_WhitespaceAfterType.Newline) {
						return token;
					}
				}
				var parent = token.parent;
				if(parent.tok == tokentree_TokenTreeDef.Root) {
					return token;
				}
				var _g1 = parent.tok;
				switch(_g1._hx_index) {
				case 1:
					if(_g1.k._hx_index != 4) {
						return token;
					}
					break;
				case 6:
					return token;
				default:
				}
				return this.findEffectiveParent(token.parent);
			case 5:
				var parent = token.parent;
				if(parent.tok == tokentree_TokenTreeDef.Root) {
					return token;
				}
				var tmp;
				if(parent != null) {
					var _g1 = parent.tok;
					tmp = _g1._hx_index == 1 && _g1.k._hx_index == 6;
				} else {
					tmp = false;
				}
				if(tmp) {
					return this.findEffectiveParent(token.parent);
				}
				break;
			case 4:case 21:
				return this.findEffectiveParent(token.parent);
			default:
			}
			break;
		case 3:
			switch(_g.s) {
			case "else":case "elseif":case "end":
				return this.findEffectiveParent(token.parent);
			default:
			}
			break;
		case 7:
			var next = this.parsedCode.tokenList.getNextToken(token);
			if(next == null) {
				return token;
			}
			var _g = next.token.tok;
			if(_g._hx_index == 1) {
				switch(_g.k._hx_index) {
				case 4:
					return this.findEffectiveParent(next.token);
				case 21:
					return this.findEffectiveParent(next.token);
				default:
					return token;
				}
			} else {
				return token;
			}
			break;
		case 8:
			var next = this.parsedCode.tokenList.getNextToken(token);
			if(next == null) {
				return token;
			}
			var _g = next.token.tok;
			if(_g._hx_index == 1) {
				switch(_g.k._hx_index) {
				case 4:
					return this.findEffectiveParent(next.token);
				case 21:
					return this.findEffectiveParent(next.token);
				default:
					return token;
				}
			} else {
				return token;
			}
			break;
		case 13:
			return this.findEffectiveParent(token.parent);
		case 17:
			var parent = token.parent;
			if(parent.tok == tokentree_TokenTreeDef.Root) {
				return token;
			}
			var firstToken = this.findEffectiveParentLineStart(token);
			if(firstToken != null) {
				return firstToken;
			}
			switch(tokentree_utils_TokenTreeCheckUtils.getBrOpenType(token)._hx_index) {
			case 0:
				break;
			case 1:
				return token.parent;
			case 2:
				return token;
			case 3:
				return token;
			case 4:
				break;
			}
			var _g = parent.tok;
			switch(_g._hx_index) {
			case 1:
				switch(_g.k._hx_index) {
				case 0:
					if(this.parsedCode.tokenList.isNewLineBefore(parent)) {
						return parent;
					}
					return this.findEffectiveParent(parent);
				case 3:case 4:
					return this.findEffectiveParent(parent);
				case 5:case 6:case 7:
					return this.findEffectiveParent(parent);
				case 14:
					return this.findEffectiveParent(parent);
				case 20:case 21:
					return this.findEffectiveParent(parent);
				case 22:
					var _g1 = parent.parent.tok;
					if(_g1._hx_index == 1 && _g1.k._hx_index == 0) {
						return this.findEffectiveParent(parent.parent);
					}
					break;
				case 28:
					return this.findEffectiveParent(parent);
				default:
				}
				break;
			case 2:
				if(_g.c._hx_index == 3) {
					var _g1 = parent.parent.tok;
					if(_g1._hx_index == 1 && _g1.k._hx_index == 0) {
						return this.findEffectiveParent(parent.parent);
					}
				}
				break;
			case 6:
				switch(_g.op._hx_index) {
				case 4:
					var access = tokentree_TokenTreeAccessHelper.matches(tokentree_TokenTreeAccessHelper.parent(tokentree_TokenTreeAccessHelper.parent(parent)),tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdTypedef));
					if(access != null) {
						return access;
					}
					break;
				case 20:
					var access = tokentree_TokenTreeAccessHelper.matches(tokentree_TokenTreeAccessHelper.parent(tokentree_TokenTreeAccessHelper.parent(parent)),tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdTypedef));
					if(access != null) {
						return access;
					}
					break;
				default:
				}
				break;
			default:
			}
			break;
		case 16:case 18:
			return this.findEffectiveParent(token.parent);
		case 19:
			var firstToken = this.findEffectiveParentLineStart(token);
			if(firstToken != null) {
				return firstToken;
			}
			break;
		case 20:
			return this.findEffectiveParent(token.parent);
		default:
		}
		return token;
	}
	,findEffectiveParentLineStart: function(token) {
		var firstToken = this.parsedCode.tokenList.findLineStartToken(token);
		if(firstToken == null) {
			return null;
		}
		if(firstToken.index == token.index) {
			return null;
		}
		switch(firstToken.tok._hx_index) {
		case 16:case 18:
			var next = this.parsedCode.tokenList.getNextToken(firstToken);
			if(next != null) {
				switch(next.token.tok._hx_index) {
				case 6:
					return this.findEffectiveParent(firstToken);
				case 11:case 14:case 16:case 18:case 20:
					return this.findEffectiveParent(firstToken);
				default:
				}
			}
			break;
		case 20:
			var next = this.parsedCode.tokenList.getNextToken(firstToken);
			if(next != null) {
				switch(next.token.tok._hx_index) {
				case 6:
					return this.findEffectiveParent(firstToken);
				case 11:
					return this.findEffectiveParent(firstToken);
				default:
				}
			}
			break;
		default:
		}
		return null;
	}
	,countLineBreaks: function(indentingTokensCandidates,indentComplexValueExpressions) {
		var count = 0;
		var prevToken = null;
		var currentToken = null;
		var mustIndent;
		var lastIndentingToken = null;
		var skipToToken = null;
		var _g = 0;
		while(_g < indentingTokensCandidates.length) {
			var token = indentingTokensCandidates[_g];
			++_g;
			prevToken = currentToken;
			if(prevToken == null) {
				prevToken = token;
			}
			currentToken = token;
			if(skipToToken != null) {
				if(token.index >= skipToToken.index) {
					continue;
				}
				prevToken = skipToToken;
				skipToToken = null;
			}
			if(prevToken.index == token.index) {
				continue;
			}
			switch(token.tok._hx_index) {
			case 15:case 17:
				var close = this.parsedCode.tokenList.getCloseToken(token);
				if(close != null && close.index >= 0 && close.index < prevToken.index) {
					currentToken = prevToken;
					continue;
				}
				break;
			default:
			}
			mustIndent = false;
			var _g1 = prevToken.tok;
			switch(_g1._hx_index) {
			case 1:
				switch(_g1.k._hx_index) {
				case 0:
					if(token.tok._hx_index == 19) {
						if(this.parsedCode.tokenList.isSameLineBetween(token,prevToken,false)) {
							continue;
						}
						if(!this.parsedCode.tokenList.isNewLineBefore(prevToken)) {
							var firstToken = this.parsedCode.tokenList.getPreviousToken(prevToken);
							while(firstToken != null && !this.parsedCode.tokenList.isNewLineBefore(firstToken.token)) firstToken = this.parsedCode.tokenList.getPreviousToken(firstToken.token);
							var this1 = tokentree_TokenTreeAccessHelper.firstOf(prevToken,tokentree_TokenTreeDef.BrOpen);
							if(this1 != null) {
								if(!this.parsedCode.tokenList.isSameLineBetween(prevToken,this1,false)) {
									continue;
								}
							}
							return count + this.calcIndent(firstToken.token);
						}
					}
					break;
				case 3:
					var _g2 = token.tok;
					if(_g2._hx_index == 6) {
						if(_g2.op._hx_index == 4) {
							if(indentComplexValueExpressions) {
								mustIndent = true;
							}
						} else if(this.parsedCode.tokenList.isSameLineBetween(token,prevToken,false)) {
							var this2 = tokentree_TokenTreeAccessHelper.firstOf(prevToken,tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdElse));
							if(this2 != null) {
								if(this.parsedCode.tokenList.isSameLineBetween(prevToken,this2,false)) {
									continue;
								}
								if(indentComplexValueExpressions) {
									mustIndent = true;
								}
							}
							var this3 = tokentree_TokenTreeAccessHelper.firstOf(prevToken,tokentree_TokenTreeDef.BrOpen);
							if(this3 != null) {
								if(tokentree_utils_TokenTreeCheckUtils.getBrOpenType(this3)._hx_index == 0) {
									continue;
								}
							}
						}
					} else if(this.parsedCode.tokenList.isSameLineBetween(token,prevToken,false)) {
						var this4 = tokentree_TokenTreeAccessHelper.firstOf(prevToken,tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdElse));
						if(this4 != null) {
							if(this.parsedCode.tokenList.isSameLineBetween(prevToken,this4,false)) {
								continue;
							}
							if(indentComplexValueExpressions) {
								mustIndent = true;
							}
						}
						var this5 = tokentree_TokenTreeAccessHelper.firstOf(prevToken,tokentree_TokenTreeDef.BrOpen);
						if(this5 != null) {
							if(tokentree_utils_TokenTreeCheckUtils.getBrOpenType(this5)._hx_index == 0) {
								continue;
							}
						}
					}
					break;
				case 4:
					continue;
				case 14:
					switch(token.tok._hx_index) {
					case 6:
						if(indentComplexValueExpressions) {
							mustIndent = true;
						}
						break;
					case 19:
						switch(tokentree_utils_TokenTreeCheckUtils.getPOpenType(token)._hx_index) {
						case 0:
							break;
						case 1:
							mustIndent = true;
							break;
						case 2:
							break;
						case 3:
							mustIndent = true;
							break;
						case 4:
							mustIndent = true;
							break;
						case 5:
							mustIndent = true;
							break;
						case 6:
							mustIndent = true;
							break;
						case 7:
							mustIndent = true;
							break;
						case 8:
							break;
						case 9:
							break;
						}
						break;
					default:
					}
					break;
				case 15:case 16:
					if(!this.config.indentCaseLabels) {
						continue;
					}
					break;
				case 21:
					var _g3 = token.tok;
					if(_g3._hx_index == 1 && _g3.k._hx_index == 20) {
						continue;
					}
					break;
				default:
				}
				break;
			case 2:
				var _g4 = _g1.c;
				if(_g4._hx_index == 3) {
					switch(_g4.s) {
					case "from":case "to":
						if(this.isAbstractFromTo(token) && this.parsedCode.tokenList.isNewLineBefore(prevToken)) {
							mustIndent = true;
						}
						break;
					default:
					}
				}
				break;
			case 11:
				var _g5 = token.tok;
				switch(_g5._hx_index) {
				case 1:
					switch(_g5.k._hx_index) {
					case 15:case 16:
						continue;
					case 10:case 22:case 28:
						if(!this.parsedCode.tokenList.isNewLineBefore(prevToken)) {
							continue;
						}
						break;
					default:
						if(this.parsedCode.tokenList.isNewLineBefore(prevToken)) {
							++count;
							continue;
						}
					}
					break;
				case 6:
					switch(_g5.op._hx_index) {
					case 4:
						if(this.parsedCode.tokenList.isSameLineBetween(token,prevToken,false)) {
							continue;
						}
						if(!this.parsedCode.tokenList.isNewLineBefore(prevToken)) {
							var firstToken1 = this.parsedCode.tokenList.getPreviousToken(prevToken);
							while(firstToken1 != null && !this.parsedCode.tokenList.isNewLineBefore(firstToken1.token)) firstToken1 = this.parsedCode.tokenList.getPreviousToken(firstToken1.token);
							return count + this.calcIndent(firstToken1.token);
						}
						break;
					case 20:
						if(this.parsedCode.tokenList.isSameLineBetween(token,prevToken,false)) {
							continue;
						}
						if(!this.parsedCode.tokenList.isNewLineBefore(prevToken)) {
							var firstToken2 = this.parsedCode.tokenList.getPreviousToken(prevToken);
							while(firstToken2 != null && !this.parsedCode.tokenList.isNewLineBefore(firstToken2.token)) firstToken2 = this.parsedCode.tokenList.getPreviousToken(firstToken2.token);
							return count + this.calcIndent(firstToken2.token);
						}
						break;
					default:
						if(this.parsedCode.tokenList.isNewLineBefore(prevToken)) {
							++count;
							continue;
						}
					}
					break;
				case 11:
					if(!(prevToken.pos.min == token.pos.min && this.parsedCode.tokenList.isNewLineBefore(token))) {
						continue;
					}
					break;
				case 15:case 17:case 19:
					if(this.parsedCode.tokenList.isSameLine(token,prevToken)) {
						continue;
					}
					mustIndent = true;
					break;
				default:
					if(this.parsedCode.tokenList.isNewLineBefore(prevToken)) {
						++count;
						continue;
					}
				}
				break;
			case 12:
				var _g6 = token.tok;
				if(_g6._hx_index == 1) {
					switch(_g6.k._hx_index) {
					case 15:case 16:
						if(lastIndentingToken != null && lastIndentingToken.pos.min == prevToken.pos.min) {
							continue;
						}
						mustIndent = true;
						break;
					default:
					}
				}
				break;
			case 13:case 15:
				if(token.tok._hx_index == 19) {
					if(this.parsedCode.tokenList.isSameLineBetween(token,prevToken,false)) {
						continue;
					}
					if(!this.parsedCode.tokenList.isNewLineBefore(prevToken)) {
						var firstToken3 = this.parsedCode.tokenList.getPreviousToken(prevToken);
						while(firstToken3 != null && !this.parsedCode.tokenList.isNewLineBefore(firstToken3.token)) firstToken3 = this.parsedCode.tokenList.getPreviousToken(firstToken3.token);
						var this6 = tokentree_TokenTreeAccessHelper.firstOf(prevToken,tokentree_TokenTreeDef.BrOpen);
						if(this6 != null) {
							if(!this.parsedCode.tokenList.isSameLineBetween(prevToken,this6,false)) {
								continue;
							}
						}
						return count + this.calcIndent(firstToken3.token);
					}
				}
				break;
			case 17:
				var _g7 = token.tok;
				switch(_g7._hx_index) {
				case 1:
					switch(_g7.k._hx_index) {
					case 0:case 3:case 4:case 5:case 6:case 7:case 10:case 14:case 20:case 21:case 28:case 39:
						if(tokentree_utils_TokenTreeCheckUtils.getBrOpenType(prevToken)._hx_index == 2) {
							var brClose = this.parsedCode.tokenList.getCloseToken(prevToken);
							if(brClose != null && !this.parsedCode.tokenList.isSameLine(prevToken,brClose) && !this.config.indentObjectLiteral) {
								continue;
							}
						} else {
							continue;
						}
						break;
					default:
					}
					break;
				case 6:
					switch(_g7.op._hx_index) {
					case 4:
						switch(tokentree_utils_TokenTreeCheckUtils.getBrOpenType(prevToken)._hx_index) {
						case 1:
							continue;
						case 2:
							var brClose1 = this.parsedCode.tokenList.getCloseToken(prevToken);
							if(brClose1 != null && !this.parsedCode.tokenList.isSameLine(prevToken,brClose1) && !this.config.indentObjectLiteral) {
								continue;
							}
							break;
						default:
						}
						break;
					case 20:
						switch(tokentree_utils_TokenTreeCheckUtils.getBrOpenType(prevToken)._hx_index) {
						case 1:
							continue;
						case 2:
							var brClose2 = this.parsedCode.tokenList.getCloseToken(prevToken);
							if(brClose2 != null && !this.parsedCode.tokenList.isSameLine(prevToken,brClose2) && !this.config.indentObjectLiteral) {
								continue;
							}
							break;
						default:
						}
						break;
					default:
					}
					break;
				case 12:
					switch(tokentree_utils_TokenTreeCheckUtils.getBrOpenType(prevToken)._hx_index) {
					case 1:
						continue;
					case 2:
						var brClose3 = this.parsedCode.tokenList.getCloseToken(prevToken);
						if(brClose3 != null && !this.parsedCode.tokenList.isSameLine(prevToken,brClose3) && !this.config.indentObjectLiteral) {
							continue;
						}
						break;
					default:
					}
					break;
				case 13:
					if(tokentree_utils_TokenTreeCheckUtils.getBrOpenType(prevToken)._hx_index == 2) {
						var brClose4 = this.parsedCode.tokenList.getCloseToken(prevToken);
						if(brClose4 != null && !this.parsedCode.tokenList.isSameLine(prevToken,brClose4) && !this.config.indentObjectLiteral) {
							continue;
						}
					} else {
						continue;
					}
					break;
				case 15:case 19:
					this.parsedCode.tokenList.isNewLineBefore(prevToken);
					break;
				default:
				}
				break;
			default:
			}
			if(!mustIndent && this.parsedCode.tokenList.isSameLineBetween(token,prevToken,false)) {
				continue;
			}
			skipToToken = this.findSkippingToken(token);
			if(!this.isIndentingToken(token,prevToken)) {
				continue;
			}
			lastIndentingToken = token;
			++count;
		}
		return count;
	}
	,findSkippingToken: function(token) {
		var firstToken = this.parsedCode.tokenList.findLineStartToken(token);
		if(firstToken == null) {
			return null;
		}
		if(firstToken.index == token.index) {
			return null;
		}
		var skipToToken = null;
		switch(firstToken.tok._hx_index) {
		case 16:case 18:case 20:
			skipToToken = this.findSkippingToken(firstToken.parent);
			if(skipToToken == null) {
				skipToToken = firstToken.parent;
			}
			return skipToToken;
		default:
			return null;
		}
	}
	,isFieldLevelVar: function(indentingTokensCandidates) {
		var tokens = indentingTokensCandidates.slice();
		tokens.reverse();
		var _g = 0;
		while(_g < tokens.length) {
			var _g1 = tokens[_g++].tok;
			switch(_g1._hx_index) {
			case 1:
				switch(_g1.k._hx_index) {
				case 0:
					return false;
				case 2:
					return true;
				case 41:
					break;
				default:
				}
				break;
			case 6:
				if(_g1.op._hx_index == 4) {
					return true;
				}
				break;
			default:
			}
		}
		return false;
	}
	,calcFromCandidates: function(token) {
		var indentingTokensCandidates = this.findIndentingCandidates(token);
		if(indentingTokensCandidates.length <= 0) {
			return 0;
		}
		var indentComplexValueExpressions = this.config.indentComplexValueExpressions;
		if(this.isFieldLevelVar(indentingTokensCandidates)) {
			indentComplexValueExpressions = true;
		}
		if(indentComplexValueExpressions) {
			indentingTokensCandidates = this.compressElseIfCandidates(indentingTokensCandidates);
		}
		var count = this.countLineBreaks(indentingTokensCandidates,indentComplexValueExpressions);
		if(this.hasConditional(indentingTokensCandidates)) {
			switch(this.config.conditionalPolicy) {
			case "aligned":
				break;
			case "alignedDecrease":
				--count;
				break;
			case "alignedIncrease":
				break;
			case "alignedNestedIncrease":
				count += this.calcConsecutiveConditionalLevel(token);
				break;
			case "fixedZero":
				break;
			case "fixedZeroIncrease":
				--count;
				if(this.calcConditionalLevel(token) == count) {
					++count;
				}
				break;
			case "fixedZeroIncreaseBlocks":
				if(this.hasBlock(indentingTokensCandidates)) {
					--count;
					if(this.calcConditionalLevel(token) == count) {
						++count;
					}
				}
				break;
			}
		}
		return count;
	}
	,hasConditional: function(tokens) {
		var _g = 0;
		while(_g < tokens.length) {
			var _g1 = tokens[_g++].tok;
			if(_g1._hx_index == 3) {
				if(_g1.s == "if") {
					return true;
				}
			}
		}
		return false;
	}
	,hasBlock: function(tokens) {
		var _g = 0;
		while(_g < tokens.length) if(tokens[_g++].tok._hx_index == 17) {
			return true;
		}
		return false;
	}
	,hasBlockParent: function(token) {
		var parent = token.parent;
		while(parent != null && parent.tok != tokentree_TokenTreeDef.Root) if(parent.tok._hx_index == 17) {
			return true;
		} else {
			parent = parent.parent;
		}
		return false;
	}
	,findIndentingCandidates: function(token) {
		var indentingTokensCandidates = [];
		var lastIndentingToken = null;
		if(token.tok._hx_index == 11) {
			lastIndentingToken = token;
		}
		indentingTokensCandidates.push(token);
		var parent = token;
		while(parent.parent != null && parent.parent.tok != tokentree_TokenTreeDef.Root) {
			parent = parent.parent;
			if(parent.pos.min > token.pos.min) {
				continue;
			}
			if(this.isIndentingToken(parent,parent)) {
				if(lastIndentingToken != null) {
					if(lastIndentingToken.tok._hx_index == 11 && parent.tok._hx_index == 11) {
						continue;
					}
				}
				indentingTokensCandidates.push(parent);
				lastIndentingToken = parent;
			} else if(this.parsedCode.tokenList.isNewLineBefore(parent)) {
				indentingTokensCandidates.push(parent);
				lastIndentingToken = parent;
			}
		}
		return indentingTokensCandidates;
	}
	,compressElseIfCandidates: function(indentingTokensCandidates) {
		var compressedCandidates = [];
		var state = formatter_marker_IndentationCompressElseIf.Copy;
		var _g = 0;
		while(_g < indentingTokensCandidates.length) {
			var token = indentingTokensCandidates[_g];
			++_g;
			var _g1 = token.tok;
			if(_g1._hx_index == 1) {
				switch(_g1.k._hx_index) {
				case 3:
					switch(state._hx_index) {
					case 0:
						if(tokentree_TokenTreeAccessHelper.firstOf(token,tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdElse)) != null) {
							state = formatter_marker_IndentationCompressElseIf.SkipElseIf;
						}
						break;
					case 1:
						state = formatter_marker_IndentationCompressElseIf.SkipElseIf;
						break;
					case 2:
						continue;
					}
					break;
				case 4:
					if(state == formatter_marker_IndentationCompressElseIf.SeenElse || state == formatter_marker_IndentationCompressElseIf.SkipElseIf) {
						state = formatter_marker_IndentationCompressElseIf.SkipElseIf;
						continue;
					}
					state = formatter_marker_IndentationCompressElseIf.SeenElse;
					break;
				default:
					state = formatter_marker_IndentationCompressElseIf.Copy;
				}
			} else {
				state = formatter_marker_IndentationCompressElseIf.Copy;
			}
			compressedCandidates.push(token);
		}
		return compressedCandidates;
	}
	,isIndentingToken: function(token,prevToken) {
		if(token == null) {
			return false;
		}
		var _g = token.tok;
		switch(_g._hx_index) {
		case 1:
			switch(_g.k._hx_index) {
			case 0:
				return true;
			case 2:
				return true;
			case 3:case 4:
				return true;
			case 5:
				var parent = token.parent;
				var tmp;
				if(parent != null) {
					var _g1 = parent.tok;
					tmp = _g1._hx_index == 1 && _g1.k._hx_index == 6;
				} else {
					tmp = false;
				}
				if(tmp) {
					return false;
				}
				return true;
			case 6:case 7:
				return true;
			case 10:case 28:
				return true;
			case 14:case 15:case 16:
				return true;
			case 20:case 21:case 24:
				return true;
			case 22:
				var _g1 = token.parent.tok;
				if(_g1._hx_index == 1) {
					if(_g1.k._hx_index == 0) {
						return false;
					} else {
						return true;
					}
				} else {
					return true;
				}
				break;
			case 39:
				return true;
			default:
			}
			break;
		case 2:
			var _g1 = _g.c;
			if(_g1._hx_index == 3) {
				switch(_g1.s) {
				case "from":case "to":
					return this.isAbstractFromTo(token);
				default:
					if(prevToken.tok._hx_index == 11) {
						return true;
					}
				}
			}
			break;
		case 3:
			if(_g.s == "if") {
				switch(this.config.conditionalPolicy) {
				case "aligned":
					return false;
				case "alignedDecrease":case "alignedIncrease":
					return true;
				case "alignedNestedIncrease":
					return false;
				case "fixedZero":
					return false;
				case "fixedZeroIncrease":
					return true;
				case "fixedZeroIncreaseBlocks":
					return this.hasBlockParent(token);
				}
			}
			break;
		case 6:
			switch(_g.op._hx_index) {
			case 4:
				return true;
			case 9:
				return tokentree_utils_TokenTreeCheckUtils.isTypeParameter(token);
			case 20:
				return true;
			default:
			}
			break;
		case 12:
			var tmp;
			var _g = token.parent.tok;
			if(!(_g._hx_index == 1 && _g.k._hx_index == 15)) {
				var _g = token.parent.tok;
				tmp = _g._hx_index == 1 && _g.k._hx_index == 16;
			} else {
				tmp = true;
			}
			if(tmp) {
				return true;
			}
			var info = this.parsedCode.tokenList.getTokenAt(token.index);
			if(info == null) {
				return false;
			}
			switch(info.whitespaceAfter._hx_index) {
			case 0:case 1:
				return false;
			case 2:
				return true;
			}
			break;
		case 13:
			return true;
		case 11:case 15:case 17:case 19:
			return true;
		default:
		}
		return false;
	}
	,isAbstractFromTo: function(token) {
		var parent = token.parent;
		if(parent == null) {
			return false;
		}
		var _g = parent.tok;
		if(_g._hx_index == 2) {
			if(_g.c._hx_index != 3) {
				return false;
			}
		} else {
			return false;
		}
		parent = parent.parent;
		if(parent == null) {
			return false;
		}
		var _g = parent.tok;
		if(_g._hx_index == 1) {
			if(_g.k._hx_index == 39) {
				return true;
			} else {
				return false;
			}
		} else {
			return false;
		}
	}
	,__class__: formatter_marker_Indenter
};
var formatter_marker_IndentationCompressElseIf = $hxEnums["formatter.marker.IndentationCompressElseIf"] = { __ename__ : true, __constructs__ : ["Copy","SeenElse","SkipElseIf"]
	,Copy: {_hx_index:0,__enum__:"formatter.marker.IndentationCompressElseIf",toString:$estr}
	,SeenElse: {_hx_index:1,__enum__:"formatter.marker.IndentationCompressElseIf",toString:$estr}
	,SkipElseIf: {_hx_index:2,__enum__:"formatter.marker.IndentationCompressElseIf",toString:$estr}
};
var formatter_marker_MarkerBase = function(config,parsedCode,indenter) {
	this.config = config;
	this.parsedCode = parsedCode;
	this.indenter = indenter;
};
formatter_marker_MarkerBase.__name__ = true;
formatter_marker_MarkerBase.prototype = {
	getCloseToken: function(token) {
		return this.parsedCode.tokenList.getCloseToken(token);
	}
	,getNextToken: function(token) {
		return this.parsedCode.tokenList.getNextToken(token);
	}
	,getPreviousToken: function(token) {
		return this.parsedCode.tokenList.getPreviousToken(token);
	}
	,getTokenAt: function(index) {
		return this.parsedCode.tokenList.getTokenAt(index);
	}
	,whitespace: function(token,where) {
		this.parsedCode.tokenList.whitespace(token,where);
	}
	,spacesBefore: function(token,count) {
		this.parsedCode.tokenList.spacesBefore(token,count);
	}
	,lineEndAfter: function(token) {
		this.parsedCode.tokenList.lineEndAfter(token);
	}
	,lineEndBefore: function(token) {
		this.parsedCode.tokenList.lineEndBefore(token);
	}
	,noLineEndAfter: function(token) {
		this.parsedCode.tokenList.noLineEndAfter(token);
	}
	,noLineEndBefore: function(token) {
		this.parsedCode.tokenList.noLineEndBefore(token);
	}
	,emptyLinesAfter: function(token,count) {
		this.parsedCode.tokenList.emptyLinesAfter(token,count);
	}
	,emptyLinesBefore: function(token,count) {
		this.parsedCode.tokenList.emptyLinesBefore(token,count);
	}
	,emptyLinesAfterSubTree: function(token,count) {
		this.parsedCode.tokenList.emptyLinesAfterSubTree(token,count);
	}
	,tokenText: function(token,text) {
		this.parsedCode.tokenList.tokenText(token,text);
	}
	,wrapAfter: function(token,wrap) {
		this.parsedCode.tokenList.wrapAfter(token,wrap);
	}
	,wrapBefore: function(token,wrap) {
		this.parsedCode.tokenList.wrapBefore(token,wrap);
	}
	,noWrappingBetween: function(tokenStart,tokenEnd,allowCommas) {
		if(allowCommas == null) {
			allowCommas = true;
		}
		this.parsedCode.tokenList.noWrappingBetween(tokenStart,tokenEnd,this.config,allowCommas);
	}
	,additionalIndent: function(token,indent) {
		this.parsedCode.tokenList.additionalIndent(token,indent);
	}
	,increaseIndentBetween: function(start,end,depth) {
		this.parsedCode.tokenList.increaseIndentBetween(start,end,depth);
	}
	,findTokenAtOffset: function(offset) {
		return this.parsedCode.tokenList.findTokenAtOffset(offset);
	}
	,isSameLine: function(first,second) {
		return this.parsedCode.tokenList.isSameLine(first,second);
	}
	,calcLength: function(token) {
		return this.parsedCode.tokenList.calcLength(token);
	}
	,isMultilineToken: function(token) {
		return this.parsedCode.tokenList.isMultilineToken(token);
	}
	,calcLengthUntilNewline: function(token,stop) {
		return this.parsedCode.tokenList.calcLengthUntilNewline(token,stop);
	}
	,calcLengthBetween: function(tokenStart,tokenEnd) {
		return this.parsedCode.tokenList.calcLengthBetween(tokenStart,tokenEnd);
	}
	,calcLineLength: function(token) {
		return this.parsedCode.tokenList.calcLineLength(token);
	}
	,calcLineLengthBefore: function(token) {
		return this.parsedCode.tokenList.calcLineLengthBefore(token);
	}
	,calcLineLengthAfter: function(token) {
		return this.parsedCode.tokenList.calcLineLengthAfter(token);
	}
	,calcTokenLength: function(token) {
		return this.parsedCode.tokenList.calcTokenLength(token);
	}
	,isNewLineBefore: function(token) {
		return this.parsedCode.tokenList.isNewLineBefore(token);
	}
	,isNewLineAfter: function(token) {
		return this.parsedCode.tokenList.isNewLineAfter(token);
	}
	,isSameLineBetween: function(tokenStart,tokenEnd,exclude) {
		return this.parsedCode.tokenList.isSameLineBetween(tokenStart,tokenEnd,exclude);
	}
	,findLineStartToken: function(token) {
		return this.parsedCode.tokenList.findLineStartToken(token);
	}
	,__class__: formatter_marker_MarkerBase
};
var formatter_marker_MarkAdditionalIndentation = function(config,parsedCode,indenter) {
	formatter_marker_MarkerBase.call(this,config,parsedCode,indenter);
};
formatter_marker_MarkAdditionalIndentation.__name__ = true;
formatter_marker_MarkAdditionalIndentation.__super__ = formatter_marker_MarkerBase;
formatter_marker_MarkAdditionalIndentation.prototype = $extend(formatter_marker_MarkerBase.prototype,{
	run: function() {
		var _gthis = this;
		this.parsedCode.root.filterCallback(function(token,index) {
			var _g = token.tok;
			if(_g._hx_index == 3) {
				if(_g.s == "if") {
					_gthis.markBlockBreakingConditional(token,_gthis.calcDepthDifferenceLeftCurly(token));
					_gthis.markBlockBreakingConditional(token,_gthis.calcDepthDifferenceRightCurly(token));
				}
			}
			return tokentree_FilterResult.GoDeeper;
		});
	}
	,markBlockBreakingConditional: function(token,depthDifference) {
		if(token.children == null) {
			return;
		}
		var this1 = tokentree_TokenTreeAccessHelper.firstOf(token,tokentree_TokenTreeDef.Sharp("end"));
		var start = this1;
		if(this1 == null) {
			return;
		}
		if(depthDifference == 0) {
			return;
		}
		if(depthDifference < 0) {
			start = token;
		}
		var parent = token.parent;
		var topLevelToken = null;
		while(parent != null && parent.tok != tokentree_TokenTreeDef.Root) {
			topLevelToken = parent;
			parent = parent.parent;
		}
		if(topLevelToken == null) {
			return;
		}
		var sibling = topLevelToken.nextSibling;
		while(sibling != null) if(sibling.tok._hx_index == 18) {
			this.increaseIndentBetween(start,sibling,depthDifference);
			return;
		} else {
			sibling = sibling.nextSibling;
		}
		this.increaseIndentBetween(start,tokentree_utils_TokenTreeCheckUtils.getLastToken(topLevelToken),depthDifference);
	}
	,calcDepthDifferenceLeftCurly: function(token) {
		if(token.children == null) {
			return 0;
		}
		var depthIncrease = 0;
		var _g = 0;
		var _g1 = token.children;
		while(_g < _g1.length) {
			var brOpens = _g1[_g++].filterCallback(function(token,index) {
				switch(token.tok._hx_index) {
				case 3:
					return tokentree_FilterResult.SkipSubtree;
				case 17:
					return tokentree_FilterResult.FoundGoDeeper;
				default:
					return tokentree_FilterResult.GoDeeper;
				}
			});
			if(brOpens.length <= 0) {
				continue;
			}
			var depth = 0;
			var _g2 = 0;
			while(_g2 < brOpens.length) {
				if(tokentree_TokenTreeAccessHelper.firstOf(brOpens[_g2++],tokentree_TokenTreeDef.BrClose) != null) {
					continue;
				}
				++depth;
			}
			if(depth > depthIncrease) {
				depthIncrease = depth;
			}
		}
		return depthIncrease;
	}
	,calcDepthDifferenceRightCurly: function(token) {
		if(token.children == null) {
			return 0;
		}
		var depthDecrease = 0;
		var _g = 0;
		var _g1 = token.children;
		while(_g < _g1.length) {
			var brClose = _g1[_g++].filterCallback(function(token,index) {
				if(token.tok._hx_index == 18) {
					return tokentree_FilterResult.FoundGoDeeper;
				} else {
					return tokentree_FilterResult.GoDeeper;
				}
			});
			if(brClose.length <= 0) {
				continue;
			}
			var depth = 0;
			var _g2 = 0;
			while(_g2 < brClose.length) {
				if(tokentree_TokenTreeAccessHelper.matches(tokentree_TokenTreeAccessHelper.parent(brClose[_g2++]),tokentree_TokenTreeDef.BrOpen) != null) {
					continue;
				}
				++depth;
			}
			if(depth > depthDecrease) {
				depthDecrease = depth;
			}
		}
		return -depthDecrease;
	}
	,__class__: formatter_marker_MarkAdditionalIndentation
});
var formatter_marker_MarkEmptyLines = function(config,parsedCode,indenter) {
	formatter_marker_MarkerBase.call(this,config,parsedCode,indenter);
};
formatter_marker_MarkEmptyLines.__name__ = true;
formatter_marker_MarkEmptyLines.__super__ = formatter_marker_MarkerBase;
formatter_marker_MarkEmptyLines.prototype = $extend(formatter_marker_MarkerBase.prototype,{
	run: function() {
		this.keepExistingEmptyLines();
		var packs = this.parsedCode.root.filterCallback(function(token,index) {
			var _g = token.tok;
			if(_g._hx_index == 1) {
				if(_g.k._hx_index == 33) {
					return tokentree_FilterResult.FoundSkipSubtree;
				} else {
					return tokentree_FilterResult.SkipSubtree;
				}
			} else {
				return tokentree_FilterResult.GoDeeper;
			}
		});
		packs.reverse();
		var _g = 0;
		while(_g < packs.length) {
			var pack = packs[_g];
			++_g;
			if(tokentree_utils_TokenTreeCheckUtils.isMetadata(pack)) {
				continue;
			}
			this.emptyLinesBefore(pack,this.config.emptyLines.beforePackage);
			this.emptyLinesAfter(pack,this.config.emptyLines.afterPackage);
		}
		this.betweenTypes();
		this.markImports();
		this.markClassesAndAbstracts();
		this.markMacroClasses();
		this.markInterfaces();
		this.markEnums();
		this.markTypedefs();
		this.markSharp();
		if(this.config.emptyLines.beforeDocCommentEmptyLines != "ignore" || this.config.emptyLines.afterFieldsWithDocComments != "ignore") {
			this.markDocComments();
		}
		this.markMultilineComments();
		this.markFileHeader();
		if(this.config.emptyLines.beforeRightCurly == "remove") {
			this.markRightCurly();
		}
		if(this.config.emptyLines.afterLeftCurly == "remove") {
			this.markLeftCurly();
		}
		if(this.config.emptyLines.afterReturn == "remove") {
			this.markReturn();
		}
		if(this.config.emptyLines.beforeBlocks == "remove" || this.config.emptyLines.afterBlocks == "remove") {
			this.markAroundBlocks();
		}
	}
	,finalRun: function(codeLines) {
		if(codeLines.lines.length <= 0) {
			return;
		}
		var _g = 0;
		var _g1 = codeLines.lines;
		while(_g < _g1.length) {
			var line = _g1[_g];
			++_g;
			if(line.verbatim) {
				continue;
			}
			if(line.emptyLinesAfter > this.config.emptyLines.maxAnywhereInFile) {
				line.emptyLinesAfter = this.config.emptyLines.maxAnywhereInFile;
			}
		}
		var lastLine = codeLines.lines[codeLines.lines.length - 1];
		if(lastLine.verbatim) {
			return;
		}
		lastLine.emptyLinesAfter = this.config.emptyLines.finalNewline ? 1 : 0;
	}
	,markImports: function() {
		var imports = this.parsedCode.root.filterCallback(function(token,index) {
			var _g = token.tok;
			if(_g._hx_index == 1) {
				switch(_g.k._hx_index) {
				case 13:case 35:
					if(tokentree_utils_TokenTreeCheckUtils.isMetadata(token)) {
						return tokentree_FilterResult.SkipSubtree;
					} else {
						return tokentree_FilterResult.FoundSkipSubtree;
					}
					break;
				default:
					return tokentree_FilterResult.GoDeeper;
				}
			} else {
				return tokentree_FilterResult.GoDeeper;
			}
		});
		if(imports.length <= 0) {
			return;
		}
		var lastImport = imports[imports.length - 1];
		var afterImport = this.getNextToken(tokentree_utils_TokenTreeCheckUtils.getLastToken(lastImport));
		if(afterImport != null) {
			var _g = afterImport.token.tok;
			if(_g._hx_index == 3) {
				switch(_g.s) {
				case "else":case "elseif":
					break;
				case "end":
					this.emptyLinesAfterSubTree(afterImport.token,this.config.emptyLines.importAndUsing.beforeType);
					break;
				default:
					this.emptyLinesAfterSubTree(lastImport,this.config.emptyLines.importAndUsing.beforeType);
				}
			} else {
				this.emptyLinesAfterSubTree(lastImport,this.config.emptyLines.importAndUsing.beforeType);
			}
		}
		lastImport = null;
		var prevInfo = null;
		var _g = 0;
		while(_g < imports.length) {
			var token = imports[_g];
			++_g;
			var newInfo = this.getImportInfo(token);
			var next = this.getNextToken(tokentree_utils_TokenTreeCheckUtils.getLastToken(token));
			if(next != null) {
				var _g1 = next.token.tok;
				if(_g1._hx_index == 3) {
					if(_g1.s == "end") {
						newInfo.token = next.token;
					}
				}
			}
			if(prevInfo == null) {
				prevInfo = newInfo;
				continue;
			}
			if(prevInfo.isImport == newInfo.isImport) {
				switch(this.config.emptyLines.importAndUsing.betweenImportsLevel) {
				case "all":
					this.emptyLinesAfterSubTree(prevInfo.token,this.config.emptyLines.importAndUsing.betweenImports);
					break;
				case "fifthLevelPackage":
					if(prevInfo.fifthLevelPackage != newInfo.fifthLevelPackage) {
						this.emptyLinesAfterSubTree(prevInfo.token,this.config.emptyLines.importAndUsing.betweenImports);
					}
					break;
				case "firstLevelPackage":
					if(prevInfo.firstLevelPackage != newInfo.firstLevelPackage) {
						this.emptyLinesAfterSubTree(prevInfo.token,this.config.emptyLines.importAndUsing.betweenImports);
					}
					break;
				case "fourthLevelPackage":
					if(prevInfo.fourthLevelPackage != newInfo.fourthLevelPackage) {
						this.emptyLinesAfterSubTree(prevInfo.token,this.config.emptyLines.importAndUsing.betweenImports);
					}
					break;
				case "fullPackage":
					if(prevInfo.fullPackage != newInfo.fullPackage) {
						this.emptyLinesAfterSubTree(prevInfo.token,this.config.emptyLines.importAndUsing.betweenImports);
					}
					break;
				case "secondLevelPackage":
					if(prevInfo.secondLevelPackage != newInfo.secondLevelPackage) {
						this.emptyLinesAfterSubTree(prevInfo.token,this.config.emptyLines.importAndUsing.betweenImports);
					}
					break;
				case "thirdLevelPackage":
					if(prevInfo.thirdLevelPackage != newInfo.thirdLevelPackage) {
						this.emptyLinesAfterSubTree(prevInfo.token,this.config.emptyLines.importAndUsing.betweenImports);
					}
					break;
				}
			} else {
				this.emptyLinesAfterSubTree(prevInfo.token,this.config.emptyLines.importAndUsing.beforeUsing);
			}
			prevInfo = newInfo;
		}
	}
	,getImportInfo: function(token) {
		var info = { token : token, isImport : false, firstLevelPackage : "", secondLevelPackage : "", thirdLevelPackage : "", fourthLevelPackage : "", fifthLevelPackage : "", fullPackage : "", moduleName : ""};
		var _g = token.tok;
		if(_g._hx_index == 1) {
			switch(_g.k._hx_index) {
			case 13:
				info.isImport = true;
				break;
			case 35:
				info.isImport = false;
				break;
			default:
			}
		}
		var parts = [];
		token = token.getFirstChild();
		while(true) {
			var _g = token.tok;
			switch(_g._hx_index) {
			case 1:
				parts.push("" + Std.string(token));
				break;
			case 2:
				var _g1 = _g.c;
				if(_g1._hx_index == 3) {
					parts.push(_g1.s);
				}
				break;
			default:
			}
			token = token.getFirstChild();
			if(token == null || token.tok._hx_index != 11) {
				break;
			}
			token = token.getFirstChild();
			if(token == null) {
				break;
			}
		}
		info.moduleName = parts.pop();
		info.fullPackage = parts.join(".");
		if(parts.length > 0) {
			info.firstLevelPackage = parts[0];
		}
		if(parts.length > 1) {
			info.secondLevelPackage = parts.slice(0,2).join(".");
		} else {
			info.secondLevelPackage = info.firstLevelPackage;
		}
		if(parts.length > 2) {
			info.thirdLevelPackage = parts.slice(0,3).join(".");
		} else {
			info.thirdLevelPackage = info.secondLevelPackage;
		}
		if(parts.length > 3) {
			info.fourthLevelPackage = parts.slice(0,4).join(".");
		} else {
			info.fourthLevelPackage = info.thirdLevelPackage;
		}
		if(parts.length > 4) {
			info.fifthLevelPackage = parts.slice(0,5).join(".");
		} else {
			info.fifthLevelPackage = info.fourthLevelPackage;
		}
		return info;
	}
	,markClassesAndAbstracts: function() {
		var classes = this.parsedCode.root.filterCallback(function(token,index) {
			var _g = token.tok;
			if(_g._hx_index == 1) {
				switch(_g.k._hx_index) {
				case 1:case 39:
					return tokentree_FilterResult.FoundSkipSubtree;
				default:
					return tokentree_FilterResult.GoDeeper;
				}
			} else {
				return tokentree_FilterResult.GoDeeper;
			}
		});
		var _g = 0;
		while(_g < classes.length) {
			var c = classes[_g];
			++_g;
			if(tokentree_utils_TokenTreeCheckUtils.isTypeEnumAbstract(c)) {
				this.markEnumAbstracts(c);
				continue;
			}
			var typeConfig = null;
			var _g1 = c.tok;
			if(_g1._hx_index == 1) {
				switch(_g1.k._hx_index) {
				case 1:
					typeConfig = this.config.emptyLines.classEmptyLines;
					if(tokentree_TokenTreeAccessHelper.firstOf(tokentree_TokenTreeAccessHelper.firstChild(c),tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdExtern)) != null) {
						this.markExternClass(c,this.config.emptyLines.externClassEmptyLines);
						continue;
					}
					break;
				case 39:
					typeConfig = this.config.emptyLines.abstractEmptyLines;
					break;
				default:
					continue;
				}
			} else {
				continue;
			}
			this.markBeginAndEndType(tokentree_TokenTreeAccessHelper.firstOf(tokentree_TokenTreeAccessHelper.firstChild(c),tokentree_TokenTreeDef.BrOpen),typeConfig.beginType,typeConfig.endType);
			var fields = this.findClassAndAbstractFields(c);
			var prevToken = null;
			var prevTokenType = null;
			var currTokenType = null;
			var _g2 = 0;
			while(_g2 < fields.length) {
				var field = fields[_g2];
				++_g2;
				currTokenType = tokentree_utils_FieldUtils.getFieldType(field,tokentree_utils_TokenFieldVisibility.Private);
				this.markClassFieldEmptyLines(prevToken,prevTokenType,field,currTokenType,typeConfig);
				prevToken = field;
				prevTokenType = currTokenType;
			}
		}
	}
	,markMacroClasses: function() {
		var classes = this.parsedCode.root.filterCallback(function(token,index) {
			var _g = token.tok;
			if(_g._hx_index == 1) {
				if(_g.k._hx_index == 1) {
					if(token.parent == null || token.parent.tok == tokentree_TokenTreeDef.Root) {
						return tokentree_FilterResult.GoDeeper;
					}
					var _g = token.parent.tok;
					if(_g._hx_index == 1) {
						if(_g.k._hx_index == 40) {
							return tokentree_FilterResult.FoundSkipSubtree;
						} else {
							return tokentree_FilterResult.GoDeeper;
						}
					} else {
						return tokentree_FilterResult.GoDeeper;
					}
				} else {
					return tokentree_FilterResult.GoDeeper;
				}
			} else {
				return tokentree_FilterResult.GoDeeper;
			}
		});
		var _g = 0;
		while(_g < classes.length) {
			var c = classes[_g];
			++_g;
			var typeConfig = this.config.emptyLines.macroClassEmptyLines;
			this.markBeginAndEndType(tokentree_TokenTreeAccessHelper.firstOf(tokentree_TokenTreeAccessHelper.firstChild(c),tokentree_TokenTreeDef.BrOpen),typeConfig.beginType,typeConfig.endType);
			var functions = this.findClassAndAbstractFields(c);
			var prevToken = null;
			var prevTokenType = null;
			var currTokenType = null;
			var _g1 = 0;
			while(_g1 < functions.length) {
				var func = functions[_g1];
				++_g1;
				currTokenType = tokentree_utils_FieldUtils.getFieldType(func,tokentree_utils_TokenFieldVisibility.Private);
				this.markClassFieldEmptyLines(prevToken,prevTokenType,func,currTokenType,typeConfig);
				prevToken = func;
				prevTokenType = currTokenType;
			}
		}
	}
	,findClassAndAbstractFields: function(c) {
		return c.filterCallback(function(token,index) {
			var _g = token.tok;
			switch(_g._hx_index) {
			case 1:
				switch(_g.k._hx_index) {
				case 0:case 2:
					return tokentree_FilterResult.FoundSkipSubtree;
				case 41:
					return tokentree_FilterResult.FoundSkipSubtree;
				default:
					return tokentree_FilterResult.GoDeeper;
				}
				break;
			case 22:
				return tokentree_FilterResult.SkipSubtree;
			default:
				return tokentree_FilterResult.GoDeeper;
			}
		});
	}
	,markBeginAndEndType: function(brOpen,beginType,endType) {
		if(brOpen == null) {
			return;
		}
		this.emptyLinesAfter(brOpen,beginType);
		var brClose = this.getCloseToken(brOpen);
		if(brClose == null) {
			return;
		}
		this.emptyLinesBefore(brClose,endType);
	}
	,markClassFieldEmptyLines: function(prevToken,prevTokenType,currToken,currTokenType,conf) {
		if(prevToken == null) {
			return;
		}
		var prevVar = false;
		var currVar = false;
		var prevStatic = false;
		var currStatic = false;
		var prevPrivate = false;
		var currPrivate = false;
		switch(prevTokenType._hx_index) {
		case 0:
			prevVar = false;
			prevStatic = prevTokenType.isStatic;
			prevPrivate = prevTokenType.visibility == tokentree_utils_TokenFieldVisibility.Private;
			break;
		case 1:
			prevVar = true;
			prevStatic = prevTokenType.isStatic;
			prevPrivate = prevTokenType.visibility == tokentree_utils_TokenFieldVisibility.Private;
			break;
		case 2:
			prevVar = true;
			prevStatic = prevTokenType.isStatic;
			prevPrivate = prevTokenType.visibility == tokentree_utils_TokenFieldVisibility.Private;
			break;
		case 3:
			return;
		}
		switch(currTokenType._hx_index) {
		case 0:
			currVar = false;
			currStatic = currTokenType.isStatic;
			currPrivate = currTokenType.visibility == tokentree_utils_TokenFieldVisibility.Private;
			break;
		case 1:
			currVar = true;
			currStatic = currTokenType.isStatic;
			currPrivate = currTokenType.visibility == tokentree_utils_TokenFieldVisibility.Private;
			break;
		case 2:
			currVar = true;
			currStatic = currTokenType.isStatic;
			currPrivate = currTokenType.visibility == tokentree_utils_TokenFieldVisibility.Private;
			break;
		case 3:
			return;
		}
		if(!currVar) {
			this.markLineCommentsBefore(currToken,this.config.emptyLines.lineCommentsBetweenFunctions);
			this.markLineCommentsAfter(currToken,1);
		}
		prevToken = this.skipSharpFields(prevToken);
		if(prevToken == null) {
			return;
		}
		if(conf.existingBetweenFields == "keep") {
			if(this.hasEmptyLinesBetweenFields(prevToken,currToken)) {
				this.emptyLinesAfterSubTree(prevToken,1);
				return;
			}
		}
		if(prevVar != currVar) {
			this.emptyLinesAfterSubTree(prevToken,conf.afterVars);
			return;
		}
		if(prevVar) {
			if(prevStatic != currStatic) {
				this.emptyLinesAfterSubTree(prevToken,conf.afterStaticVars);
				return;
			}
			if(prevStatic) {
				this.emptyLinesAfterSubTree(prevToken,conf.betweenStaticVars);
				return;
			}
			if(prevPrivate != currPrivate) {
				this.emptyLinesAfterSubTree(prevToken,conf.afterPrivateVars);
				return;
			}
			this.emptyLinesAfterSubTree(prevToken,conf.betweenVars);
			return;
		} else {
			if(prevStatic != currStatic) {
				this.emptyLinesAfterSubTree(prevToken,conf.afterStaticFunctions);
				return;
			}
			if(prevStatic) {
				this.emptyLinesAfterSubTree(prevToken,conf.betweenStaticFunctions);
				return;
			}
			if(prevPrivate != currPrivate) {
				this.emptyLinesAfterSubTree(prevToken,conf.afterPrivateFunctions);
				return;
			}
			this.emptyLinesAfterSubTree(prevToken,conf.betweenFunctions);
			return;
		}
	}
	,hasEmptyLinesBetweenFields: function(prevToken,currToken) {
		var lastToken = tokentree_utils_TokenTreeCheckUtils.getLastToken(prevToken);
		if(lastToken == null) {
			return false;
		}
		var prevLine = this.parsedCode.getLinePos(lastToken.pos.max).line;
		var currLine = this.parsedCode.getLinePos(currToken.pos.min).line;
		var _g = 0;
		var _g1 = this.parsedCode.emptyLines;
		while(_g < _g1.length) {
			var emptyLine = _g1[_g];
			++_g;
			if(prevLine >= emptyLine) {
				continue;
			}
			if(currLine > emptyLine) {
				return true;
			}
			return false;
		}
		return false;
	}
	,markLineCommentsBefore: function(token,policy) {
		if(policy == "none") {
			return;
		}
		if(token.previousSibling == null) {
			return;
		}
		var prev = token.previousSibling;
		while(prev != null) {
			switch(prev.tok._hx_index) {
			case 7:
				break;
			case 8:
				var prevInfo = this.getPreviousToken(prev);
				if(prevInfo == null || prevInfo.whitespaceAfter == formatter_codedata_WhitespaceAfterType.Newline) {
					switch(policy) {
					case "keep":
						if(this.parsedCode.linesBetweenOriginal(prev,token) > 1) {
							this.emptyLinesAfter(prev,1);
						}
						break;
					case "none":
						break;
					case "one":
						this.emptyLinesAfter(prev,1);
						break;
					}
				}
				return;
			default:
				return;
			}
			prev = prev.previousSibling;
		}
	}
	,markLineCommentsAfter: function(token,count) {
		if(count <= 0) {
			return;
		}
		if(token.nextSibling == null) {
			return;
		}
		var next = token.nextSibling;
		if(next.tok._hx_index == 8) {
			if(this.isNewLineBefore(next)) {
				this.emptyLinesBefore(next,count);
			}
		}
	}
	,markExternClass: function(c,conf) {
		var this1 = tokentree_TokenTreeAccessHelper.firstOf(tokentree_TokenTreeAccessHelper.firstChild(c),tokentree_TokenTreeDef.BrOpen);
		if(this1 == null) {
			return;
		}
		this.markBeginAndEndType(this1,conf.beginType,conf.endType);
		var fields = this.findClassAndAbstractFields(this1);
		var prevToken = null;
		var prevTokenType = null;
		var currTokenType = null;
		var _g = 0;
		while(_g < fields.length) {
			var field = fields[_g];
			++_g;
			currTokenType = tokentree_utils_FieldUtils.getFieldType(field,tokentree_utils_TokenFieldVisibility.Public);
			this.markInterfaceEmptyLines(prevToken,prevTokenType,field,currTokenType,conf);
			prevToken = field;
			prevTokenType = currTokenType;
		}
	}
	,markInterfaces: function() {
		var interfaces = this.parsedCode.root.filterCallback(function(token,index) {
			var _g = token.tok;
			if(_g._hx_index == 1) {
				if(_g.k._hx_index == 27) {
					return tokentree_FilterResult.FoundSkipSubtree;
				} else {
					return tokentree_FilterResult.SkipSubtree;
				}
			} else {
				return tokentree_FilterResult.GoDeeper;
			}
		});
		var _g = 0;
		while(_g < interfaces.length) this.markExternClass(interfaces[_g++],this.config.emptyLines.interfaceEmptyLines);
	}
	,markInterfaceEmptyLines: function(prevToken,prevTokenType,currToken,currTokenType,conf) {
		if(prevToken == null) {
			return;
		}
		var prevVar = false;
		var currVar = false;
		switch(prevTokenType._hx_index) {
		case 0:
			prevVar = false;
			break;
		case 1:
			prevVar = true;
			break;
		case 2:
			prevVar = true;
			break;
		case 3:
			return;
		}
		switch(currTokenType._hx_index) {
		case 0:
			currVar = false;
			break;
		case 1:
			currVar = true;
			break;
		case 2:
			currVar = true;
			break;
		case 3:
			return;
		}
		prevToken = this.skipSharpFields(prevToken);
		if(prevToken == null) {
			return;
		}
		if(conf.existingBetweenFields == "keep") {
			if(this.hasEmptyLinesBetweenFields(prevToken,currToken)) {
				this.emptyLinesAfterSubTree(prevToken,1);
				return;
			}
		}
		if(prevVar != currVar) {
			this.emptyLinesAfterSubTree(prevToken,conf.afterVars);
			return;
		}
		if(prevVar) {
			this.emptyLinesAfterSubTree(prevToken,conf.betweenVars);
			return;
		} else {
			this.emptyLinesAfterSubTree(prevToken,conf.betweenFunctions);
			return;
		}
	}
	,markEnumAbstracts: function(token) {
		this.markBeginAndEndType(tokentree_TokenTreeAccessHelper.firstOf(tokentree_TokenTreeAccessHelper.firstChild(token),tokentree_TokenTreeDef.BrOpen),this.config.emptyLines.enumAbstractEmptyLines.beginType,this.config.emptyLines.enumAbstractEmptyLines.endType);
		var functions = this.findClassAndAbstractFields(token);
		var prevToken = null;
		var prevTokenType = null;
		var currTokenType = null;
		var _g = 0;
		while(_g < functions.length) {
			var func = functions[_g];
			++_g;
			currTokenType = tokentree_utils_FieldUtils.getFieldType(func,tokentree_utils_TokenFieldVisibility.Public);
			this.markEnumAbstractFieldEmptyLines(prevToken,prevTokenType,func,currTokenType);
			prevToken = func;
			prevTokenType = currTokenType;
		}
	}
	,markEnumAbstractFieldEmptyLines: function(prevToken,prevTokenType,currToken,currTokenType) {
		if(prevToken == null) {
			return;
		}
		var prevVar = false;
		var currVar = false;
		switch(prevTokenType._hx_index) {
		case 0:
			prevVar = false;
			break;
		case 1:
			prevVar = true;
			break;
		case 2:
			prevVar = true;
			break;
		case 3:
			return;
		}
		switch(currTokenType._hx_index) {
		case 0:
			currVar = false;
			break;
		case 1:
			currVar = true;
			break;
		case 2:
			currVar = true;
			break;
		case 3:
			return;
		}
		prevToken = this.skipSharpFields(prevToken);
		if(prevToken == null) {
			return;
		}
		if(prevVar != currVar) {
			this.emptyLinesAfterSubTree(prevToken,this.config.emptyLines.enumAbstractEmptyLines.afterVars);
			return;
		}
		if(prevVar) {
			this.emptyLinesAfterSubTree(prevToken,this.config.emptyLines.enumAbstractEmptyLines.betweenVars);
			return;
		} else {
			this.emptyLinesAfterSubTree(prevToken,this.config.emptyLines.enumAbstractEmptyLines.betweenFunctions);
			return;
		}
	}
	,markEnums: function() {
		var enums = this.parsedCode.root.filterCallback(function(token,index) {
			var _g = token.tok;
			if(_g._hx_index == 1) {
				if(_g.k._hx_index == 26) {
					return tokentree_FilterResult.FoundSkipSubtree;
				} else {
					return tokentree_FilterResult.SkipSubtree;
				}
			} else {
				return tokentree_FilterResult.GoDeeper;
			}
		});
		var _g = 0;
		while(_g < enums.length) {
			var e = enums[_g];
			++_g;
			if(e.parent.tok != tokentree_TokenTreeDef.Root) {
				switch(e.parent.tok._hx_index) {
				case 2:
					continue;
				case 12:case 22:
					continue;
				default:
				}
			}
			var this1 = tokentree_TokenTreeAccessHelper.firstOf(tokentree_TokenTreeAccessHelper.firstChild(e),tokentree_TokenTreeDef.BrOpen);
			if(this1 == null) {
				continue;
			}
			this.markEnumFields(this1,this.config.emptyLines.enumEmptyLines);
		}
	}
	,markEnumFields: function(block,config) {
		this.markBeginAndEndType(block,config.beginType,config.endType);
		if(block.children == null || block.children.length <= 0) {
			return;
		}
		var prevToken = null;
		var _g = 0;
		var _g1 = block.children;
		while(_g < _g1.length) {
			var child = _g1[_g];
			++_g;
			switch(child.tok._hx_index) {
			case 7:
				continue;
			case 8:
				continue;
			case 18:
				return;
			default:
			}
			if(prevToken == null) {
				prevToken = child;
				continue;
			}
			if(config.existingBetweenFields == "keep") {
				if(this.hasEmptyLinesBetweenFields(prevToken,child)) {
					this.emptyLinesAfterSubTree(prevToken,1);
					return;
				}
			}
			this.emptyLinesAfterSubTree(prevToken,config.betweenFields);
			prevToken = child;
		}
	}
	,markTypedefs: function() {
		var typedefs = this.parsedCode.root.filterCallback(function(token,index) {
			var _g = token.tok;
			if(_g._hx_index == 1) {
				if(_g.k._hx_index == 31) {
					return tokentree_FilterResult.FoundSkipSubtree;
				} else {
					return tokentree_FilterResult.SkipSubtree;
				}
			} else {
				return tokentree_FilterResult.GoDeeper;
			}
		});
		var _g = 0;
		while(_g < typedefs.length) {
			var this1 = tokentree_TokenTreeAccessHelper.firstOf(tokentree_TokenTreeAccessHelper.firstOf(tokentree_TokenTreeAccessHelper.firstChild(typedefs[_g++]),tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpAssign)),tokentree_TokenTreeDef.BrOpen);
			if(this1 == null) {
				continue;
			}
			this.markEnumFields(this1,this.config.emptyLines.typedefEmptyLines);
		}
	}
	,skipSharpFields: function(prevToken) {
		var next = prevToken.nextSibling;
		if(next == null) {
			next = prevToken.parent;
			if(next.tok._hx_index == 3) {
				next = next.nextSibling;
			} else {
				return prevToken;
			}
		}
		var _g = next.tok;
		if(_g._hx_index == 3) {
			switch(_g.s) {
			case "end":
				return next;
			case "if":
				return prevToken;
			default:
				return null;
			}
		}
		return prevToken;
	}
	,betweenTypes: function() {
		if(this.config.emptyLines.betweenTypes <= 0 && this.config.emptyLines.betweenSingleLineTypes <= 0) {
			return;
		}
		var types = this.parsedCode.root.filterCallback(function(token,index) {
			var _g = token.tok;
			if(_g._hx_index == 1) {
				switch(_g.k._hx_index) {
				case 0:case 2:
					return tokentree_FilterResult.FoundSkipSubtree;
				case 1:case 26:case 27:case 31:case 39:
					return tokentree_FilterResult.FoundSkipSubtree;
				case 41:
					return tokentree_FilterResult.FoundSkipSubtree;
				default:
					return tokentree_FilterResult.GoDeeper;
				}
			} else {
				return tokentree_FilterResult.GoDeeper;
			}
		});
		if(types.length <= 1) {
			return;
		}
		var prevTypeInfo = null;
		var _g = 0;
		while(_g < types.length) {
			var type = types[_g];
			++_g;
			var newTypeInfo = this.getTypeInfo(type);
			this.markLineCommentsBefore(type,this.config.emptyLines.lineCommentsBetweenTypes);
			this.markLineCommentsAfter(type,1);
			if(prevTypeInfo == null) {
				prevTypeInfo = newTypeInfo;
				continue;
			}
			var next = this.getNextToken(prevTypeInfo.lastToken);
			if(next != null) {
				var _g1 = next.token.tok;
				if(_g1._hx_index == 3) {
					switch(_g1.s) {
					case "else":case "elseif":
						prevTypeInfo = newTypeInfo;
						continue;
					default:
					}
				}
			}
			var emptyLines = this.config.emptyLines.betweenTypes;
			if(prevTypeInfo.oneLine && newTypeInfo.oneLine) {
				emptyLines = this.config.emptyLines.betweenSingleLineTypes;
			}
			this.emptyLinesAfterSubTree(prevTypeInfo.lastToken,emptyLines);
			this.markLineCommentsAfter(prevTypeInfo.typeToken,1);
			prevTypeInfo = newTypeInfo;
		}
	}
	,getTypeInfo: function(token) {
		var info = { lastToken : tokentree_utils_TokenTreeCheckUtils.getLastToken(token), typeToken : token, oneLine : false};
		if(this.isSameLine(this.parsedCode.tokenList.findLowestIndex(token),info.lastToken)) {
			info.oneLine = true;
		}
		while(true) {
			var next = this.getNextToken(info.lastToken);
			if(next == null) {
				break;
			}
			var _g = next.token.tok;
			if(_g._hx_index == 3) {
				if(_g.s == "end") {
					info.lastToken = next.token;
				} else {
					break;
				}
			} else {
				break;
			}
		}
		return info;
	}
	,markLeftCurly: function() {
		var brOpens = this.parsedCode.root.filterCallback(function(token,index) {
			if(token.tok._hx_index == 17) {
				return tokentree_FilterResult.FoundGoDeeper;
			} else {
				return tokentree_FilterResult.GoDeeper;
			}
		});
		var _g = 0;
		while(_g < brOpens.length) this.emptyLinesAfter(brOpens[_g++],0);
	}
	,markRightCurly: function() {
		var brCloses = this.parsedCode.root.filterCallback(function(token,index) {
			if(token.tok._hx_index == 18) {
				return tokentree_FilterResult.FoundGoDeeper;
			} else {
				return tokentree_FilterResult.GoDeeper;
			}
		});
		var _g = 0;
		while(_g < brCloses.length) this.emptyLinesBefore(brCloses[_g++],0);
	}
	,markReturn: function() {
		var returns = this.parsedCode.root.filterCallback(function(token,index) {
			var _g = token.tok;
			if(_g._hx_index == 1) {
				if(_g.k._hx_index == 10) {
					return tokentree_FilterResult.FoundGoDeeper;
				} else {
					return tokentree_FilterResult.GoDeeper;
				}
			} else {
				return tokentree_FilterResult.GoDeeper;
			}
		});
		var _g = 0;
		while(_g < returns.length) {
			var ret = returns[_g];
			++_g;
			if(this.isReturnBody(ret)) {
				continue;
			}
			var lastChild = tokentree_utils_TokenTreeCheckUtils.getLastToken(ret);
			if(lastChild == null) {
				continue;
			}
			var next = this.getNextToken(lastChild);
			if(next == null) {
				continue;
			}
			if(next.token.tok._hx_index == 18) {
				this.emptyLinesAfterSubTree(ret,0);
			}
		}
	}
	,isReturnBody: function(ret) {
		var parent = ret.parent;
		while(parent != null && parent.tok != tokentree_TokenTreeDef.Root) {
			var _g = parent.tok;
			switch(_g._hx_index) {
			case 1:
				if(_g.k._hx_index == 0) {
					return true;
				} else {
					parent = parent.parent;
				}
				break;
			case 17:
				return false;
			default:
				parent = parent.parent;
			}
		}
		return true;
	}
	,markSharp: function() {
		var sharps = this.parsedCode.root.filterCallback(function(token,index) {
			if(token.tok._hx_index == 3) {
				return tokentree_FilterResult.FoundGoDeeper;
			} else {
				return tokentree_FilterResult.GoDeeper;
			}
		});
		var _g = 0;
		while(_g < sharps.length) {
			var sharp = sharps[_g];
			++_g;
			var prev = this.getPreviousToken(sharp);
			if(prev != null && prev.whitespaceAfter != formatter_codedata_WhitespaceAfterType.Newline) {
				continue;
			}
			var _g1 = sharp.tok;
			if(_g1._hx_index == 3) {
				switch(_g1.s) {
				case "else":
					this.emptyLinesBefore(sharp,this.config.emptyLines.conditionalsEmptyLines.beforeElse);
					this.emptyLinesAfter(sharp,this.config.emptyLines.conditionalsEmptyLines.afterElse);
					break;
				case "elseif":
					this.emptyLinesBefore(sharp,this.config.emptyLines.conditionalsEmptyLines.beforeElse);
					this.emptyLinesAfterSubTree(sharp.getFirstChild(),this.config.emptyLines.conditionalsEmptyLines.afterIf);
					break;
				case "end":
					this.emptyLinesBefore(sharp,this.config.emptyLines.conditionalsEmptyLines.beforeEnd);
					break;
				case "error":
					this.emptyLinesBefore(sharp,this.config.emptyLines.conditionalsEmptyLines.beforeError);
					this.emptyLinesAfterSubTree(sharp,this.config.emptyLines.conditionalsEmptyLines.afterError);
					break;
				case "if":
					this.emptyLinesAfterSubTree(sharp.getFirstChild(),this.config.emptyLines.conditionalsEmptyLines.afterIf);
					break;
				default:
				}
			}
		}
	}
	,markDocComments: function() {
		var comments = this.parsedCode.root.filterCallback(function(token,index) {
			var _g = token.tok;
			if(_g._hx_index == 7) {
				if(StringTools.startsWith(_g.s,"*")) {
					return tokentree_FilterResult.FoundGoDeeper;
				} else {
					return tokentree_FilterResult.GoDeeper;
				}
			} else {
				return tokentree_FilterResult.GoDeeper;
			}
		});
		var _g = 0;
		while(_g < comments.length) {
			var comment = comments[_g];
			++_g;
			var effectiveToken = null;
			effectiveToken = comment;
			if(comment.previousSibling != null) {
				if(comment.parent != null) {
					if(comment.parent.tok._hx_index == 3) {
						if(comment.parent.getFirstChild() == comment.previousSibling) {
							effectiveToken = comment.parent;
						}
					}
				}
			} else if(comment.parent == null || comment.parent.tok == tokentree_TokenTreeDef.Root) {
				continue;
			}
			if(comment.nextSibling == null) {
				continue;
			}
			var next = comment.nextSibling;
			var found = true;
			while(next != null) {
				var _g1 = next.tok;
				switch(_g1._hx_index) {
				case 1:
					switch(_g1.k._hx_index) {
					case 0:
						break;
					case 1:
						break;
					case 2:
						break;
					case 26:
						break;
					case 27:
						break;
					case 31:
						break;
					case 39:
						break;
					case 41:
						break;
					default:
						found = false;
					}
					break;
				case 2:
					if(_g1.c._hx_index != 3) {
						found = false;
					}
					break;
				case 3:
					next = null;
					break;
				case 8:
					next = next.nextSibling;
					continue;
				default:
					found = false;
				}
				break;
			}
			if(!found) {
				continue;
			}
			switch(this.config.emptyLines.beforeDocCommentEmptyLines) {
			case "ignore":
				break;
			case "none":
				this.emptyLinesBefore(effectiveToken,0);
				break;
			case "one":
				this.emptyLinesBefore(effectiveToken,1);
				break;
			}
			if(next == null) {
				continue;
			}
			var lastToken = tokentree_utils_TokenTreeCheckUtils.getLastToken(next);
			var nextInfo = this.getNextToken(lastToken);
			if(nextInfo == null) {
				continue;
			}
			var _g2 = nextInfo.token.tok;
			if(_g2._hx_index == 3) {
				switch(_g2.s) {
				case "end":
					lastToken = nextInfo.token;
					break;
				case "error":
					break;
				case "if":
					break;
				default:
					continue;
				}
			}
			switch(this.config.emptyLines.afterFieldsWithDocComments) {
			case "ignore":
				break;
			case "none":
				this.emptyLinesAfter(lastToken,0);
				break;
			case "one":
				this.emptyLinesAfter(lastToken,1);
				break;
			}
		}
	}
	,markMultilineComments: function() {
		var comments = this.parsedCode.root.filterCallback(function(token,index) {
			if(token.tok._hx_index == 7) {
				return tokentree_FilterResult.FoundSkipSubtree;
			} else {
				return tokentree_FilterResult.GoDeeper;
			}
		});
		var _g = 0;
		while(_g < comments.length) {
			var comment = comments[_g];
			++_g;
			var sibling = comment.nextSibling;
			if(sibling == null) {
				continue;
			}
			if(!this.isNewLineAfter(comment)) {
				continue;
			}
			if(sibling.tok._hx_index == 7) {
				this.emptyLinesAfter(comment,this.config.emptyLines.betweenMultilineComments);
			} else {
				continue;
			}
		}
	}
	,markAroundBlocks: function() {
		var _gthis = this;
		this.parsedCode.root.filterCallback(function(token,index) {
			var _g = token.tok;
			if(_g._hx_index == 1) {
				switch(_g.k._hx_index) {
				case 0:
					break;
				case 3:
					_gthis.removeEmptyLinesAroundBlock(token.children[1],_gthis.config.emptyLines.beforeBlocks,"keep");
					var this1 = tokentree_TokenTreeAccessHelper.previousSibling(tokentree_TokenTreeAccessHelper.firstOf(token,tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdElse)));
					if(this1 != null) {
						_gthis.removeEmptyLinesAroundBlock(this1,"keep",_gthis.config.emptyLines.afterBlocks);
					}
					break;
				case 4:
					_gthis.removeEmptyLinesAroundBlock(token.getFirstChild(),_gthis.config.emptyLines.beforeBlocks,"keep");
					break;
				case 5:
					var tmp;
					if(token.parent != null) {
						var _g = token.parent.tok;
						tmp = !(_g._hx_index == 1 && _g.k._hx_index == 6);
					} else {
						tmp = true;
					}
					if(tmp) {
						_gthis.removeEmptyLinesAroundBlock(token.children[1],_gthis.config.emptyLines.beforeBlocks,"keep");
					}
					break;
				case 6:
					_gthis.removeEmptyLinesAroundBlock(token.getFirstChild(),_gthis.config.emptyLines.beforeBlocks,"keep");
					var this1 = tokentree_TokenTreeAccessHelper.previousSibling(tokentree_TokenTreeAccessHelper.lastChild(token));
					_gthis.removeEmptyLinesAroundBlock(this1,"keep",_gthis.config.emptyLines.afterBlocks);
					break;
				case 7:
					_gthis.removeEmptyLinesAroundBlock(token.children[1],_gthis.config.emptyLines.beforeBlocks,"keep");
					break;
				case 15:case 16:
					var this1 = tokentree_TokenTreeAccessHelper.firstChild(tokentree_TokenTreeAccessHelper.firstOf(token,tokentree_TokenTreeDef.DblDot));
					_gthis.removeEmptyLinesAroundBlock(this1,_gthis.config.emptyLines.beforeBlocks,"keep");
					break;
				case 20:
					_gthis.removeEmptyLinesAroundBlock(token.getFirstChild(),_gthis.config.emptyLines.beforeBlocks,"keep");
					var this1 = tokentree_TokenTreeAccessHelper.previousSibling(tokentree_TokenTreeAccessHelper.lastChild(token));
					_gthis.removeEmptyLinesAroundBlock(this1,"keep",_gthis.config.emptyLines.afterBlocks);
					break;
				case 21:
					_gthis.removeEmptyLinesAroundBlock(token.children[1],_gthis.config.emptyLines.beforeBlocks,"keep");
					break;
				default:
				}
			}
			return tokentree_FilterResult.GoDeeper;
		});
	}
	,removeEmptyLinesAroundBlock: function(block,before,after) {
		if(block == null) {
			return;
		}
		if(before == "remove") {
			var prev = this.getPreviousToken(block);
			if(prev != null) {
				this.emptyLinesAfter(prev.token,0);
			}
		}
		if(after == "remove") {
			this.emptyLinesAfterSubTree(block,0);
		}
	}
	,keepExistingEmptyLines: function() {
		var funcs = this.parsedCode.root.filterCallback(function(token,index) {
			var _g = token.tok;
			if(_g._hx_index == 1) {
				if(_g.k._hx_index == 0) {
					return tokentree_FilterResult.FoundGoDeeper;
				} else {
					return tokentree_FilterResult.GoDeeper;
				}
			} else {
				return tokentree_FilterResult.GoDeeper;
			}
		});
		var _g = 0;
		while(_g < funcs.length) {
			var func = funcs[_g];
			++_g;
			var this1 = tokentree_TokenTreeAccessHelper.matches(tokentree_TokenTreeAccessHelper.firstChild(func),tokentree_TokenTreeDef.BrOpen);
			var block = this1;
			if(this1 == null) {
				block = tokentree_TokenTreeAccessHelper.firstOf(tokentree_TokenTreeAccessHelper.firstChild(func),tokentree_TokenTreeDef.BrOpen);
			}
			if(block == null) {
				continue;
			}
			var fullPos = block.getPos();
			var startLine = this.parsedCode.getLinePos(fullPos.min).line;
			var endLine = this.parsedCode.getLinePos(fullPos.max).line;
			var _g1 = 0;
			var _g2 = this.parsedCode.emptyLines;
			while(_g1 < _g2.length) {
				var emptyLine = _g2[_g1];
				++_g1;
				if(startLine >= emptyLine || endLine <= emptyLine) {
					continue;
				}
				var tokenInf = this.findTokenAtOffset(this.parsedCode.linesIdx[emptyLine].l);
				if(tokenInf == null) {
					continue;
				}
				if(tokentree_utils_TokenTreeCheckUtils.isMetadata(tokenInf.token)) {
					continue;
				}
				tokenInf.emptyLinesAfter++;
			}
		}
	}
	,markFileHeader: function() {
		var info = this.getTokenAt(0);
		var info2 = this.getTokenAt(1);
		var packagesAndImports = this.parsedCode.root.filterCallback(function(token,index) {
			var _g = token.tok;
			if(_g._hx_index == 1) {
				switch(_g.k._hx_index) {
				case 13:case 33:case 35:
					return tokentree_FilterResult.FoundSkipSubtree;
				default:
					return tokentree_FilterResult.SkipSubtree;
				}
			} else {
				return tokentree_FilterResult.GoDeeper;
			}
		});
		if(info == null) {
			return;
		}
		if(info.token.tok._hx_index == 7) {
			if(packagesAndImports.length == 0) {
				if(info2.token.tok._hx_index != 7) {
					return;
				}
			}
			info.emptyLinesAfter = this.config.emptyLines.afterFileHeaderComment;
		}
	}
	,__class__: formatter_marker_MarkEmptyLines
});
var formatter_marker_MarkLineEnds = function(config,parsedCode,indenter) {
	formatter_marker_MarkerBase.call(this,config,parsedCode,indenter);
};
formatter_marker_MarkLineEnds.__name__ = true;
formatter_marker_MarkLineEnds.outputLineSeparator = function(config,parsedCode) {
	var _g = config.lineEndCharacter;
	if(_g == null) {
		return parsedCode.lineSeparator;
	} else {
		switch(_g) {
		case "CR":
			return "\r";
		case "CRLF":
			return "\r\n";
		case "LF":
			return "\n";
		default:
			return parsedCode.lineSeparator;
		}
	}
};
formatter_marker_MarkLineEnds.__super__ = formatter_marker_MarkerBase;
formatter_marker_MarkLineEnds.prototype = $extend(formatter_marker_MarkerBase.prototype,{
	run: function() {
		var semicolonTokens = this.parsedCode.root.filterCallback(function(token,index) {
			if(token.tok._hx_index == 10) {
				return tokentree_FilterResult.FoundGoDeeper;
			} else {
				return tokentree_FilterResult.GoDeeper;
			}
		});
		var _g = 0;
		while(_g < semicolonTokens.length) this.lineEndAfter(semicolonTokens[_g++]);
		this.markBrOpenClose();
		this.markAt();
		this.markDblDot();
		this.markSharp();
		this.markComments();
		this.markStructureExtension();
	}
	,markComments: function() {
		var commentTokens = this.parsedCode.root.filterCallback(function(token,index) {
			switch(token.tok._hx_index) {
			case 7:
				return tokentree_FilterResult.FoundSkipSubtree;
			case 8:
				return tokentree_FilterResult.FoundSkipSubtree;
			default:
				return tokentree_FilterResult.GoDeeper;
			}
		});
		var _g = 0;
		while(_g < commentTokens.length) {
			var token = commentTokens[_g];
			++_g;
			switch(token.tok._hx_index) {
			case 7:
				var prev = this.getPreviousToken(token);
				var noneBefore = false;
				if(prev != null) {
					if(this.parsedCode.isOriginalSameLine(token,prev.token)) {
						if(prev.whitespaceAfter == formatter_codedata_WhitespaceAfterType.Newline) {
							this.lineEndAfter(token);
						}
						this.noLineEndBefore(token);
						noneBefore = !this.isMultilineToken(token);
					}
				}
				var commentLine = this.parsedCode.getLinePos(token.pos.min);
				var prefix = this.parsedCode.getString(this.parsedCode.linesIdx[commentLine.line].l,token.pos.min);
				commentLine = this.parsedCode.getLinePos(token.pos.max);
				var postfix = this.parsedCode.getString(token.pos.max,this.parsedCode.linesIdx[commentLine.line].r);
				if(new EReg("^\\s*$","").match(prefix) && new EReg("^\\s*$","").match(postfix)) {
					this.lineEndAfter(token);
					continue;
				}
				var next = this.getNextToken(token);
				if(next == null) {
					continue;
				}
				if(this.parsedCode.isOriginalSameLine(token,next.token)) {
					this.noLineEndAfter(token);
				}
				var _g1 = next.token.tok;
				switch(_g1._hx_index) {
				case 1:
					if(!noneBefore) {
						this.lineEndAfter(token);
					}
					continue;
				case 2:
					var _g2 = _g1.c;
					if(_g2._hx_index == 3) {
						if(_g2.s == "final") {
							if(!noneBefore) {
								this.lineEndAfter(token);
							}
							continue;
						}
					}
					break;
				default:
				}
				break;
			case 8:
				var prev1 = this.getPreviousToken(token);
				if(prev1 != null) {
					if(this.parsedCode.isOriginalSameLine(token,prev1.token)) {
						this.noLineEndBefore(token);
					}
				}
				this.lineEndAfter(token);
				break;
			default:
			}
		}
	}
	,markBrOpenClose: function() {
		var brTokens = this.parsedCode.root.filterCallback(function(token,index) {
			if(token.tok._hx_index == 17) {
				return tokentree_FilterResult.FoundGoDeeper;
			}
			return tokentree_FilterResult.GoDeeper;
		});
		var _g = 0;
		while(_g < brTokens.length) {
			var brOpen = brTokens[_g];
			++_g;
			var curlyPolicy = this.detectCurlyPolicy(brOpen);
			this.fixMissingSemicolonsInBlock(brOpen);
			var brClose = this.getCloseToken(brOpen);
			if(brClose == null) {
				switch(curlyPolicy.leftCurly) {
				case "after":
					this.lineEndAfter(brOpen);
					break;
				case "before":
					this.beforeLeftCurly(brOpen);
					break;
				case "both":
					this.beforeLeftCurly(brOpen);
					this.lineEndAfter(brOpen);
					break;
				case "none":
					break;
				}
				continue;
			}
			var prev = this.getPreviousToken(brOpen);
			if(prev != null) {
				var _g1 = prev.token.tok;
				if(_g1._hx_index == 4) {
					switch(_g1.s) {
					case "":case "a":case "b":case "e":case "i":case "p":case "v":
						if(this.parsedCode.isOriginalSameLine(brOpen,brClose)) {
							this.noLineEndAfter(brOpen);
							this.noLineEndBefore(brClose);
							this.whitespace(brOpen,"none");
							this.whitespace(brClose,"noneBefore");
							var next = this.getNextToken(brClose);
							if(next != null) {
								if(next.token.tok._hx_index == 12) {
									this.whitespace(brClose,"after");
								}
							}
							continue;
						}
						this.whitespace(brOpen,"noneBefore");
						break;
					default:
					}
				}
			}
			var next1 = this.getNextToken(brOpen);
			var isEmpty = false;
			if(next1 != null) {
				if(next1.token.tok._hx_index == 18) {
					if(curlyPolicy.emptyCurly == "noBreak") {
						isEmpty = true;
					}
				}
			}
			if(!isEmpty) {
				switch(curlyPolicy.leftCurly) {
				case "after":
					this.lineEndAfter(brOpen);
					break;
				case "before":
					this.beforeLeftCurly(brOpen);
					break;
				case "both":
					this.beforeLeftCurly(brOpen);
					this.lineEndAfter(brOpen);
					break;
				case "none":
					break;
				}
			}
			var preventBefore = isEmpty;
			var preventAfter = false;
			next1 = this.getNextToken(brClose);
			if(next1 != null) {
				if(next1.token.tok._hx_index == 12) {
					preventAfter = true;
				}
			}
			switch(curlyPolicy.rightCurly) {
			case "after":
				if(!preventAfter) {
					this.afterRightCurly(brClose);
				}
				break;
			case "before":
				if(!preventBefore) {
					this.beforeRightCurly(brClose);
				}
				break;
			case "both":
				if(!preventBefore) {
					this.beforeRightCurly(brClose);
				}
				if(!preventAfter) {
					this.afterRightCurly(brClose);
				}
				break;
			case "none":
				break;
			}
		}
	}
	,fixMissingSemicolonsInBlock: function(token) {
		switch(tokentree_utils_TokenTreeCheckUtils.getBrOpenType(token)._hx_index) {
		case 0:
			break;
		case 1:case 2:case 3:case 4:
			return;
		}
		if(!token.hasChildren()) {
			return;
		}
		var _g = 0;
		var _g1 = token.children;
		while(_g < _g1.length) {
			var child = _g1[_g];
			++_g;
			switch(child.tok._hx_index) {
			case 3:
				continue;
			case 18:
				return;
			default:
				var lastChild = tokentree_utils_TokenTreeCheckUtils.getLastToken(child);
				if(lastChild == null) {
					continue;
				}
				if(lastChild.tok._hx_index == 10) {
					continue;
				} else if(this.isMissingSemicolon(lastChild)) {
					this.lineEndAfter(lastChild);
				}
			}
		}
	}
	,isMissingSemicolon: function(token) {
		while(true) {
			var next = this.getNextToken(token);
			if(next == null) {
				return true;
			}
			token = next.token;
			switch(token.tok._hx_index) {
			case 10:
				return false;
			case 16:case 20:
				continue;
			default:
				return true;
			}
		}
	}
	,detectCurlyPolicy: function(brOpen) {
		var type = tokentree_utils_TokenTreeCheckUtils.getBrOpenType(brOpen);
		var curlyPolicy = { leftCurly : this.config.lineEnds.leftCurly, rightCurly : this.config.lineEnds.rightCurly, emptyCurly : this.config.lineEnds.emptyCurly};
		switch(type._hx_index) {
		case 0:
			if(brOpen.parent != null && this.config.lineEnds.anonFunctionCurly != null) {
				var _g = brOpen.parent.tok;
				switch(_g._hx_index) {
				case 1:
					if(_g.k._hx_index == 0) {
						return this.config.lineEnds.anonFunctionCurly;
					}
					break;
				case 13:
					return this.config.lineEnds.anonFunctionCurly;
				default:
				}
			}
			if(this.config.lineEnds.blockCurly != null) {
				return this.config.lineEnds.blockCurly;
			}
			break;
		case 1:
			if(this.config.lineEnds.typedefCurly != null) {
				return this.config.lineEnds.typedefCurly;
			}
			break;
		case 2:
			if(this.config.lineEnds.objectLiteralCurly != null) {
				return this.config.lineEnds.objectLiteralCurly;
			}
			break;
		case 3:
			if(this.config.lineEnds.anonTypeCurly != null) {
				return this.config.lineEnds.anonTypeCurly;
			} else {
				var brClose = this.getCloseToken(brOpen);
				if(this.parsedCode.isOriginalSameLine(brOpen,brClose)) {
					var _g = curlyPolicy.leftCurly;
					if(_g != null) {
						switch(_g) {
						case "before":
							curlyPolicy.leftCurly = "none";
							break;
						case "both":
							curlyPolicy.leftCurly = "after";
							break;
						default:
						}
					}
				}
			}
			break;
		case 4:
			break;
		}
		return curlyPolicy;
	}
	,beforeLeftCurly: function(token) {
		this.lineEndBefore(token);
	}
	,beforeRightCurly: function(token) {
		this.lineEndBefore(token);
	}
	,afterRightCurly: function(token) {
		var next = token.index + 1;
		if(this.parsedCode.tokenList.tokens.length <= next) {
			this.lineEndAfter(token);
			return;
		}
		var nextToken = this.getTokenAt(next);
		if(nextToken == null) {
			this.lineEndAfter(token);
			return;
		}
		var _g = nextToken.token.tok;
		switch(_g._hx_index) {
		case 2:
			var _g1 = _g.c;
			if(_g1._hx_index == 3) {
				if(_g1.s != "is") {
					this.lineEndAfter(token);
				}
			} else {
				this.lineEndAfter(token);
			}
			break;
		case 6:
			switch(_g.op._hx_index) {
			case 4:
				break;
			case 7:
				break;
			default:
				this.lineEndAfter(token);
			}
			break;
		case 10:
			break;
		case 11:
			break;
		case 13:
			break;
		case 14:
			break;
		case 17:
			switch(tokentree_utils_TokenTreeCheckUtils.getBrOpenType(nextToken.token)._hx_index) {
			case 0:
				break;
			case 1:
				break;
			case 2:
				this.lineEndAfter(token);
				break;
			case 3:
				break;
			case 4:
				break;
			}
			break;
		case 20:
			break;
		default:
			this.lineEndAfter(token);
		}
	}
	,markAt: function() {
		var _gthis = this;
		var atTokens = this.parsedCode.root.filterCallback(function(token,index) {
			if(token.tok._hx_index == 22) {
				return tokentree_FilterResult.FoundSkipSubtree;
			} else {
				return tokentree_FilterResult.GoDeeper;
			}
		});
		var addLineEndBefore = function(atToken) {
			var prev = _gthis.getPreviousToken(atToken);
			if(prev == null) {
				_gthis.lineEndBefore(atToken);
				return;
			}
			var _g = prev.token.tok;
			switch(_g._hx_index) {
			case 1:
				switch(_g.k._hx_index) {
				case 4:
					_gthis.lineEndBefore(atToken);
					break;
				case 0:case 2:case 41:
					_gthis.noLineEndBefore(atToken);
					break;
				default:
				}
				break;
			case 17:
				_gthis.lineEndBefore(atToken);
				break;
			default:
			}
		};
		var _g = 0;
		while(_g < atTokens.length) {
			var token = atTokens[_g];
			++_g;
			var metadataPolicy = this.determineMetadataPolicy(token);
			var lastChild = tokentree_utils_TokenTreeCheckUtils.getLastToken(token);
			if(lastChild == null) {
				continue;
			}
			var isNotFirst = token.previousSibling != null && token.previousSibling.tok._hx_index == 22;
			if(!isNotFirst) {
				addLineEndBefore(token);
			}
			if(metadataPolicy == "after") {
				this.lineEndAfter(lastChild);
				continue;
			}
			if(isNotFirst) {
				continue;
			}
			var next = token.nextSibling;
			var metadata = [token];
			while(next != null && next.tok._hx_index == 22) {
				metadata.push(next);
				next = next.nextSibling;
			}
			var _g1 = 0;
			while(_g1 < metadata.length) {
				lastChild = tokentree_utils_TokenTreeCheckUtils.getLastToken(metadata[_g1++]);
				if(lastChild == null) {
					continue;
				}
				switch(metadataPolicy) {
				case "after":
					this.lineEndAfter(lastChild);
					break;
				case "afterLast":
					var next1 = this.getNextToken(lastChild);
					if(next1 != null && !this.parsedCode.isOriginalSameLine(lastChild,next1.token)) {
						this.lineEndAfter(lastChild);
						continue;
					}
					this.whitespace(lastChild,"after");
					break;
				case "forceAfterLast":
					this.whitespace(lastChild,"after");
					break;
				case "none":
					var next2 = this.getNextToken(lastChild);
					if(next2 != null && !this.parsedCode.isOriginalSameLine(lastChild,next2.token)) {
						this.lineEndAfter(lastChild);
						continue;
					}
					this.whitespace(lastChild,"after");
					break;
				}
			}
			if(metadataPolicy == "afterLast" || metadataPolicy == "forceAfterLast") {
				this.lineEndAfter(lastChild);
			}
		}
	}
	,determineMetadataPolicy: function(token) {
		if(token == null) {
			return this.config.lineEnds.metadataOther;
		}
		var parent = token.parent;
		if(parent == null || parent.tok == tokentree_TokenTreeDef.Root) {
			return this.config.lineEnds.metadataType;
		}
		var _g = parent.tok;
		switch(_g._hx_index) {
		case 1:
			switch(_g.k._hx_index) {
			case 0:
				return this.config.lineEnds.metadataFunction;
			case 22:
				if(parent.parent == null) {
					return this.config.lineEnds.metadataOther;
				}
				var _g1 = parent.parent.tok;
				if(_g1._hx_index == 1) {
					switch(_g1.k._hx_index) {
					case 0:
						return this.config.lineEnds.metadataFunction;
					case 2:
						return this.config.lineEnds.metadataVar;
					case 1:case 26:case 27:case 31:case 39:
						return this.config.lineEnds.metadataType;
					default:
						return this.config.lineEnds.metadataOther;
					}
				} else {
					return this.config.lineEnds.metadataOther;
				}
				break;
			default:
				return this.config.lineEnds.metadataOther;
			}
			break;
		case 2:
			if(_g.c._hx_index == 3) {
				if(parent.parent == null) {
					return this.config.lineEnds.metadataOther;
				}
				var _g = parent.parent.tok;
				if(_g._hx_index == 1) {
					switch(_g.k._hx_index) {
					case 0:
						return this.config.lineEnds.metadataFunction;
					case 2:
						return this.config.lineEnds.metadataVar;
					case 1:case 26:case 27:case 31:case 39:
						return this.config.lineEnds.metadataType;
					default:
						return this.config.lineEnds.metadataOther;
					}
				} else {
					return this.config.lineEnds.metadataOther;
				}
			} else {
				return this.config.lineEnds.metadataOther;
			}
			break;
		case 3:
			return "after";
		case 4:
			if(parent.parent == null) {
				return this.config.lineEnds.metadataOther;
			}
			var _g = parent.parent.tok;
			if(_g._hx_index == 1) {
				switch(_g.k._hx_index) {
				case 0:
					return this.config.lineEnds.metadataFunction;
				case 2:
					return this.config.lineEnds.metadataVar;
				case 1:case 26:case 27:case 31:case 39:
					return this.config.lineEnds.metadataType;
				default:
					return this.config.lineEnds.metadataOther;
				}
			} else {
				return this.config.lineEnds.metadataOther;
			}
			break;
		default:
			return this.config.lineEnds.metadataOther;
		}
	}
	,markDblDot: function() {
		var dblDotTokens = this.parsedCode.root.filterCallback(function(token,index) {
			if(token.tok._hx_index == 12) {
				return tokentree_FilterResult.FoundGoDeeper;
			} else {
				return tokentree_FilterResult.GoDeeper;
			}
		});
		var _g = 0;
		while(_g < dblDotTokens.length) {
			var token = dblDotTokens[_g];
			++_g;
			var tmp;
			var _g1 = token.parent.tok;
			if(!(_g1._hx_index == 1 && _g1.k._hx_index == 15)) {
				var _g2 = token.parent.tok;
				tmp = !(_g2._hx_index == 1 && _g2.k._hx_index == 16);
			} else {
				tmp = false;
			}
			if(tmp) {
				continue;
			}
			if(this.config.lineEnds.caseColon != "none") {
				this.lineEndAfter(token);
			}
			var lastChild = tokentree_utils_TokenTreeCheckUtils.getLastToken(token);
			if(lastChild == null) {
				continue;
			}
			this.lineEndAfter(lastChild);
		}
	}
	,markSharp: function() {
		var sharpTokens = this.parsedCode.root.filterCallback(function(token,index) {
			var _g = token.tok;
			if(_g._hx_index == 3) {
				switch(_g.s) {
				case "else":case "elseif":case "end":case "error":case "if":
					return tokentree_FilterResult.FoundGoDeeper;
				default:
					return tokentree_FilterResult.GoDeeper;
				}
			} else {
				return tokentree_FilterResult.GoDeeper;
			}
		});
		var _g = 0;
		while(_g < sharpTokens.length) {
			var token = sharpTokens[_g];
			++_g;
			var _g1 = token.tok;
			if(_g1._hx_index == 3) {
				switch(_g1.s) {
				case "else":
					if(this.isInlineSharp(token)) {
						this.noLineEndBefore(token);
						continue;
					}
					this.lineEndBefore(token);
					this.lineEndAfter(token);
					break;
				case "end":
					if(this.isInlineSharp(token)) {
						this.noLineEndBefore(token);
					} else {
						this.lineEndBefore(token);
					}
					var next = this.getNextToken(token);
					if(next != null) {
						switch(next.token.tok._hx_index) {
						case 10:case 14:
							continue;
						default:
						}
					}
					if(!this.isOnlyWhitespaceAfterToken(token,true)) {
						continue;
					}
					this.lineEndAfter(token);
					break;
				case "error":
					var lastChild = tokentree_utils_TokenTreeCheckUtils.getLastToken(token.getFirstChild());
					if(lastChild == null) {
						lastChild = token;
					}
					this.lineEndAfter(lastChild);
					break;
				case "elseif":case "if":
					var lastChild1 = tokentree_utils_TokenTreeCheckUtils.getLastToken(token.getFirstChild());
					if(lastChild1 == null) {
						continue;
					}
					if(this.config.lineEnds.sharp == "none") {
						this.whitespace(lastChild1,"after");
						continue;
					}
					if(this.isInlineSharp(token)) {
						var _g2 = token.tok;
						if(_g2._hx_index == 3 && _g2.s == "if" && this.isOnlyWhitespaceBeforeToken(token)) {
							continue;
						}
						this.noLineEndBefore(token);
						continue;
					}
					this.lineEndBefore(token);
					this.lineEndAfter(lastChild1);
					break;
				default:
					this.lineEndAfter(token);
				}
			} else {
				this.lineEndAfter(token);
			}
		}
	}
	,isInlineSharp: function(token) {
		var _g = token.tok;
		if(_g._hx_index == 3) {
			switch(_g.s) {
			case "else":
				return this.isInlineSharp(token.parent);
			case "elseif":
				return this.isInlineSharp(token.parent);
			case "end":
				return this.isInlineSharp(token.parent);
			case "if":
				var sharpEnd = token.getLastChild();
				if(sharpEnd == null) {
					return false;
				}
				var _g = sharpEnd.tok;
				switch(_g._hx_index) {
				case 3:
					if(_g.s == "end") {
						if(this.parsedCode.linesBetweenOriginal(token,sharpEnd) > 5) {
							return false;
						}
					} else {
						return false;
					}
					break;
				case 10:case 14:
					sharpEnd = sharpEnd.previousSibling;
					if(sharpEnd == null) {
						return false;
					}
					var _g = sharpEnd.tok;
					if(!(_g._hx_index == 3 && _g.s == "end")) {
						return false;
					}
					break;
				default:
					return false;
				}
				if(!this.isOnlyWhitespaceAfterToken(sharpEnd,true)) {
					return true;
				}
				if(!this.isOnlyWhitespaceBeforeToken(token)) {
					return true;
				}
				var prev = this.getPreviousToken(token);
				if(prev == null) {
					return !this.isOnlyWhitespaceBeforeToken(token);
				}
				if(prev.whitespaceAfter == formatter_codedata_WhitespaceAfterType.Newline) {
					return false;
				}
				switch(prev.token.tok._hx_index) {
				case 7:
					return false;
				case 8:
					return false;
				case 10:
					return false;
				case 18:
					return false;
				case 20:
					if(this.parsedCode.isOriginalSameLine(prev.token,token)) {
						return true;
					}
					return false;
				default:
					return true;
				}
				break;
			default:
				return false;
			}
		} else {
			return false;
		}
	}
	,isOnlyWhitespaceBeforeToken: function(token) {
		var tokenLine = this.parsedCode.getLinePos(token.pos.min);
		var prefix = this.parsedCode.getString(this.parsedCode.linesIdx[tokenLine.line].l,token.pos.min);
		return new EReg("^\\s*$","").match(prefix);
	}
	,isOnlyWhitespaceAfterToken: function(token,allowLineComments) {
		var tokenLine = this.parsedCode.getLinePos(token.pos.max);
		var prefix = this.parsedCode.getString(token.pos.max,this.parsedCode.linesIdx[tokenLine.line].r);
		if(allowLineComments) {
			return new EReg("^\\s*(|//.*)$","").match(prefix);
		} else {
			return new EReg("^\\s*$","").match(prefix);
		}
	}
	,findTypedefBrOpen: function(token) {
		var this1 = tokentree_TokenTreeAccessHelper.firstOf(tokentree_TokenTreeAccessHelper.isCIdent(tokentree_TokenTreeAccessHelper.firstChild(token)),tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpAssign));
		if(this1 == null) {
			return null;
		}
		return tokentree_TokenTreeAccessHelper.firstOf(this1,tokentree_TokenTreeDef.BrOpen);
	}
	,markStructureExtension: function() {
		var typedefTokens = this.parsedCode.root.filterCallback(function(token,index) {
			var _g = token.tok;
			if(_g._hx_index == 1) {
				if(_g.k._hx_index == 31) {
					return tokentree_FilterResult.FoundSkipSubtree;
				} else {
					return tokentree_FilterResult.SkipSubtree;
				}
			} else {
				return tokentree_FilterResult.GoDeeper;
			}
		});
		var _g = 0;
		while(_g < typedefTokens.length) {
			var token = typedefTokens[_g];
			++_g;
			this.markAfterTypedef(token);
			var brOpen = this.findTypedefBrOpen(token);
			if(brOpen == null) {
				continue;
			}
			if(brOpen.children == null || brOpen.children.length <= 0) {
				continue;
			}
			var assignParent = brOpen.parent;
			if(assignParent.children.length > 1) {
				var _g1 = 0;
				var _g2 = assignParent.children;
				while(_g1 < _g2.length) {
					var lastChild = tokentree_utils_TokenTreeCheckUtils.getLastToken(_g2[_g1++]);
					if(lastChild == null) {
						continue;
					}
					var next = this.getNextToken(lastChild);
					if(next == null) {
						continue;
					}
					if(lastChild.tok._hx_index == 18) {
						var _g3 = next.token.tok;
						switch(_g3._hx_index) {
						case 6:
							if(_g3.op._hx_index == 11) {
								this.noLineEndAfter(lastChild);
								continue;
							}
							break;
						case 10:
							this.whitespace(lastChild,"noneAfter");
							continue;
						case 13:
							this.whitespace(lastChild,"none");
							continue;
						default:
						}
					}
					switch(next.token.tok._hx_index) {
					case 10:case 17:
						continue;
					default:
					}
					this.lineEndAfter(lastChild);
				}
			}
			var _g4 = 0;
			var _g5 = brOpen.children;
			while(_g4 < _g5.length) {
				var child = _g5[_g4];
				++_g4;
				var _g6 = child.tok;
				switch(_g6._hx_index) {
				case 2:
					if(_g6.c._hx_index == 3) {
						var lastChild1 = tokentree_utils_TokenTreeCheckUtils.getLastToken(child);
						if(lastChild1 == null) {
							continue;
						}
						this.lineEndAfter(lastChild1);
					}
					break;
				case 6:
					if(_g6.op._hx_index == 7) {
						var lastChild2 = tokentree_utils_TokenTreeCheckUtils.getLastToken(child);
						if(lastChild2 == null) {
							continue;
						}
						this.lineEndAfter(lastChild2);
					}
					break;
				case 18:
					var next1 = this.getNextToken(child);
					if(next1 == null) {
						continue;
					}
					var _g7 = next1.token.tok;
					if(_g7._hx_index == 6 && _g7.op._hx_index == 11) {
						this.noLineEndAfter(child);
					}
					var _g8 = next1.token.tok;
					if(_g8._hx_index == 6 && _g8.op._hx_index == 7) {
						this.whitespace(child,"noneAfter");
					}
					break;
				case 21:
					var lastChild3 = tokentree_utils_TokenTreeCheckUtils.getLastToken(child);
					if(lastChild3 == null) {
						continue;
					}
					this.lineEndAfter(lastChild3);
					break;
				default:
				}
			}
		}
	}
	,markAfterTypedef: function(token) {
		var lastChild = tokentree_utils_TokenTreeCheckUtils.getLastToken(token);
		if(lastChild == null) {
			return;
		}
		var next = this.getNextToken(lastChild);
		if(next != null) {
			switch(next.token.tok._hx_index) {
			case 8:
				if(!this.parsedCode.isOriginalNewlineBefore(next.token)) {
					return;
				}
				break;
			case 10:
				this.whitespace(lastChild,"noneAfter");
				return;
			default:
			}
		}
		this.lineEndAfter(lastChild);
	}
	,__class__: formatter_marker_MarkLineEnds
});
var formatter_marker_MarkSameLine = function(config,parsedCode,indenter) {
	formatter_marker_MarkerBase.call(this,config,parsedCode,indenter);
};
formatter_marker_MarkSameLine.__name__ = true;
formatter_marker_MarkSameLine.__super__ = formatter_marker_MarkerBase;
formatter_marker_MarkSameLine.prototype = $extend(formatter_marker_MarkerBase.prototype,{
	run: function() {
		var _gthis = this;
		this.markDollarSameLine();
		this.parsedCode.root.filterCallback(function(token,index) {
			if(token.parent != null && token.parent.tok._hx_index == 22) {
				return tokentree_FilterResult.GoDeeper;
			}
			var _g = token.tok;
			if(_g._hx_index == 1) {
				switch(_g.k._hx_index) {
				case 0:
					_gthis.markFunction(token);
					break;
				case 3:
					_gthis.markIf(token);
					break;
				case 4:
					_gthis.markElse(token);
					break;
				case 5:
					var tmp;
					if(token.parent != null) {
						var _g = token.parent.tok;
						tmp = _g._hx_index == 1 && _g.k._hx_index == 6;
					} else {
						tmp = false;
					}
					if(tmp) {
						return tokentree_FilterResult.GoDeeper;
					}
					_gthis.markWhile(token);
					break;
				case 6:
					_gthis.markDoWhile(token);
					break;
				case 7:
					_gthis.markFor(token);
					break;
				case 10:
					_gthis.markReturn(token);
					break;
				case 15:
					_gthis.markCase(token);
					break;
				case 16:
					_gthis.markCase(token);
					break;
				case 20:
					_gthis.markTry(token);
					break;
				case 21:
					_gthis.markCatch(token);
					break;
				case 28:
					_gthis.markUntyped(token);
					break;
				case 40:
					_gthis.markMacro(token);
					break;
				default:
				}
			}
			return tokentree_FilterResult.GoDeeper;
		});
	}
	,isExpression: function(token) {
		if(token == null) {
			return false;
		}
		var parent = token.parent;
		var _g = parent.tok;
		switch(_g._hx_index) {
		case 1:
			switch(_g.k._hx_index) {
			case 4:
				return this.shouldElseBeSameLine(parent);
			case 5:case 7:
				if(parent.parent.tok._hx_index == 15) {
					return true;
				}
				break;
			case 10:
				return true;
			case 28:
				return this.isExpression(parent);
			default:
			}
			break;
		case 6:
			return true;
		case 12:
			var lastChild = parent.getLastChild();
			if(lastChild == null) {
				return false;
			}
			if(lastChild.index != token.index) {
				return false;
			}
			return this.isReturnExpression(parent);
		case 13:
			return true;
		case 19:
			var pos = parent.getPos();
			if(pos.min < token.pos.min && pos.max > token.pos.max) {
				return true;
			}
			break;
		default:
		}
		return false;
	}
	,isReturnExpression: function(token) {
		var parent = token;
		while(parent.parent.tok != tokentree_TokenTreeDef.Root) {
			parent = parent.parent;
			var _g = parent.tok;
			switch(_g._hx_index) {
			case 1:
				switch(_g.k._hx_index) {
				case 0:
					return false;
				case 10:
					return true;
				default:
				}
				break;
			case 6:
				return true;
			case 12:
				return true;
			case 13:
				return true;
			case 15:
				return false;
			case 17:
				switch(tokentree_utils_TokenTreeCheckUtils.getBrOpenType(parent)._hx_index) {
				case 0:
					break;
				case 1:
					break;
				case 2:
					return true;
				case 3:
					break;
				case 4:
					break;
				}
				break;
			case 19:
				return true;
			default:
			}
		}
		return false;
	}
	,shouldIfBeSameLine: function(token) {
		if(token == null) {
			return false;
		}
		var _g = token.tok;
		if(!(_g._hx_index == 1 && _g.k._hx_index == 3)) {
			return false;
		}
		if(this.getBodyAfterCondition(token) == null) {
			return false;
		}
		return this.isExpression(token);
	}
	,shouldElseBeSameLine: function(token) {
		if(token == null) {
			return false;
		}
		var _g = token.tok;
		if(!(_g._hx_index == 1 && _g.k._hx_index == 4)) {
			return false;
		}
		return this.shouldIfBeSameLine(token.parent);
	}
	,shouldTryBeSameLine: function(token) {
		if(token == null) {
			return false;
		}
		var _g = token.tok;
		if(!(_g._hx_index == 1 && _g.k._hx_index == 20)) {
			return false;
		}
		return this.isExpression(token);
	}
	,shouldCatchBeSameLine: function(token) {
		if(token == null) {
			return false;
		}
		var _g = token.tok;
		if(!(_g._hx_index == 1 && _g.k._hx_index == 21)) {
			return false;
		}
		return this.shouldTryBeSameLine(token.parent);
	}
	,markIf: function(token) {
		if(this.shouldIfBeSameLine(token)) {
			switch(this.config.sameLine.expressionIf) {
			case "keep":
				this.markBodyAfterPOpen(token,"keep",this.config.sameLine.expressionIfWithBlocks);
				return;
			case "next":
				break;
			case "same":
				this.markBodyAfterPOpen(token,"same",this.config.sameLine.expressionIfWithBlocks);
				return;
			}
		}
		this.markBodyAfterPOpen(token,this.config.sameLine.ifBody,false);
		var prev = this.getPreviousToken(token);
		var tmp;
		if(prev != null) {
			var _g = prev.token.tok;
			tmp = _g._hx_index == 1 && _g.k._hx_index == 4;
		} else {
			tmp = false;
		}
		if(tmp) {
			this.applySameLinePolicy(token,this.config.sameLine.elseIf);
		}
	}
	,markElse: function(token) {
		if(this.shouldElseBeSameLine(token)) {
			switch(this.config.sameLine.expressionIf) {
			case "keep":
				this.markBody(token,"keep",this.config.sameLine.expressionIfWithBlocks);
				if(this.parsedCode.isOriginalNewlineBefore(token)) {
					this.lineEndBefore(token);
				}
				var prev = this.getPreviousToken(token);
				if(prev == null) {
					return;
				}
				if(prev.token.tok._hx_index == 18) {
					this.applySameLinePolicyChained(token,"keep","keep");
				}
				return;
			case "next":
				break;
			case "same":
				this.markBody(token,"same",this.config.sameLine.expressionIfWithBlocks);
				var prev = this.getPreviousToken(token);
				if(prev == null) {
					return;
				}
				if(prev.token.tok._hx_index == 18) {
					this.applySameLinePolicyChained(token,this.config.sameLine.ifBody,this.config.sameLine.ifElse);
				}
				return;
			}
		}
		this.markBody(token,this.config.sameLine.elseBody,false);
		var policy = this.config.sameLine.ifElse;
		var prev = this.getPreviousToken(token);
		if(prev != null) {
			if(prev.token.tok._hx_index == 18) {
				if(tokentree_TokenTreeAccessHelper.matches(tokentree_TokenTreeAccessHelper.parent(tokentree_TokenTreeAccessHelper.matches(tokentree_TokenTreeAccessHelper.parent(prev.token),tokentree_TokenTreeDef.BrOpen)),tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdIf)) == null) {
					switch(policy) {
					case "keep":
						break;
					case "next":
						break;
					case "same":
						policy = "next";
						break;
					}
				}
			}
		}
		this.applySameLinePolicyChained(token,this.config.sameLine.ifBody,policy);
	}
	,markTry: function(token) {
		if(this.shouldTryBeSameLine(token) && this.config.sameLine.expressionTry == "same") {
			this.markBody(token,"same",false);
			return;
		}
		this.markBody(token,this.config.sameLine.tryBody,false);
	}
	,markCatch: function(token) {
		if(this.shouldCatchBeSameLine(token) && this.config.sameLine.expressionTry == "same") {
			this.markBodyAfterPOpen(token,"same",false);
			this.applySameLinePolicy(token,this.config.sameLine.tryCatch);
			return;
		}
		this.markBodyAfterPOpen(token,this.config.sameLine.catchBody,false);
		this.applySameLinePolicyChained(token,this.config.sameLine.tryBody,this.config.sameLine.tryCatch);
	}
	,markCase: function(token) {
		if(token == null) {
			return;
		}
		var this1 = tokentree_TokenTreeAccessHelper.firstOf(token,tokentree_TokenTreeDef.DblDot);
		if(this1 == null) {
			return;
		}
		if(this.isReturnExpression(token)) {
			this.markExpressionCase(token,this1);
			return;
		}
		if(this1.children == null || this1.children.length > 1) {
			return;
		}
		switch(this.config.sameLine.caseBody) {
		case "keep":
			if(!this.parsedCode.isOriginalSameLine(this1,this1.getFirstChild())) {
				return;
			}
			break;
		case "next":
			return;
		case "same":
			break;
		}
		var first = this1.getFirstChild();
		var last = tokentree_utils_TokenTreeCheckUtils.getLastToken(first);
		if(this.parsedCode.linesBetweenOriginal(first,last) > 2) {
			return;
		}
		this.noLineEndAfter(this1);
	}
	,markExpressionCase: function(token,dblDot) {
		if(dblDot.children == null) {
			return;
		}
		switch(this.config.sameLine.expressionCase) {
		case "keep":
			if(!this.parsedCode.isOriginalSameLine(dblDot,dblDot.getFirstChild())) {
				return;
			}
			break;
		case "next":
			return;
		case "same":
			break;
		}
		if(dblDot.children.length == 2) {
			var second = dblDot.children[1];
			if(second.tok._hx_index == 8) {
				var prev = this.getPreviousToken(second);
				if(prev != null) {
					if(!this.parsedCode.isOriginalSameLine(dblDot,prev.token)) {
						return;
					}
				}
			} else {
				return;
			}
		}
		if(dblDot.children.length > 2) {
			return;
		}
		this.noLineEndAfter(dblDot);
	}
	,isArrayComprehension: function(token) {
		if(token == null) {
			return false;
		}
		var parent = token.parent;
		while(parent != null) {
			var _g = parent.tok;
			switch(_g._hx_index) {
			case 1:
				switch(_g.k._hx_index) {
				case 3:case 4:case 5:case 7:
					parent = parent.parent;
					break;
				default:
					return false;
				}
				break;
			case 15:
				return true;
			default:
				return false;
			}
		}
		return false;
	}
	,markFor: function(token) {
		if(token == null) {
			return;
		}
		var parent = token.parent;
		if(parent == null || parent.tok == tokentree_TokenTreeDef.Root) {
			return;
		}
		if(this.isArrayComprehension(token)) {
			this.markArrayComprehension(token,parent);
			return;
		}
		var _g = parent.tok;
		if(_g._hx_index == 1) {
			if(_g.k._hx_index == 40) {
				var lastToken = tokentree_utils_TokenTreeCheckUtils.getLastToken(token);
				if(lastToken == null) {
					return;
				}
				if(this.parsedCode.isOriginalSameLine(token,lastToken)) {
					this.markBodyAfterPOpen(token,"same",false);
					return;
				}
			}
		}
		this.markBodyAfterPOpen(token,this.config.sameLine.forBody,false);
	}
	,markWhile: function(token) {
		if(token == null) {
			return;
		}
		var parent = token.parent;
		if(parent == null || parent.tok == tokentree_TokenTreeDef.Root) {
			return;
		}
		if(this.isArrayComprehension(token)) {
			this.markArrayComprehension(token,parent);
			return;
		}
		this.markBodyAfterPOpen(token,this.config.sameLine.whileBody,false);
	}
	,markArrayComprehension: function(token,bkOpen) {
		var bkClose = this.getCloseToken(bkOpen);
		switch(this.config.sameLine.comprehensionFor) {
		case "keep":
			if(this.parsedCode.isOriginalNewlineBefore(token)) {
				this.lineEndBefore(token);
			}
			this.markBodyAfterPOpen(token,this.config.sameLine.comprehensionFor,false);
			if(bkClose != null && this.parsedCode.isOriginalNewlineBefore(bkClose)) {
				this.lineEndBefore(bkClose);
			}
			break;
		case "next":
			break;
		case "same":
			var origSame = false;
			if(bkClose != null) {
				origSame = this.parsedCode.isOriginalSameLine(bkOpen,bkClose);
			} else {
				var lastToken = tokentree_utils_TokenTreeCheckUtils.getLastToken(bkOpen);
				if(lastToken != null) {
					origSame = this.parsedCode.isOriginalSameLine(bkOpen,lastToken);
				}
			}
			if(origSame) {
				this.markBodyAfterPOpen(token,this.config.sameLine.comprehensionFor,false);
				if(bkClose != null) {
					this.whitespace(token,"noneBefore");
					this.whitespace(bkClose,"noneBefore");
				}
			} else {
				this.markBodyAfterPOpen(token,this.config.sameLine.forBody,false);
			}
			break;
		}
	}
	,getBodyAfterCondition: function(token) {
		var this1 = tokentree_TokenTreeAccessHelper.firstOf(tokentree_TokenTreeAccessHelper.firstOf(token,tokentree_TokenTreeDef.POpen),tokentree_TokenTreeDef.PClose);
		if(this1 != null) {
			var next = this.getNextToken(this1);
			if(next != null) {
				if(next.token.tok._hx_index != 12) {
					return next.token;
				}
			}
		}
		if(token.children == null) {
			return null;
		}
		var _g = 0;
		var _g1 = token.children;
		while(_g < _g1.length) {
			var child = _g1[_g];
			++_g;
			var _g2 = child.tok;
			switch(_g2._hx_index) {
			case 1:
				switch(_g2.k._hx_index) {
				case 36:case 37:case 38:
					return child.nextSibling;
				default:
				}
				break;
			case 2:
				if(_g2.c._hx_index == 3) {
					return child.nextSibling;
				}
				break;
			case 17:
				return child;
			case 22:
				break;
			default:
			}
		}
		return null;
	}
	,markBodyAfterPOpen: function(token,policy,includeBrOpen) {
		var body = this.getBodyAfterCondition(token);
		_hx_loop1: while(body != null) {
			var _g = body.tok;
			switch(_g._hx_index) {
			case 3:
				switch(_g.s) {
				case "else":case "elseif":case "end":
					return;
				default:
					break _hx_loop1;
				}
				break;
			case 8:
				var prev = this.getPreviousToken(body);
				if(prev != null) {
					if(!this.parsedCode.isOriginalSameLine(body,prev.token)) {
						this.applySameLinePolicy(body,policy);
						return;
					}
				}
				body = body.nextSibling;
				break;
			case 17:
				switch(tokentree_utils_TokenTreeCheckUtils.getBrOpenType(body)._hx_index) {
				case 0:
					if(includeBrOpen) {
						this.markBlockBody(body,policy);
					}
					return;
				case 1:
					break;
				case 2:
					this.applySameLinePolicy(body,policy);
					break;
				case 3:
					break;
				case 4:
					break;
				}
				body = body.nextSibling;
				break;
			default:
				break _hx_loop1;
			}
		}
		if(body == null) {
			return;
		}
		this.applySameLinePolicy(body,policy);
	}
	,markBody: function(token,policy,includeBrOpen) {
		var this1 = tokentree_TokenTreeAccessHelper.firstChild(token);
		if(this1 == null) {
			return;
		}
		if(this1.tok._hx_index == 17) {
			switch(tokentree_utils_TokenTreeCheckUtils.getBrOpenType(this1)._hx_index) {
			case 0:
				if(includeBrOpen) {
					this.markBlockBody(this1,policy);
				}
				return;
			case 1:
				break;
			case 2:
				this.applySameLinePolicy(this1,policy);
				break;
			case 3:
				break;
			case 4:
				break;
			}
			return;
		}
		this.applySameLinePolicy(this1,policy);
	}
	,markBlockBody: function(token,policy) {
		if(token == null) {
			return;
		}
		if(token.tok._hx_index != 17) {
			return;
		}
		if(token.children == null) {
			return;
		}
		if(token.getLastChild().tok._hx_index == 10) {
			if(token.children.length > 3) {
				return;
			}
		} else if(token.children.length > 2) {
			return;
		}
		this.noLineEndAfter(token);
		var _g = 0;
		var _g1 = token.children;
		while(_g < _g1.length) {
			var child = _g1[_g];
			++_g;
			if(child.tok._hx_index == 18) {
				var _g2 = this.getNextToken(child).token.tok;
				switch(_g2._hx_index) {
				case 1:
					switch(_g2.k._hx_index) {
					case 4:
						this.noLineEndAfter(child);
						break;
					case 21:
						this.noLineEndAfter(child);
						break;
					default:
					}
					break;
				case 10:
					this.whitespace(child,"noneAfter");
					break;
				case 14:
					this.whitespace(child,"noneAfter");
					break;
				default:
				}
				return;
			} else {
				var lastToken = tokentree_utils_TokenTreeCheckUtils.getLastToken(child);
				if(lastToken == null) {
					return;
				}
				this.noLineEndAfter(lastToken);
			}
		}
	}
	,applySameLinePolicyChained: function(token,previousBlockPolicy,policy) {
		if(policy == "same") {
			var prev = this.getPreviousToken(token);
			if(prev == null) {
				policy = "next";
			}
			if(prev.token.tok._hx_index != 18 && previousBlockPolicy != "same") {
				policy = "next";
			}
		}
		this.applySameLinePolicy(token,policy);
	}
	,applySameLinePolicy: function(token,policy) {
		switch(policy) {
		case "keep":
			if(this.parsedCode.isOriginalNewlineBefore(token)) {
				this.applySameLinePolicy(token,"next");
			} else {
				this.applySameLinePolicy(token,"same");
			}
			break;
		case "next":
			switch(token.tok._hx_index) {
			case 8:
				if(!this.parsedCode.isOriginalNewlineBefore(token)) {
					return;
				}
				break;
			case 15:
				if(tokentree_TokenTreeAccessHelper.matches(tokentree_TokenTreeAccessHelper.parent(token),tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdFor)) != null) {
					return;
				}
				break;
			default:
			}
			var prev = this.getPreviousToken(token);
			if(prev == null || !tokentree_utils_TokenTreeCheckUtils.isMetadata(prev.token)) {
				this.lineEndBefore(token);
				return;
			}
			if(!this.parsedCode.isOriginalNewlineBefore(token)) {
				return;
			}
			this.lineEndBefore(token);
			break;
		case "same":
			this.wrapBefore(token,true);
			var prev = this.getPreviousToken(token);
			if(prev == null) {
				this.noLineEndBefore(token);
			} else if(token.tok._hx_index == 22) {
				switch(prev.token.tok._hx_index) {
				case 1:
					break;
				case 3:
					break;
				case 6:
					this.lineEndBefore(token);
					break;
				case 10:case 12:case 17:case 18:
					break;
				case 11:case 19:
					this.whitespace(token,"noneBefore");
					break;
				default:
					this.noLineEndBefore(token);
				}
			} else {
				switch(prev.token.tok._hx_index) {
				case 11:case 19:
					this.whitespace(token,"noneBefore");
					break;
				default:
					this.noLineEndBefore(token);
				}
			}
			var lastToken = tokentree_utils_TokenTreeCheckUtils.getLastToken(token);
			if(lastToken == null) {
				return;
			}
			var next = this.getNextToken(lastToken);
			if(next == null) {
				return;
			}
			var _g = next.token.tok;
			if(_g._hx_index == 1) {
				if(_g.k._hx_index == 4) {
					this.noLineEndAfter(lastToken);
				}
			}
			return;
		}
	}
	,markDollarSameLine: function() {
		var tokens = this.parsedCode.root.filterCallback(function(token,index) {
			var _g = token.tok;
			if(_g._hx_index == 4) {
				switch(_g.s) {
				case "":case "a":case "b":case "e":case "i":case "p":case "v":
					return tokentree_FilterResult.FoundSkipSubtree;
				default:
					return tokentree_FilterResult.SkipSubtree;
				}
			} else {
				return tokentree_FilterResult.GoDeeper;
			}
		});
		var _g = 0;
		while(_g < tokens.length) {
			var this1 = tokentree_TokenTreeAccessHelper.matches(tokentree_TokenTreeAccessHelper.firstChild(tokens[_g++]),tokentree_TokenTreeDef.BrOpen);
			if(this1 == null) {
				continue;
			}
			var brClose = this.getCloseToken(this1);
			if(!this.parsedCode.isOriginalSameLine(this1,brClose)) {
				continue;
			}
			this.whitespace(this1,"none");
			var next = this.getNextToken(brClose);
			if(next != null) {
				switch(next.token.tok._hx_index) {
				case 10:case 11:case 14:
					this.whitespace(brClose,"none");
					break;
				case 12:case 15:case 16:case 18:case 19:case 20:
					break;
				default:
					this.whitespace(brClose,"onlyAfter");
				}
			} else {
				this.noLineEndAfter(brClose);
			}
			this.wrapBefore(this1,false);
			this.wrapAfter(this1,false);
			this.wrapBefore(brClose,false);
			this.wrapAfter(brClose,false);
		}
	}
	,markFunction: function(token) {
		var this1 = tokentree_TokenTreeAccessHelper.isCIdent(tokentree_TokenTreeAccessHelper.firstChild(token));
		var body = this1;
		if(this1 == null) {
			body = tokentree_TokenTreeAccessHelper.matches(tokentree_TokenTreeAccessHelper.firstChild(token),tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdNew));
		}
		var policy = this.config.sameLine.functionBody;
		if(body == null) {
			body = token;
			policy = this.config.sameLine.anonFunctionBody;
		}
		if(body == null || body.children == null) {
			return;
		}
		var this1 = tokentree_TokenTreeAccessHelper.firstOf(body,tokentree_TokenTreeDef.POpen);
		body = this1;
		if(this1 == null) {
			return;
		}
		if(this1.nextSibling == null) {
			return;
		}
		body = this1.nextSibling;
		if(body.tok._hx_index == 12) {
			body = body.nextSibling;
		}
		if(body == null) {
			return;
		}
		var _g = body.tok;
		switch(_g._hx_index) {
		case 3:
			if(_g.s == "if") {
				return;
			}
			break;
		case 8:
			return;
		case 10:
			return;
		case 17:
			return;
		default:
		}
		this.applySameLinePolicy(body,policy);
	}
	,markDoWhile: function(token) {
		this.markBody(token,this.config.sameLine.doWhileBody,false);
		var this1 = tokentree_TokenTreeAccessHelper.firstOf(token,tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdWhile));
		if(this1 == null) {
			return;
		}
		this.applySameLinePolicy(this1,this.config.sameLine.doWhile);
	}
	,markMacro: function(token) {
		var brOpen = this.getNextToken(token);
		if(brOpen == null || brOpen.token.tok._hx_index != 17) {
			return;
		}
		var brClose = this.getCloseToken(brOpen.token);
		if(this.parsedCode.isOriginalSameLine(brOpen.token,brClose)) {
			this.noLineEndAfter(brOpen.token);
			this.noLineEndBefore(brClose);
			this.noWrappingBetween(brOpen.token,brClose);
		}
	}
	,markReturn: function(token) {
		if(this.shouldReturnBeSameLine(token)) {
			this.markBody(token,this.config.sameLine.returnBodySingleLine,false);
		} else {
			this.markBody(token,this.config.sameLine.returnBody,false);
		}
	}
	,markUntyped: function(token) {
		if(tokentree_TokenTreeAccessHelper.matches(tokentree_TokenTreeAccessHelper.firstChild(token),tokentree_TokenTreeDef.BrOpen) == null) {
			return;
		}
		var parent = token.parent;
		if(parent == null || token.tok == tokentree_TokenTreeDef.Root) {
			return;
		}
		if(parent.tok._hx_index == 17) {
			switch(tokentree_utils_TokenTreeCheckUtils.getBrOpenType(parent)._hx_index) {
			case 0:
				return;
			case 1:
				return;
			case 2:
				break;
			case 3:
				break;
			case 4:
				break;
			}
		}
		this.applySameLinePolicy(token,this.config.sameLine.untypedBody);
	}
	,shouldReturnBeSameLine: function(token) {
		var lastToken = tokentree_utils_TokenTreeCheckUtils.getLastToken(token);
		if(lastToken == null) {
			return true;
		}
		if(this.isSameLineBetween(token,lastToken,false)) {
			return true;
		}
		return this.shouldReturnChildsBeSameLine(token);
	}
	,shouldReturnChildsBeSameLine: function(token) {
		if(token.children == null) {
			return true;
		}
		var _g = 0;
		var _g1 = token.children;
		while(_g < _g1.length) {
			var child = _g1[_g];
			++_g;
			var _g2 = child.tok;
			if(_g2._hx_index == 1) {
				switch(_g2.k._hx_index) {
				case 3:case 5:case 7:case 14:case 20:
					return false;
				default:
					if(!this.shouldReturnChildsBeSameLine(child)) {
						return false;
					}
				}
			} else if(!this.shouldReturnChildsBeSameLine(child)) {
				return false;
			}
		}
		return true;
	}
	,__class__: formatter_marker_MarkSameLine
});
var formatter_marker_MarkTokenText = function(config,parsedCode,indenter) {
	formatter_marker_MarkerBase.call(this,config,parsedCode,indenter);
};
formatter_marker_MarkTokenText.__name__ = true;
formatter_marker_MarkTokenText.__super__ = formatter_marker_MarkerBase;
formatter_marker_MarkTokenText.prototype = $extend(formatter_marker_MarkerBase.prototype,{
	run: function() {
		var _gthis = this;
		this.parsedCode.root.filterCallback(function(token,index) {
			var _g = token.tok;
			switch(_g._hx_index) {
			case 2:
				switch(_g.c._hx_index) {
				case 2:
					_gthis.tokenText(token,_gthis.printStringToken(token));
					break;
				case 4:
					_gthis.tokenText(token,_gthis.printEregToken(token));
					break;
				default:
					_gthis.tokenText(token,token.toString());
				}
				break;
			case 8:
				_gthis.tokenText(token,_gthis.printCommentLine(_g.s));
				break;
			default:
				_gthis.tokenText(token,token.toString());
			}
			return tokentree_FilterResult.GoDeeper;
		});
	}
	,finalRun: function() {
		var _gthis = this;
		this.parsedCode.root.filterCallback(function(token,index) {
			var _g = token.tok;
			if(_g._hx_index == 7) {
				_gthis.tokenText(token,_gthis.printComment(_g.s,token));
			}
			return tokentree_FilterResult.GoDeeper;
		});
	}
	,printStringToken: function(token) {
		var text = this.parsedCode.getString(token.pos.min,token.pos.max);
		if(!this.config.whitespace.formatStringInterpolation) {
			return text;
		}
		if(StringTools.startsWith(text,"'")) {
			var start = 0;
			var index;
			while(true) {
				index = text.indexOf("${",start);
				if(!(index >= 0)) {
					break;
				}
				if(this.isDollarEscaped(text,index)) {
					return text;
				}
				start = index + 1;
				var indexEnd = text.indexOf("}",index + 2);
				var fragment = text.substring(index + 2,indexEnd);
				if(fragment.indexOf("{") >= 0) {
					continue;
				}
				var formatted = this.formatFragment(fragment);
				start += formatted.length;
				text = HxOverrides.substr(text,0,index + 2) + formatted + HxOverrides.substr(text,indexEnd,null);
			}
		}
		return text;
	}
	,isDollarEscaped: function(text,index) {
		var escaped = false;
		while(--index >= 0) {
			if(text.charCodeAt(index) != 36) {
				return escaped;
			}
			escaped = !escaped;
		}
		return escaped;
	}
	,formatFragment: function(fragment) {
		try {
			var tokens = this.makeTokens(haxe_io_Bytes.ofString(fragment),"string interpolation");
			var stream = new tokentree_TokenStream(tokens,haxe_io_Bytes.ofString(fragment));
			var root = new tokentree_TokenTree(tokentree_TokenTreeDef.Root,"",null,-1);
			var progress = new tokentree_TokenStreamProgress(stream);
			while(progress.streamHasChanged()) if(stream.hasMore()) {
				tokentree_walk_WalkStatement.walkStatement(stream,root);
			}
			var interpolParsedCode = new formatter_codedata_ParsedCode({ fileName : "string interpolation", content : haxe_io_Bytes.ofString(fragment), tokenList : tokens, tokenTree : root, config : this.config, entryPoint : tokentree_TokenTreeEntryPoint.ExpressionLevel});
			var interpolIndenter = new formatter_marker_Indenter(this.config.indentation);
			interpolIndenter.setParsedCode(interpolParsedCode);
			var markWhitespace = new formatter_marker_MarkWhitespace(this.config,interpolParsedCode,interpolIndenter);
			new formatter_marker_MarkTokenText(this.config,interpolParsedCode,interpolIndenter).run();
			markWhitespace.run();
			var outputLineEnds = formatter_marker_MarkLineEnds.outputLineSeparator(this.config.lineEnds,interpolParsedCode);
			return StringTools.trim(new formatter_codedata_CodeLines(interpolParsedCode,interpolIndenter).print(outputLineEnds));
		} catch( _g ) {
			haxe_NativeStackTrace.lastError = _g;
		}
		return fragment;
	}
	,makeTokens: function(fragment,name) {
		var tokens = [];
		try {
			var lexer = new haxeparser_HaxeLexer(fragment,name);
			var t = lexer.token(haxeparser_HaxeLexer.tok);
			while(t.tok != haxeparser_TokenDef.Eof) {
				tokens.push(t);
				t = lexer.token(haxeparser_HaxeLexer.tok);
			}
		} catch( _g ) {
			haxe_NativeStackTrace.lastError = _g;
			var _g1 = haxe_Exception.caught(_g).unwrap();
			throw haxe_Exception.thrown("failed to make tokens " + (_g1 == null ? "null" : Std.string(_g1)));
		}
		return tokens;
	}
	,printEregToken: function(token) {
		return this.parsedCode.getString(token.pos.min,token.pos.max);
	}
	,printComment: function(text,token) {
		var lines = text.split(this.parsedCode.lineSeparator);
		var indent = this.indenter.calcIndent(token);
		var startsWithStar = lines.length >= 3;
		var _g = 1;
		var _g1 = lines.length - 1;
		while(_g < _g1) if(!new EReg("^\\s*\\*(\\s|$)","").match(lines[_g++])) {
			startsWithStar = false;
			break;
		}
		var linesNew = [];
		var _g = 0;
		while(_g < lines.length) linesNew.push(this.convertLeadingIndent(lines[_g++]));
		lines = this.removeCommentPrefix(linesNew);
		var outputLineEnds = formatter_marker_MarkLineEnds.outputLineSeparator(this.config.lineEnds,this.parsedCode);
		text = "/*" + lines[0];
		var _g = 1;
		var _g1 = lines.length;
		while(_g < _g1) {
			var index = _g++;
			text += outputLineEnds;
			var line = lines[index];
			var lineIndent = indent;
			var lastLine = index == lines.length - 1;
			if(!lastLine) {
				lineIndent = indent + 1;
			}
			if(startsWithStar) {
				lineIndent = indent;
			}
			if(!lastLine && line.length <= 0) {
				lineIndent = 0;
			}
			if(!lastLine && startsWithStar) {
				line = " " + line;
			}
			if(lastLine) {
				if(new EReg("^\\s*\\*\\s*[^\\s\\*]","").match(line)) {
					line = " " + line;
				}
				if(new EReg("^\\s*}","").match(line)) {
					line = StringTools.trim(line);
				} else {
					if(new EReg("^\\s*[^*\\s]","").match(line)) {
						lineIndent = indent + 1;
					}
					line = StringTools.rtrim(line);
					if(!StringTools.endsWith(line,"*")) {
						line += " ";
					}
				}
				if(new EReg("^\\s*$","").match(line)) {
					line = " ";
				}
			}
			text += this.indenter.makeIndentString(lineIndent) + line;
		}
		return text + "*/";
	}
	,removeCommentPrefix: function(lines) {
		var prefixReg = new EReg("^(\\s*)","");
		var prefix = null;
		var linesNew = [];
		var endIndex = lines.length - 1;
		var lastLine = lines[lines.length - 1];
		if(!new EReg("^\\s*(\\**$|\\})","").match(lastLine)) {
			endIndex = lines.length;
		}
		var _g = 1;
		var _g1 = endIndex;
		while(_g < _g1) {
			prefixReg.match(lines[_g++]);
			var linePrefix = prefixReg.matched(1);
			if(linePrefix.length <= 0) {
				continue;
			}
			if(prefix == null || prefix.length > linePrefix.length) {
				prefix = linePrefix;
			}
		}
		if(prefix != null) {
			linesNew = [];
			var startPrefix = prefix + " *";
			var _g = 0;
			while(_g < lines.length) {
				var line = lines[_g];
				++_g;
				if(StringTools.startsWith(line,startPrefix)) {
					line = HxOverrides.substr(line,startPrefix.length - 1,null);
				}
				if(StringTools.startsWith(line,prefix)) {
					line = HxOverrides.substr(line,prefix.length,null);
				}
				linesNew.push(line);
			}
			lines = linesNew;
		}
		var lastLine = lines[lines.length - 1];
		if(new EReg("^\\s*\\*\\**$","").match(lastLine)) {
			lines[lines.length - 1] = StringTools.ltrim(lastLine);
		}
		return lines;
	}
	,convertLeadingIndent: function(line) {
		var spaceIndent = StringTools.lpad(""," ",this.config.indentation.tabWidth);
		var oneIndent = this.config.indentation.character;
		var whitespaceReg = new EReg("^\\s+","");
		if(!whitespaceReg.match(line)) {
			return line;
		}
		var match = whitespaceReg.matched(0);
		if(this.config.indentation.character == "\t") {
			line = StringTools.replace(match,spaceIndent,oneIndent) + HxOverrides.substr(line,match.length,null);
		} else {
			line = StringTools.replace(match,"\t",oneIndent) + HxOverrides.substr(line,match.length,null);
		}
		return line;
	}
	,printCommentLine: function(text) {
		if(new EReg("^[/\\*\\-\\s]+","").match(text)) {
			return "//" + StringTools.rtrim(text);
		}
		if(this.config.whitespace.addLineCommentSpace) {
			return "// " + StringTools.trim(text);
		}
		return "//" + StringTools.trim(text);
	}
	,__class__: formatter_marker_MarkTokenText
});
var formatter_marker_MarkWhitespace = function(config,parsedCode,indenter) {
	formatter_marker_MarkerBase.call(this,config,parsedCode,indenter);
};
formatter_marker_MarkWhitespace.__name__ = true;
formatter_marker_MarkWhitespace.__super__ = formatter_marker_MarkerBase;
formatter_marker_MarkWhitespace.prototype = $extend(formatter_marker_MarkerBase.prototype,{
	run: function() {
		var _gthis = this;
		this.parsedCode.root.filterCallback(function(token,index) {
			var _g = token.tok;
			switch(_g._hx_index) {
			case 1:
				_gthis.markKeyword(token);
				break;
			case 2:
				var _g1 = _g.c;
				if(_g1._hx_index == 3) {
					switch(_g1.s) {
					case "is":
						_gthis.markIs(token);
						break;
					case "from":case "to":
						if(tokentree_TokenTreeAccessHelper.matches(tokentree_TokenTreeAccessHelper.parent(tokentree_TokenTreeAccessHelper.parent(token)),tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdAbstract)) != null) {
							_gthis.whitespace(token,"around");
							_gthis.wrapBefore(token,true);
						}
						_gthis.fixConstAfterConst(token);
						break;
					default:
						_gthis.fixConstAfterConst(token);
					}
				} else {
					_gthis.fixConstAfterConst(token);
				}
				break;
			case 3:
				_gthis.markSharp(token);
				break;
			case 4:
				_gthis.markDollar(token);
				break;
			case 5:
				_gthis.markUnop(token);
				break;
			case 6:
				switch(_g.op._hx_index) {
				case 1:
					if(tokentree_utils_TokenTreeCheckUtils.isImport(token.parent)) {
						_gthis.whitespace(token,"none");
					} else {
						_gthis.whitespace(token,_gthis.config.whitespace.binopPolicy);
					}
					break;
				case 3:
					if(tokentree_utils_TokenTreeCheckUtils.filterOpSub(token)) {
						var policy = formatter_config_WhitespacePolicy.remove(_gthis.config.whitespace.binopPolicy,"after");
						switch(_gthis.getPreviousToken(token).token.tok._hx_index) {
						case 15:case 19:
							policy = formatter_config_WhitespacePolicy.remove(policy,"before");
							break;
						default:
						}
						_gthis.whitespace(token,policy);
					} else {
						_gthis.whitespace(token,_gthis.config.whitespace.binopPolicy);
					}
					break;
				case 4:
					_gthis.markOpAssign(token);
					break;
				case 7:
					_gthis.markGt(token);
					break;
				case 9:
					if(tokentree_utils_TokenTreeCheckUtils.isTypeParameter(token)) {
						_gthis.whitespace(token,_gthis.config.whitespace.typeParamOpenPolicy);
					} else {
						_gthis.whitespace(token,_gthis.config.whitespace.binopPolicy);
					}
					break;
				case 21:
					_gthis.markOpSpread(token);
					break;
				case 23:
					_gthis.markIn(token);
					break;
				default:
					_gthis.whitespace(token,_gthis.config.whitespace.binopPolicy);
				}
				break;
			case 7:
				_gthis.markComment(token);
				break;
			case 8:
				_gthis.whitespace(token,"before");
				break;
			case 10:
				_gthis.markSemicolon(token);
				break;
			case 12:
				_gthis.markDblDot(token);
				break;
			case 13:
				_gthis.markArrow(token);
				break;
			case 14:
				_gthis.whitespace(token,_gthis.config.whitespace.commaPolicy);
				break;
			case 15:
				_gthis.successiveParenthesis(token,false,_gthis.config.whitespace.openingBracketPolicy,_gthis.config.whitespace.compressSuccessiveParenthesis);
				break;
			case 16:
				_gthis.successiveParenthesis(token,true,_gthis.config.whitespace.closingBracketPolicy,_gthis.config.whitespace.compressSuccessiveParenthesis);
				break;
			case 17:
				_gthis.markBrOpen(token);
				break;
			case 18:
				_gthis.markBrClose(token);
				break;
			case 19:
				_gthis.markPOpen(token);
				break;
			case 20:
				_gthis.markPClose(token);
				break;
			case 21:
				if(tokentree_utils_TokenTreeCheckUtils.isTernary(token)) {
					_gthis.whitespace(token,_gthis.config.whitespace.ternaryPolicy);
				} else {
					_gthis.whitespace(token,"noneAfter");
				}
				break;
			case 22:
				_gthis.markAt(token);
				break;
			default:
			}
			return tokentree_FilterResult.GoDeeper;
		});
	}
	,markOpSpread: function(token) {
		var prev = this.getPreviousToken(token);
		var policy = this.config.whitespace.intervalPolicy;
		if(prev != null) {
			policy = prev.token.tok._hx_index == 14 ? formatter_config_WhitespacePolicy.add(this.config.whitespace.intervalPolicy,"before") : this.config.whitespace.intervalPolicy;
		}
		this.whitespace(token,policy);
	}
	,markGt: function(token) {
		if(tokentree_utils_TokenTreeCheckUtils.isOpGtTypedefExtension(token)) {
			this.whitespace(token,this.config.whitespace.typeExtensionPolicy);
			return;
		}
		if(tokentree_utils_TokenTreeCheckUtils.isTypeParameter(token)) {
			var policy = this.config.whitespace.typeParamClosePolicy;
			var next = this.getNextToken(token);
			if(next != null) {
				var _g = next.token.tok;
				switch(_g._hx_index) {
				case 1:
					policy = formatter_config_WhitespacePolicy.add(policy,"after");
					break;
				case 6:
					if(_g.op._hx_index == 7) {
						policy = formatter_config_WhitespacePolicy.remove(policy,"after");
					}
					break;
				case 10:case 14:
					policy = formatter_config_WhitespacePolicy.remove(policy,"after");
					break;
				case 18:case 20:
					policy = formatter_config_WhitespacePolicy.remove(policy,"after");
					break;
				default:
				}
			}
			this.whitespace(token,policy);
		} else {
			this.whitespace(token,this.config.whitespace.binopPolicy);
		}
	}
	,fixConstAfterConst: function(token) {
		var next = this.getNextToken(token);
		if(next != null) {
			switch(next.token.tok._hx_index) {
			case 1:
				this.whitespace(token,"after");
				break;
			case 2:
				this.whitespace(token,"after");
				break;
			default:
			}
		}
	}
	,successiveParenthesis: function(token,closing,policy,compress) {
		var next = this.getNextToken(token);
		if(next != null) {
			var _g = next.token.tok;
			switch(_g._hx_index) {
			case 1:
				if(closing) {
					policy = formatter_config_WhitespacePolicy.add(policy,"after");
				}
				break;
			case 6:
				switch(_g.op._hx_index) {
				case 7:
					if(token.tok._hx_index == 18) {
						policy = formatter_config_WhitespacePolicy.remove(policy,"after");
					}
					break;
				case 22:
					policy = formatter_config_WhitespacePolicy.add(policy,"after");
					break;
				default:
				}
				break;
			case 10:case 11:case 12:case 14:
				policy = formatter_config_WhitespacePolicy.remove(policy,"after");
				break;
			default:
			}
		}
		if(!compress) {
			this.whitespace(token,policy);
			return;
		}
		if(closing) {
			if(next != null) {
				var _g = next.token.tok;
				switch(_g._hx_index) {
				case 6:
					if(_g.op._hx_index == 7) {
						if(tokentree_utils_TokenTreeCheckUtils.isTypeParameter(next.token)) {
							policy = formatter_config_WhitespacePolicy.remove(policy,"after");
						}
					}
					break;
				case 18:
					policy = formatter_config_WhitespacePolicy.remove(policy,"after");
					break;
				case 15:case 16:case 17:case 19:case 20:
					if(token.tok._hx_index == 20) {
						switch(tokentree_utils_TokenTreeCheckUtils.getPOpenType(token.parent)._hx_index) {
						case 1:
							policy = formatter_config_WhitespacePolicy.add(policy,"after");
							break;
						case 0:case 2:case 9:
							policy = formatter_config_WhitespacePolicy.remove(policy,"after");
							break;
						case 3:case 4:case 5:case 6:case 7:
							policy = formatter_config_WhitespacePolicy.add(policy,"after");
							break;
						case 8:
							policy = formatter_config_WhitespacePolicy.add(policy,"after");
							break;
						}
					} else {
						policy = formatter_config_WhitespacePolicy.remove(policy,"after");
					}
					break;
				default:
				}
			}
		} else {
			var prev = this.getPreviousToken(token);
			if(prev != null) {
				var _g = prev.token.tok;
				switch(_g._hx_index) {
				case 6:
					switch(_g.op._hx_index) {
					case 9:
						if(token.tok._hx_index == 17) {
							return;
						}
						break;
					case 21:
						policy = formatter_config_WhitespacePolicy.remove(policy,"before");
						break;
					default:
					}
					break;
				case 9:
					policy = formatter_config_WhitespacePolicy.remove(policy,"before");
					break;
				case 12:
					switch(prev.whitespaceAfter._hx_index) {
					case 0:
						policy = formatter_config_WhitespacePolicy.remove(policy,"before");
						break;
					case 1:
						policy = formatter_config_WhitespacePolicy.add(policy,"before");
						break;
					case 2:
						break;
					}
					break;
				case 13:
					return;
				case 14:
					var _g = this.config.whitespace.commaPolicy;
					if(_g != null) {
						switch(_g) {
						case "after":case "around":case "onlyAfter":
							policy = formatter_config_WhitespacePolicy.add(policy,"before");
							break;
						default:
						}
					}
					break;
				case 15:case 17:case 19:
					policy = formatter_config_WhitespacePolicy.remove(policy,"before");
					break;
				case 20:
					switch(tokentree_utils_TokenTreeCheckUtils.getPOpenType(prev.token)._hx_index) {
					case 3:case 4:case 5:case 6:case 7:
						policy = formatter_config_WhitespacePolicy.add(policy,"before");
						break;
					default:
					}
					break;
				default:
				}
			}
		}
		this.whitespace(token,policy);
	}
	,markKeyword: function(token) {
		var prev = this.getPreviousToken(token);
		if(prev != null) {
			switch(prev.token.tok._hx_index) {
			case 2:
				prev.whitespaceAfter = formatter_codedata_WhitespaceAfterType.Space;
				break;
			case 20:
				prev.whitespaceAfter = formatter_codedata_WhitespaceAfterType.Space;
				break;
			case 22:
				return;
			default:
			}
		}
		var _g = token.tok;
		if(_g._hx_index == 1) {
			switch(_g.k._hx_index) {
			case 3:
				this.whitespace(token,this.config.whitespace.ifPolicy);
				break;
			case 4:
				this.whitespace(token,formatter_config_WhitespacePolicy.add(this.config.whitespace.ifPolicy,"after"));
				break;
			case 5:
				this.whitespace(token,this.config.whitespace.whilePolicy);
				break;
			case 6:
				this.whitespace(token,this.config.whitespace.doPolicy);
				break;
			case 7:
				this.whitespace(token,this.config.whitespace.forPolicy);
				break;
			case 9:case 16:case 23:case 36:case 37:case 38:
				var next = this.getNextToken(token);
				if(next != null) {
					var _g = next.token.tok;
					switch(_g._hx_index) {
					case 1:
						this.whitespace(token,"after");
						return;
					case 2:
						if(_g.c._hx_index == 3) {
							this.whitespace(token,"after");
							return;
						}
						break;
					case 21:
						this.whitespace(token,"after");
						return;
					default:
					}
				}
				this.whitespace(token,"noneAfter");
				break;
			case 10:
				this.whitespace(token,"after");
				break;
			case 11:case 12:
				this.whitespace(token,"around");
				break;
			case 14:
				this.whitespace(token,this.config.whitespace.switchPolicy);
				break;
			case 20:
				this.whitespace(token,this.config.whitespace.tryPolicy);
				break;
			case 21:
				this.whitespace(token,this.config.whitespace.catchPolicy);
				break;
			case 28:
				this.whitespace(token,"after");
				break;
			default:
				var next = this.getNextToken(token);
				if(next != null) {
					switch(next.token.tok._hx_index) {
					case 11:
						return;
					case 19:
						return;
					default:
					}
				}
				this.whitespace(token,"after");
			}
		}
	}
	,markIs: function(token) {
		var prev = this.getPreviousToken(token);
		var policy = "around";
		if(prev != null) {
			switch(prev.token.tok._hx_index) {
			case 11:case 19:
				policy = formatter_config_WhitespacePolicy.remove(policy,"before");
				break;
			default:
			}
		}
		this.whitespace(token,policy);
	}
	,markIn: function(token) {
		if(!tokentree_utils_TokenTreeCheckUtils.hasAtParent(token)) {
			this.whitespace(token,"around");
			return;
		}
		var policy = "after";
		if(token.hasChildren()) {
			policy = "none";
		}
		this.whitespace(token,policy);
	}
	,markOpAssign: function(token) {
		var prev = this.getPreviousToken(token);
		if(prev == null) {
			this.whitespace(token,this.config.whitespace.binopPolicy);
			return;
		}
		var policy = this.config.whitespace.binopPolicy;
		var _g = prev.token.tok;
		if(_g._hx_index == 6) {
			switch(_g.op._hx_index) {
			case 14:case 15:
				prev.whitespaceAfter = formatter_codedata_WhitespaceAfterType.None;
				policy = formatter_config_WhitespacePolicy.remove(policy,"before");
				break;
			default:
			}
		}
		this.whitespace(token,policy);
	}
	,markUnop: function(token) {
		var next = this.getNextToken(token);
		if(next != null) {
			switch(next.token.tok._hx_index) {
			case 10:case 14:
				return;
			case 11:
				var _g = token.tok;
				if(_g._hx_index == 5) {
					if(_g.op._hx_index == 2) {
						this.whitespace(token,"none");
						return;
					}
				}
				break;
			case 16:case 18:case 20:
				return;
			default:
			}
		}
		var prev = this.getPreviousToken(token);
		if(prev == null) {
			return;
		}
		var _g = prev.token.tok;
		if(_g._hx_index == 2) {
			if(_g.c._hx_index == 3) {
				var _g = token.tok;
				if(_g._hx_index == 5) {
					switch(_g.op._hx_index) {
					case 2:case 3:case 4:
						return;
					default:
					}
				}
				this.whitespace(token,"after");
			}
		}
	}
	,markDollar: function(token) {
		var next = this.getNextToken(token);
		if(next == null) {
			return;
		}
		switch(next.token.tok._hx_index) {
		case 1:
			this.whitespace(token,"after");
			break;
		case 2:
			this.whitespace(token,"after");
			break;
		default:
		}
	}
	,markDblDot: function(token) {
		var type = tokentree_utils_TokenTreeCheckUtils.getColonType(token);
		if(type == null) {
			type = tokentree_utils_ColonType.Unknown;
		}
		var policy = this.config.whitespace.colonPolicy;
		switch(type._hx_index) {
		case 0:
			policy = this.config.whitespace.caseColonPolicy;
			break;
		case 1:
			policy = this.config.whitespace.typeHintColonPolicy;
			break;
		case 2:
			policy = this.config.whitespace.typeCheckColonPolicy;
			break;
		case 3:
			policy = this.config.whitespace.ternaryPolicy;
			break;
		case 4:
			policy = this.config.whitespace.objectFieldColonPolicy;
			break;
		case 5:
			this.whitespace(token,"none");
			return;
		case 6:
			policy = this.config.whitespace.colonPolicy;
			break;
		}
		policy = this.correctDblDotSharp(token,policy);
		this.whitespace(token,policy);
	}
	,correctDblDotSharp: function(token,policy) {
		var prev = this.getPreviousToken(token);
		if(prev == null) {
			return policy;
		}
		var _g = prev.token.tok;
		switch(_g._hx_index) {
		case 2:
			if(prev.token.parent == null) {
				return policy;
			}
			var _g1 = prev.token.parent.tok;
			if(_g1._hx_index == 3) {
				if(_g1.s == "if") {
					if(prev.token.parent.getFirstChild().index == prev.token.index) {
						policy = formatter_config_WhitespacePolicy.add(policy,"before");
					}
				}
			}
			break;
		case 3:
			if(_g.s != "end") {
				policy = formatter_config_WhitespacePolicy.add(policy,"before");
			}
			break;
		case 20:
			if(prev.token.parent == null) {
				return policy;
			}
			var _g = prev.token.parent.tok;
			if(_g._hx_index == 3) {
				if(_g.s == "if") {
					if(prev.token.parent.getFirstChild().index == prev.token.index) {
						policy = formatter_config_WhitespacePolicy.add(policy,"before");
					}
				}
			}
			break;
		default:
		}
		return policy;
	}
	,markSemicolon: function(token) {
		var next = this.getNextToken(token);
		var policy = this.config.whitespace.semicolonPolicy;
		if(next != null) {
			if(next.token.tok._hx_index == 18) {
				policy = formatter_config_WhitespacePolicy.remove(policy,"after");
			}
		}
		this.whitespace(token,policy);
	}
	,markSharp: function(token) {
		var _g = token.tok;
		if(_g._hx_index == 3) {
			switch(_g.s) {
			case "else":
				this.whitespace(token,"around");
				break;
			case "elseif":
				this.whitespace(token,"around");
				break;
			case "end":
				var prev = this.getPreviousToken(token);
				if(prev != null) {
					switch(prev.token.tok._hx_index) {
					case 15:case 17:case 19:
						break;
					default:
						this.whitespace(token,"before");
					}
				}
				var next = this.getNextToken(token);
				if(next != null) {
					switch(next.token.tok._hx_index) {
					case 1:
						this.whitespace(token,"after");
						break;
					case 2:
						this.whitespace(token,"after");
						break;
					case 10:case 14:
						break;
					case 15:case 17:case 19:case 21:
						this.whitespace(token,"after");
						break;
					default:
					}
				}
				break;
			case "error":
				this.whitespace(token,"after");
				break;
			case "if":
				this.whitespace(token,"after");
				var prev = this.getPreviousToken(token);
				if(prev != null) {
					switch(prev.token.tok._hx_index) {
					case 1:
						this.whitespace(token,"before");
						break;
					case 2:
						this.whitespace(token,"before");
						break;
					default:
					}
				}
				if(this.getNextToken(token) != null) {
					var lastChild = tokentree_utils_TokenTreeCheckUtils.getLastToken(token.getFirstChild());
					if(lastChild != null) {
						this.whitespace(lastChild,"after");
					}
				}
				break;
			default:
			}
		}
	}
	,markArrow: function(token) {
		var arrowType = tokentree_utils_TokenTreeCheckUtils.getArrowType(token);
		if(arrowType == null) {
			arrowType = tokentree_utils_ArrowType.ArrowFunction;
		}
		switch(arrowType._hx_index) {
		case 0:
			this.whitespace(token,this.config.whitespace.arrowFunctionsPolicy);
			break;
		case 1:
			this.whitespace(token,this.config.whitespace.functionTypeHaxe3Policy);
			break;
		case 2:
			this.whitespace(token,this.config.whitespace.functionTypeHaxe4Policy);
			break;
		}
	}
	,determinePOpenPolicy: function(token) {
		var type = tokentree_utils_TokenTreeCheckUtils.getPOpenType(token);
		if(type == null) {
			type = tokentree_utils_POpenType.Expression;
		}
		switch(type._hx_index) {
		case 0:
			this.config.whitespace.parenConfig.metadataParens.openingPolicy = formatter_config_WhitespacePolicy.remove(this.config.whitespace.parenConfig.metadataParens.openingPolicy,"before");
			return this.config.whitespace.parenConfig.metadataParens;
		case 1:
			var _g = token.parent.tok;
			switch(_g._hx_index) {
			case 1:
				switch(_g.k._hx_index) {
				case 10:
					var policy = { openingPolicy : this.config.whitespace.parenConfig.anonFuncParamParens.openingPolicy, closingPolicy : this.config.whitespace.parenConfig.anonFuncParamParens.closingPolicy, removeInnerWhenEmpty : this.config.whitespace.parenConfig.anonFuncParamParens.removeInnerWhenEmpty};
					switch(policy.openingPolicy) {
					case "after":
						policy.openingPolicy = "around";
						break;
					case "around":
						break;
					case "before":
						break;
					case "none":
						policy.openingPolicy = "before";
						break;
					case "noneAfter":
						policy.openingPolicy = "onlyBefore";
						break;
					case "noneBefore":
						policy.openingPolicy = "before";
						break;
					case "onlyAfter":
						policy.openingPolicy = "around";
						break;
					case "onlyBefore":
						break;
					}
					return policy;
				case 22:
					return this.config.whitespace.parenConfig.funcParamParens;
				default:
					return this.config.whitespace.parenConfig.anonFuncParamParens;
				}
				break;
			case 2:
				if(_g.c._hx_index == 3) {
					return this.config.whitespace.parenConfig.funcParamParens;
				} else {
					return this.config.whitespace.parenConfig.anonFuncParamParens;
				}
				break;
			default:
				return this.config.whitespace.parenConfig.anonFuncParamParens;
			}
			break;
		case 2:
			return this.config.whitespace.parenConfig.callParens;
		case 3:
			if(this.config.whitespace.parenConfig.switchConditionParens != null) {
				return this.config.whitespace.parenConfig.switchConditionParens;
			}
			return this.config.whitespace.parenConfig.conditionParens;
		case 4:
			if(this.config.whitespace.parenConfig.whileConditionParens != null) {
				return this.config.whitespace.parenConfig.whileConditionParens;
			}
			return this.config.whitespace.parenConfig.conditionParens;
		case 5:
			if(this.config.whitespace.parenConfig.ifConditionParens != null) {
				return this.config.whitespace.parenConfig.ifConditionParens;
			}
			return this.config.whitespace.parenConfig.conditionParens;
		case 6:
			if(this.config.whitespace.parenConfig.sharpConditionParens != null) {
				return this.config.whitespace.parenConfig.sharpConditionParens;
			}
			return this.config.whitespace.parenConfig.conditionParens;
		case 7:
			if(this.config.whitespace.parenConfig.catchParens != null) {
				return this.config.whitespace.parenConfig.catchParens;
			}
			return this.config.whitespace.parenConfig.conditionParens;
		case 8:
			return this.config.whitespace.parenConfig.forLoopParens;
		case 9:
			return this.config.whitespace.parenConfig.expressionParens;
		}
	}
	,markPOpen: function(token) {
		var openClosePolicy = this.determinePOpenPolicy(token);
		var policy = openClosePolicy.openingPolicy;
		var prev = this.getPreviousToken(token);
		if(prev != null) {
			switch(prev.token.tok._hx_index) {
			case 5:
				policy = formatter_config_WhitespacePolicy.remove(policy,"before");
				break;
			case 6:
				if(prev.spacesAfter > 0) {
					policy = formatter_config_WhitespacePolicy.add(policy,"before");
				}
				break;
			case 7:
				if(prev.spacesAfter > 0) {
					policy = formatter_config_WhitespacePolicy.add(policy,"before");
				}
				break;
			default:
			}
		}
		if(openClosePolicy.removeInnerWhenEmpty) {
			var next = this.getNextToken(token);
			if(next != null) {
				if(next.token.tok._hx_index == 20) {
					policy = formatter_config_WhitespacePolicy.remove(policy,"after");
				}
			}
		}
		this.successiveParenthesis(token,false,policy,this.config.whitespace.compressSuccessiveParenthesis);
	}
	,markPClose: function(token) {
		var openClosePolicy = this.determinePOpenPolicy(token.parent);
		var policy = openClosePolicy.closingPolicy;
		if(openClosePolicy.removeInnerWhenEmpty) {
			var prev = this.getPreviousToken(token);
			if(prev != null) {
				if(prev.token.tok._hx_index == 19) {
					policy = formatter_config_WhitespacePolicy.remove(policy,"before");
				}
			}
		}
		this.successiveParenthesis(token,true,policy,this.config.whitespace.compressSuccessiveParenthesis);
	}
	,determineBrOpenPolicy: function(token) {
		var type = tokentree_utils_TokenTreeCheckUtils.getBrOpenType(token);
		if(type == null) {
			type = tokentree_utils_BrOpenType.Unknown;
		}
		switch(type._hx_index) {
		case 0:
			return this.config.whitespace.bracesConfig.blockBraces;
		case 1:
			return this.config.whitespace.bracesConfig.typedefBraces;
		case 2:
			return this.config.whitespace.bracesConfig.objectLiteralBraces;
		case 3:
			return this.config.whitespace.bracesConfig.anonTypeBraces;
		case 4:
			return this.config.whitespace.bracesConfig.unknownBraces;
		}
	}
	,markBrOpen: function(token) {
		var openClosePolicy = this.determineBrOpenPolicy(token);
		var policy = openClosePolicy.openingPolicy;
		if(openClosePolicy.removeInnerWhenEmpty) {
			var next = this.getNextToken(token);
			if(next != null) {
				if(next.token.tok._hx_index == 18) {
					policy = formatter_config_WhitespacePolicy.remove(policy,"after");
				}
			}
		}
		this.successiveParenthesis(token,false,policy,this.config.whitespace.compressSuccessiveParenthesis);
	}
	,markBrClose: function(token) {
		var openClosePolicy = this.determineBrOpenPolicy(token.parent);
		var policy = openClosePolicy.closingPolicy;
		if(openClosePolicy.removeInnerWhenEmpty) {
			var prev = this.getPreviousToken(token);
			if(prev != null) {
				if(prev.token.tok._hx_index == 17) {
					policy = formatter_config_WhitespacePolicy.remove(policy,"before");
				}
			}
		}
		this.successiveParenthesis(token,true,policy,this.config.whitespace.compressSuccessiveParenthesis);
	}
	,markComment: function(token) {
		var policy = "around";
		var prev = this.getPreviousToken(token);
		if(prev != null) {
			var _g = prev.token.tok;
			switch(_g._hx_index) {
			case 6:
				if(_g.op._hx_index == 9) {
					if(tokentree_utils_TokenTreeCheckUtils.isTypeParameter(prev.token)) {
						policy = formatter_config_WhitespacePolicy.remove(policy,"before");
					}
				}
				break;
			case 15:case 17:case 19:
				policy = formatter_config_WhitespacePolicy.remove(policy,"before");
				break;
			default:
			}
		}
		var next = this.getNextToken(token);
		if(next != null) {
			switch(next.token.tok._hx_index) {
			case 14:
				policy = formatter_config_WhitespacePolicy.remove(policy,"after");
				break;
			case 16:case 18:case 20:
				policy = formatter_config_WhitespacePolicy.remove(policy,"after");
				break;
			default:
			}
		}
		this.whitespace(token,policy);
	}
	,markAt: function(token) {
		var prev = this.getPreviousToken(token);
		if(prev == null) {
			return;
		}
		switch(prev.whitespaceAfter._hx_index) {
		case 0:
			break;
		case 1:case 2:
			return;
		}
		var _g = prev.token.tok;
		switch(_g._hx_index) {
		case 0:
			return;
		case 1:
			break;
		case 2:
			break;
		case 3:
			break;
		case 4:
			break;
		case 5:
			break;
		case 6:
			if(_g.op._hx_index == 9) {
				if(tokentree_utils_TokenTreeCheckUtils.isTypeParameter(prev.token)) {
					return;
				}
			}
			break;
		case 7:
			return;
		case 8:
			return;
		case 9:
			break;
		case 10:
			return;
		case 11:
			break;
		case 12:
			break;
		case 13:
			break;
		case 14:
			break;
		case 16:
			break;
		case 18:
			break;
		case 15:case 17:case 19:
			return;
		case 20:
			break;
		case 21:
			break;
		case 22:
			break;
		case 23:
			return;
		}
		this.whitespace(token,"before");
	}
	,__class__: formatter_marker_MarkWhitespace
});
var formatter_marker_wrapping_MarkWrappingBase = function(config,parsedCode,indenter) {
	formatter_marker_MarkerBase.call(this,config,parsedCode,indenter);
	this.wrappingQueue = [];
};
formatter_marker_wrapping_MarkWrappingBase.__name__ = true;
formatter_marker_wrapping_MarkWrappingBase.__super__ = formatter_marker_MarkerBase;
formatter_marker_wrapping_MarkWrappingBase.prototype = $extend(formatter_marker_MarkerBase.prototype,{
	noWrap: function(open,close) {
		var this1 = tokentree_TokenTreeAccessHelper.matches(tokentree_TokenTreeAccessHelper.parent(tokentree_TokenTreeAccessHelper.matches(open,tokentree_TokenTreeDef.BrOpen)),tokentree_TokenTreeDef.DblDot);
		if(this1 != null) {
			switch(tokentree_utils_TokenTreeCheckUtils.getColonType(this1)._hx_index) {
			case 0:
				break;
			case 1:
				break;
			case 2:
				break;
			case 3:
				break;
			case 4:
				this.noLineEndBefore(open);
				break;
			case 5:
				break;
			case 6:
				break;
			}
		}
		this.noWrappingBetween(open,close);
		var _g = 0;
		var _g1 = open.children;
		_hx_loop1: while(_g < _g1.length) {
			var child = _g1[_g];
			++_g;
			var _g2 = child.tok;
			switch(_g2._hx_index) {
			case 6:
				if(_g2.op._hx_index == 7) {
					continue;
				}
				break;
			case 10:case 14:
				continue;
			case 16:case 18:case 20:
				break _hx_loop1;
			default:
			}
			var lastChild = tokentree_utils_TokenTreeCheckUtils.getLastToken(child);
			if(lastChild == null) {
				continue;
			} else {
				switch(lastChild.tok._hx_index) {
				case 10:case 14:
					this.noLineEndAfter(lastChild);
					break;
				default:
				}
			}
		}
		this.noLineEndBefore(close);
	}
	,keep2: function(open,close,items,addIndent,location) {
		var tokens = [];
		var _g = [];
		var _g1 = 0;
		while(_g1 < items.length) _g.push(items[_g1++].last);
		tokens = _g;
		if(items.length > 0) {
			_g.unshift(items[0].first);
		}
		var _g1 = [];
		var _g2 = 0;
		while(_g2 < items.length) _g1.push(items[_g2++].first);
		tokens = _g.concat(_g1);
		if(close != null) {
			tokens.push(close);
		}
		tokens.push(close);
		var _g = 0;
		while(_g < tokens.length) {
			var token = tokens[_g];
			++_g;
			if(this.parsedCode.isOriginalNewlineBefore(token)) {
				this.lineEndBefore(token);
				this.additionalIndent(token,addIndent);
			} else {
				this.noLineEndBefore(token);
				this.wrapBefore(token,false);
			}
		}
	}
	,keep: function(open,close,addIndent) {
		this.noWrappingBetween(open,close);
		var _g = 0;
		var _g1 = open.children;
		while(_g < _g1.length) {
			var child = _g1[_g];
			++_g;
			var last = false;
			var _g2 = child.tok;
			switch(_g2._hx_index) {
			case 6:
				if(_g2.op._hx_index == 7) {
					continue;
				}
				break;
			case 10:case 14:
				continue;
			case 16:case 18:case 20:
				last = true;
				break;
			default:
			}
			if(this.parsedCode.isOriginalNewlineBefore(child)) {
				this.lineEndBefore(child);
				this.additionalIndent(child,addIndent);
			} else {
				this.noLineEndBefore(child);
				this.wrapBefore(child,false);
			}
			if(last) {
				break;
			}
		}
		if(!this.parsedCode.isOriginalNewlineBefore(open)) {
			this.noLineEndBefore(open);
		}
	}
	,wrapChildOneLineEach2: function(open,close,items,addIndent,location,keepFirst) {
		if(keepFirst == null) {
			keepFirst = false;
		}
		if(addIndent == null) {
			addIndent = 0;
		}
		if(items.length <= 0) {
			return;
		}
		switch(location) {
		case "afterLast":
			var _g = 0;
			while(_g < items.length) {
				var item = items[_g];
				++_g;
				this.additionalIndent(item.first,addIndent);
				this.lineEndBefore(item.first);
				if(item.last.tok._hx_index == 3) {
					this.lineEndBefore(item.last);
				}
			}
			break;
		case "beforeLast":
			var item = items[0];
			this.additionalIndent(item.first,addIndent);
			this.lineEndBefore(item.first);
			item = items.pop();
			var _g = 0;
			while(_g < items.length) {
				var it = items[_g];
				++_g;
				this.additionalIndent(it.last,addIndent);
				this.lineEndBefore(it.last);
			}
			items.push(item);
			break;
		}
		if(keepFirst) {
			if(open != null) {
				this.noLineEndAfter(open);
			}
			var lastToken = items[items.length - 1].last;
			if(lastToken.tok._hx_index != 10) {
				var next = this.getNextToken(lastToken);
				if(next == null) {
					this.noLineEndAfter(lastToken);
					return;
				}
				var _g = next.token.tok;
				switch(_g._hx_index) {
				case 1:
					switch(_g.k._hx_index) {
					case 22:case 23:case 36:
						this.noLineEndAfter(lastToken);
						break;
					default:
					}
					break;
				case 10:
					break;
				default:
					this.noLineEndAfter(lastToken);
				}
			}
		} else {
			var lastToken = items[items.length - 1].last;
			var next = this.getNextToken(lastToken);
			if(next == null) {
				this.lineEndAfter(lastToken);
				return;
			}
			var _g = next.token.tok;
			switch(_g._hx_index) {
			case 1:
				switch(_g.k._hx_index) {
				case 22:case 23:case 36:
					this.lineEndAfter(lastToken);
					break;
				default:
				}
				break;
			case 10:
				break;
			case 14:
				break;
			case 15:case 17:case 19:
				break;
			default:
				this.lineEndAfter(lastToken);
			}
		}
	}
	,wrapChildOneLineEach: function(open,close,addIndent,keepFirst) {
		if(keepFirst == null) {
			keepFirst = false;
		}
		if(addIndent == null) {
			addIndent = 0;
		}
		if(!keepFirst) {
			this.lineEndAfter(open);
		}
		var _g = 0;
		var _g1 = open.children;
		while(_g < _g1.length) {
			var child = _g1[_g];
			++_g;
			var _g2 = child.tok;
			switch(_g2._hx_index) {
			case 3:
				this.wrapChildOneLineEachSharp(child,addIndent,keepFirst);
				break;
			case 6:
				if(_g2.op._hx_index == 7) {
					if(keepFirst) {
						this.noLineEndBefore(child);
					}
					return;
				} else {
					this.additionalIndent(child,addIndent);
				}
				break;
			case 8:
				var prev = this.getPreviousToken(child);
				if(prev != null) {
					if(this.parsedCode.isOriginalSameLine(child,prev.token)) {
						this.noLineEndBefore(child);
					}
				}
				this.lineEndAfter(child);
				this.additionalIndent(child,addIndent);
				continue;
			case 16:case 18:case 20:
				if(keepFirst) {
					this.noLineEndBefore(child);
				}
				return;
			default:
				this.additionalIndent(child,addIndent);
			}
			var lastChild = tokentree_utils_TokenTreeCheckUtils.getLastToken(child);
			if(lastChild == null) {
				this.lineEndAfter(child);
			} else {
				this.lineEndAfter(lastChild);
			}
		}
		if(close == null) {
			return;
		}
		switch(close.tok._hx_index) {
		case 16:case 18:case 20:
			this.lineEndBefore(close);
			break;
		default:
		}
	}
	,wrapChildOneLineEachSharp: function(sharp,addIndent,keepFirst) {
		if(keepFirst == null) {
			keepFirst = false;
		}
		if(addIndent == null) {
			addIndent = 0;
		}
		var children = sharp.children;
		var skipFirst = false;
		this.lineEndBefore(sharp);
		var _g = sharp.tok;
		if(_g._hx_index == 3) {
			switch(_g.s) {
			case "else":
				this.lineEndAfter(sharp);
				break;
			case "elseif":
				this.lineEndAfter(tokentree_utils_TokenTreeCheckUtils.getLastToken(sharp.getFirstChild()));
				skipFirst = true;
				break;
			case "end":
				this.lineEndAfter(sharp);
				return;
			case "if":
				this.lineEndAfter(tokentree_utils_TokenTreeCheckUtils.getLastToken(sharp.getFirstChild()));
				skipFirst = true;
				break;
			default:
			}
		}
		var _g = 0;
		while(_g < children.length) {
			var child = children[_g];
			++_g;
			if(skipFirst) {
				skipFirst = false;
				continue;
			}
			var _g1 = child.tok;
			switch(_g1._hx_index) {
			case 3:
				this.wrapChildOneLineEachSharp(child,addIndent,keepFirst);
				break;
			case 6:
				if(_g1.op._hx_index == 7) {
					if(keepFirst) {
						this.whitespace(child,"noneBefore");
					}
					return;
				} else {
					this.additionalIndent(child,addIndent);
				}
				break;
			case 8:
				var prev = this.getPreviousToken(child);
				if(prev != null) {
					if(this.parsedCode.isOriginalSameLine(child,prev.token)) {
						this.noLineEndBefore(child);
					}
				}
				this.lineEndAfter(child);
				this.additionalIndent(child,addIndent);
				continue;
			case 16:case 18:case 20:
				if(keepFirst) {
					this.whitespace(child,"noneBefore");
				}
				return;
			default:
				this.additionalIndent(child,addIndent);
			}
		}
	}
	,wrapFillLine2AfterLast: function(open,close,items,maxLineLength,addIndent,useTrailing) {
		if(useTrailing == null) {
			useTrailing = false;
		}
		if(addIndent == null) {
			addIndent = 0;
		}
		if(items.length <= 0) {
			return;
		}
		var lineStart = open;
		if(open == null) {
			lineStart = items[0].first;
		}
		lineStart = this.findLineStartToken(lineStart);
		if(lineStart == null) {
			return;
		}
		var indent = this.indenter.calcIndent(lineStart);
		var lineLength = this.calcLineLengthBefore(open) + this.indenter.calcAbsoluteIndent(indent) + this.calcTokenLength(open);
		var _g = 0;
		while(_g < items.length) {
			var item = items[_g];
			++_g;
			var tokenLength = item.firstLineLength;
			if(lineLength + tokenLength >= maxLineLength) {
				this.lineEndBefore(item.first);
				this.additionalIndent(item.first,addIndent);
				lineLength = this.indenter.calcAbsoluteIndent(indent + 1 + addIndent);
				if(item.multiline) {
					lineLength = item.lastLineLength;
				} else {
					lineLength += item.firstLineLength;
				}
				continue;
			} else {
				this.noLineEndBefore(item.first);
				lineLength += tokenLength;
				if(item.multiline) {
					lineLength = item.lastLineLength;
				}
			}
		}
		if(useTrailing) {
			var lastItem = items[items.length - 1];
			if(lineLength + this.calcLineLengthAfter(lastItem.last) >= maxLineLength) {
				this.lineEndBefore(lastItem.first);
				this.additionalIndent(lastItem.first,addIndent);
			}
		}
		this.noLineEndAfter(open);
		this.wrapAfter(open,false);
	}
	,wrapFillLineWithLeading2AfterLast: function(open,close,items,maxLineLength,addIndent) {
		if(addIndent == null) {
			addIndent = 0;
		}
		if(items.length <= 0) {
			return;
		}
		var lineStart = open;
		if(open == null) {
			lineStart = items[0].first;
		}
		lineStart = this.findLineStartToken(lineStart);
		if(lineStart == null) {
			return;
		}
		var indent = this.indenter.calcIndent(lineStart);
		var lineLength = this.indenter.calcAbsoluteIndent(indent + 1 + addIndent);
		var first = true;
		var _g = 0;
		while(_g < items.length) {
			var item = items[_g];
			++_g;
			var tokenLength = item.firstLineLength;
			if(lineLength + tokenLength >= maxLineLength) {
				this.lineEndBefore(item.first);
				this.additionalIndent(item.first,addIndent);
				lineLength = this.indenter.calcAbsoluteIndent(indent + 1 + addIndent);
				if(item.multiline) {
					lineLength = item.lastLineLength;
				} else {
					lineLength += item.firstLineLength;
				}
				continue;
			} else {
				if(!first) {
					this.noLineEndBefore(item.first);
				} else {
					this.lineEndBefore(item.first);
				}
				lineLength += tokenLength;
				first = false;
				if(item.multiline) {
					lineLength = item.lastLineLength;
				}
			}
		}
		var lastItem = items[items.length - 1];
		switch(lastItem.last.tok._hx_index) {
		case 10:
			break;
		case 12:
			break;
		case 16:case 18:case 20:
			if(this.isNewLineAfter(lastItem.last)) {
				this.lineEndAfter(lastItem.last);
			}
			break;
		default:
			this.lineEndAfter(lastItem.last);
		}
	}
	,wrapFillLine2BeforeLast: function(open,close,items,maxLineLength,addIndent,useTrailing) {
		if(useTrailing == null) {
			useTrailing = false;
		}
		if(addIndent == null) {
			addIndent = 0;
		}
		if(items.length <= 0) {
			return;
		}
		var lineStart = open;
		if(open == null) {
			lineStart = items[0].first;
		}
		lineStart = this.findLineStartToken(lineStart);
		if(lineStart == null) {
			return;
		}
		var indent = this.indenter.calcIndent(lineStart);
		var lineLength = this.calcLineLengthBefore(open) + this.indenter.calcAbsoluteIndent(indent) + this.calcTokenLength(open);
		var first = true;
		var _g = 0;
		while(_g < items.length) {
			var item = items[_g];
			++_g;
			var tokenLength = item.firstLineLength;
			if(!first && lineLength + tokenLength >= maxLineLength) {
				lineLength = this.indenter.calcAbsoluteIndent(indent + 1 + addIndent);
				var prev = this.getPreviousToken(item.first);
				if(prev != null) {
					this.lineEndBefore(prev.token);
					this.additionalIndent(prev.token,addIndent);
					lineLength += prev.text.length;
				}
				if(item.multiline) {
					lineLength += item.lastLineLength;
				} else {
					lineLength += item.firstLineLength;
				}
				continue;
			} else {
				if(first) {
					this.noLineEndBefore(item.first);
				} else {
					var prev1 = this.getPreviousToken(item.first);
					if(prev1 != null) {
						this.noLineEndBefore(prev1.token);
					}
				}
				lineLength += tokenLength;
				first = false;
				if(item.multiline) {
					lineLength = this.indenter.calcAbsoluteIndent(indent + 1 + addIndent) + item.lastLineLength;
				}
			}
		}
		if(useTrailing) {
			var lastItem = items[items.length - 1];
			var lengthAfter = this.calcLineLengthAfter(lastItem.last);
			var prev = this.getPreviousToken(lastItem.first);
			if(prev != null && lineLength + lengthAfter >= maxLineLength) {
				this.lineEndBefore(prev.token);
				this.additionalIndent(prev.token,addIndent);
			}
		}
		this.noLineEndAfter(open);
		this.wrapAfter(open,false);
	}
	,wrapFillLine: function(open,close,maxLineLength,addIndent,useTrailing) {
		if(useTrailing == null) {
			useTrailing = false;
		}
		if(addIndent == null) {
			addIndent = 0;
		}
		var lineStart = this.findLineStartToken(open);
		if(lineStart == null) {
			return;
		}
		var indent = this.indenter.calcIndent(lineStart);
		var lineLength = this.calcLineLengthBefore(open) + this.indenter.calcAbsoluteIndent(indent + addIndent);
		var first = true;
		var _g = 0;
		var _g1 = open.children;
		while(_g < _g1.length) {
			var child = _g1[_g];
			++_g;
			var _g2 = child.tok;
			switch(_g2._hx_index) {
			case 1:
				if(_g2.k._hx_index == 0) {
					continue;
				} else {
					this.additionalIndent(child,addIndent);
				}
				break;
			case 6:
				if(_g2.op._hx_index == 7) {
					this.whitespace(child,"noneBefore");
					return;
				} else {
					this.additionalIndent(child,addIndent);
				}
				break;
			case 8:
				var prev = this.getPreviousToken(child);
				if(prev != null) {
					if(this.parsedCode.isOriginalSameLine(child,prev.token)) {
						this.noLineEndBefore(child);
					}
				}
				this.lineEndAfter(child);
				this.additionalIndent(child,addIndent);
				continue;
			case 17:
				continue;
			case 16:case 18:case 20:
				this.whitespace(child,"noneBefore");
				if(useTrailing) {
					if(this.calcLineLengthAfter(child) + lineLength > maxLineLength) {
						var prev1 = child.previousSibling;
						if(prev1 == null) {
							return;
						}
						this.lineEndBefore(prev1);
						this.additionalIndent(prev1,addIndent);
					}
				}
				return;
			default:
				this.additionalIndent(child,addIndent);
			}
			var tokenLength = this.calcLength(child);
			var lastChild = tokentree_utils_TokenTreeCheckUtils.getLastToken(child);
			if(lastChild == null) {
				lastChild = child;
			}
			lineLength += tokenLength;
			if(lineLength > maxLineLength) {
				this.lineEndBefore(child);
				this.noLineEndAfter(lastChild);
				indent = this.indenter.calcIndent(child);
				lineLength = tokenLength + this.indenter.calcAbsoluteIndent(indent);
			} else {
				this.noLineEndAfter(lastChild);
			}
			if(first) {
				first = false;
				this.noLineEndBefore(child);
			}
		}
	}
	,calcLineLength: function(token) {
		var indent = this.indenter.calcIndent(token);
		return formatter_marker_MarkerBase.prototype.calcLineLength.call(this,token) + this.indenter.calcAbsoluteIndent(indent);
	}
	,hasEmptyFunctionBody: function(token) {
		if(token.getLastChild().tok._hx_index == 10) {
			return true;
		}
		var body = token.nextSibling;
		if(body == null) {
			return true;
		}
		if(body.tok._hx_index == 12) {
			body = body.nextSibling;
		}
		while(body != null && body.tok._hx_index == 22) body = body.nextSibling;
		if(body == null) {
			return true;
		}
		switch(body.tok._hx_index) {
		case 10:
			return true;
		case 17:
			var brClose = body.getFirstChild();
			if(brClose == null) {
				return false;
			}
			if(brClose.tok._hx_index == 18) {
				return true;
			} else {
				return false;
			}
			break;
		default:
			return false;
		}
	}
	,makeWrappableItems: function(token) {
		var items = [];
		var lastIndex = -1;
		var _g = 0;
		var _g1 = token.children;
		while(_g < _g1.length) {
			var child = _g1[_g];
			++_g;
			var _g2 = child.tok;
			switch(_g2._hx_index) {
			case 6:
				if(_g2.op._hx_index == 7) {
					return items;
				}
				break;
			case 16:case 18:case 20:
				return items;
			default:
			}
			if(child.index <= lastIndex) {
				continue;
			}
			var endToken = this.findItemEnd(child);
			if(endToken == null) {
				continue;
			}
			lastIndex = endToken.index;
			var sameLine = this.isSameLineBetween(child,endToken,false);
			var firstLineLength = this.calcLengthUntilNewline(child,endToken);
			if(this.isMultilineToken(endToken)) {
				sameLine = false;
			}
			var lastLineLength = 0;
			if(!sameLine) {
				lastLineLength = this.calcLineLengthAfter(endToken);
			}
			items.push({ first : child, last : endToken, multiline : !sameLine, firstLineLength : firstLineLength, lastLineLength : lastLineLength});
		}
		return items;
	}
	,findItemEnd: function(child) {
		var endToken = tokentree_utils_TokenTreeCheckUtils.getLastToken(child);
		if(endToken == null) {
			return null;
		}
		if(endToken.index == child.index) {
			switch(child.tok._hx_index) {
			case 7:
				var next = child.nextSibling;
				if(next != null) {
					return this.findItemEnd(next);
				}
				break;
			case 8:
				var next = child.nextSibling;
				if(next != null) {
					return this.findItemEnd(next);
				}
				break;
			default:
			}
		}
		if(endToken.tok._hx_index == 14) {
			var next = this.getNextToken(endToken);
			if(next == null) {
				return endToken;
			}
			switch(next.token.tok._hx_index) {
			case 7:
				if(this.parsedCode.isOriginalSameLine(endToken,next.token)) {
					return next.token;
				}
				break;
			case 8:
				if(this.parsedCode.isOriginalSameLine(endToken,next.token)) {
					return next.token;
				}
				break;
			default:
			}
			return endToken;
		}
		var next = this.getNextToken(endToken);
		if(next == null) {
			return endToken;
		}
		var _g = next.token.tok;
		switch(_g._hx_index) {
		case 6:
			if(_g.op._hx_index == 7) {
				if(tokentree_TokenTreeAccessHelper.matches(tokentree_TokenTreeAccessHelper.parent(next.token),tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpLt)) != null) {
					return endToken;
				}
				return this.findItemEnd(next.token);
			} else {
				return this.findItemEnd(next.token);
			}
			break;
		case 7:
			return this.findItemEnd(next.token);
		case 8:
			return this.findItemEnd(next.token);
		default:
		}
		return endToken;
	}
	,determineWrapType2: function(rules,token,items) {
		var itemCount = items.length;
		if(items.length <= 0) {
			return { conditions : [], type : rules.defaultWrap, location : rules.defaultLocation, additionalIndent : rules.defaultAdditionalIndent};
		}
		var maxItemLength = 0;
		var totalItemLength = 0;
		var lineLength = this.calcLineLength(token);
		var hasMultiLineItem = false;
		var _g = 0;
		while(_g < items.length) {
			var item = items[_g];
			++_g;
			totalItemLength += item.firstLineLength + item.lastLineLength;
			if(item.multiline) {
				hasMultiLineItem = true;
			}
			var length = Math.floor(Math.max(item.firstLineLength,item.lastLineLength));
			if(length > maxItemLength) {
				maxItemLength = length;
			}
		}
		var _g = 0;
		var _g1 = rules.rules;
		while(_g < _g1.length) {
			var rule = _g1[_g];
			++_g;
			if(this.matchesRule(rule,itemCount,maxItemLength,totalItemLength,lineLength,hasMultiLineItem)) {
				return rule;
			}
		}
		return { conditions : [], type : rules.defaultWrap, location : rules.defaultLocation, additionalIndent : rules.defaultAdditionalIndent};
	}
	,determineWrapType: function(rules,itemCount,maxItemLength,totalItemLength,lineLength) {
		var _g = 0;
		var _g1 = rules.rules;
		while(_g < _g1.length) {
			var rule = _g1[_g];
			++_g;
			if(this.matchesRule(rule,itemCount,maxItemLength,totalItemLength,lineLength,false)) {
				return rule;
			}
		}
		return { conditions : [], type : rules.defaultWrap, location : rules.defaultLocation, additionalIndent : rules.defaultAdditionalIndent};
	}
	,matchesRule: function(rule,itemCount,maxItemLength,totalItemLength,lineLength,hasMultiLineItem) {
		var _g = 0;
		var _g1 = rule.conditions;
		while(_g < _g1.length) {
			var cond = _g1[_g];
			++_g;
			switch(cond.cond) {
			case "anyItemLength <= n":
				if(maxItemLength > cond.value) {
					return false;
				}
				break;
			case "anyItemLength >= n":
				if(maxItemLength < cond.value) {
					return false;
				}
				break;
			case "exceedsMaxLineLength":
				if(cond.value == 1) {
					if(lineLength <= this.config.wrapping.maxLineLength) {
						return false;
					}
				} else if(lineLength > this.config.wrapping.maxLineLength) {
					return false;
				}
				break;
			case "hasMultilineItems":
				if(cond.value == 1) {
					if(!hasMultiLineItem) {
						return false;
					}
				} else if(hasMultiLineItem) {
					return false;
				}
				break;
			case "itemCount <= n":
				if(itemCount > cond.value) {
					return false;
				}
				break;
			case "itemCount >= n":
				if(itemCount < cond.value) {
					return false;
				}
				break;
			case "lineLength <= n":
				if(lineLength > cond.value) {
					return false;
				}
				break;
			case "lineLength >= n":
				if(lineLength < cond.value) {
					return false;
				}
				break;
			case "totalItemLength <= n":
				if(totalItemLength > cond.value) {
					return false;
				}
				break;
			case "totalItemLength >= n":
				if(totalItemLength < cond.value) {
					return false;
				}
				break;
			}
		}
		return true;
	}
	,applyRule: function(origin,rule,open,close,items,addIndent,useTrailing) {
		var location = "afterLast";
		if(rule.location != null) {
			location = rule.location;
		}
		switch(rule.type) {
		case "equalNumber":
			break;
		case "fillLine":
			switch(location) {
			case "afterLast":
				this.wrapFillLine2AfterLast(open,close,items,this.config.wrapping.maxLineLength,addIndent,useTrailing);
				break;
			case "beforeLast":
				this.wrapFillLine2BeforeLast(open,close,items,this.config.wrapping.maxLineLength,addIndent,useTrailing);
				break;
			}
			break;
		case "fillLineWithLeadingBreak":
			switch(location) {
			case "afterLast":
				this.wrapFillLineWithLeading2AfterLast(open,close,items,this.config.wrapping.maxLineLength,addIndent);
				break;
			case "beforeLast":
				this.wrapFillLine2BeforeLast(open,close,items,this.config.wrapping.maxLineLength,addIndent,useTrailing);
				break;
			}
			break;
		case "keep":
			this.keep2(open,close,items,addIndent,location);
			break;
		case "noWrap":
			this.noWrappingBetween(open,close,false);
			break;
		case "onePerLine":
			this.wrapChildOneLineEach2(open,close,items,addIndent,location);
			break;
		case "onePerLineAfterFirst":
			this.wrapChildOneLineEach2(open,close,items,addIndent,location,true);
			break;
		}
	}
	,applyWrappingQueue: function() {
		var _g = 0;
		var _g1 = this.wrappingQueue;
		while(_g < _g1.length) this.applyWrappingPlace(_g1[_g++]);
	}
	,applyWrappingPlace: function(place) {
		var rule = this.determineWrapType2(place.rules,place.start,place.items);
		var additionalIndent = rule.additionalIndent;
		if(place.overrideAdditionalIndent != null) {
			additionalIndent = place.overrideAdditionalIndent;
		}
		this.applyRule(place.origin,rule,place.start,place.end,place.items,additionalIndent,place.useTrailing);
	}
	,queueWrapping: function(place,name) {
		if(place.items == null || place.items.length <= 0) {
			return;
		}
		var startIndex = this.getPlaceStartIndex(place);
		var endIndex = this.getPlaceEndIndex(place);
		if(startIndex < 0 || endIndex < 0) {
			return;
		}
		var _g = 0;
		var _g1 = this.wrappingQueue.length;
		while(_g < _g1) {
			var index = _g++;
			var p = this.wrappingQueue[index];
			var itemStart = this.getPlaceStartIndex(p);
			if(startIndex > itemStart) {
				continue;
			}
			if(startIndex == itemStart) {
				if(endIndex > this.getPlaceEndIndex(p)) {
					this.wrappingQueue.splice(index,0,place);
					return;
				}
				continue;
			}
			this.wrappingQueue.splice(index,0,place);
			return;
		}
		this.wrappingQueue.push(place);
	}
	,getPlaceStartIndex: function(place) {
		if(place.items == null || place.items.length <= 0) {
			return -1;
		}
		if(place.start != null) {
			return place.start.index;
		} else {
			return place.items[0].first.index;
		}
	}
	,getPlaceEndIndex: function(place) {
		if(place.items == null || place.items.length <= 0) {
			return -1;
		}
		if(place.end != null) {
			return place.end.index;
		} else {
			return place.items[place.items.length - 1].last.index;
		}
	}
	,__class__: formatter_marker_wrapping_MarkWrappingBase
});
var formatter_marker_wrapping_MarkWrapping = function(config,parsedCode,indenter) {
	formatter_marker_wrapping_MarkWrappingBase.call(this,config,parsedCode,indenter);
};
formatter_marker_wrapping_MarkWrapping.__name__ = true;
formatter_marker_wrapping_MarkWrapping.__super__ = formatter_marker_wrapping_MarkWrappingBase;
formatter_marker_wrapping_MarkWrapping.prototype = $extend(formatter_marker_wrapping_MarkWrappingBase.prototype,{
	run: function() {
		var _gthis = this;
		var wrappableTokens = this.parsedCode.root.filterCallback(function(token,index) {
			var _g = token.tok;
			switch(_g._hx_index) {
			case 6:
				switch(_g.op._hx_index) {
				case 0:
					return tokentree_FilterResult.FoundGoDeeper;
				case 9:
					return tokentree_FilterResult.FoundGoDeeper;
				case 22:
					return tokentree_FilterResult.FoundGoDeeper;
				default:
				}
				break;
			case 8:
				return tokentree_FilterResult.FoundGoDeeper;
			case 11:
				return tokentree_FilterResult.FoundGoDeeper;
			case 13:
				return tokentree_FilterResult.FoundGoDeeper;
			case 14:
				_gthis.wrapAfter(token,true);
				return tokentree_FilterResult.GoDeeper;
			case 15:
				return tokentree_FilterResult.FoundGoDeeper;
			case 17:
				return tokentree_FilterResult.FoundGoDeeper;
			case 19:
				return tokentree_FilterResult.FoundGoDeeper;
			default:
			}
			return tokentree_FilterResult.GoDeeper;
		});
		wrappableTokens.reverse();
		var _g = 0;
		while(_g < wrappableTokens.length) {
			var token = wrappableTokens[_g];
			++_g;
			var _g1 = token.tok;
			switch(_g1._hx_index) {
			case 6:
				switch(_g1.op._hx_index) {
				case 0:
					this.wrapAfter(token,true);
					break;
				case 9:
					if(tokentree_utils_TokenTreeCheckUtils.isTypeParameter(token)) {
						this.wrapTypeParameter(token);
					}
					break;
				case 22:
					this.wrapAfter(token,true);
					break;
				default:
				}
				break;
			case 8:
				this.wrapBefore(token,false);
				break;
			case 11:
				break;
			case 13:
				this.wrapAfter(token,true);
				break;
			case 15:
				this.arrayWrapping(token);
				break;
			case 17:
				this.markBrWrapping(token);
				break;
			case 19:
				this.markPWrapping(token);
				break;
			default:
			}
		}
		this.markMethodChaining(this.parsedCode.root);
		this.markMultiVarChaining();
		this.markImplementsExtendsChaining();
		this.markOpBoolChaining();
		this.markOpAddChaining();
		this.markCasePatternChaining();
		this.applyWrappingQueue();
	}
	,wrapTypeParameter: function(token) {
		tokentree_TokenTreeAccessHelper.firstOf(token,tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpGt));
		if(token.children == null || token.children.length <= 0) {
			return;
		}
		this.queueWrapping({ origin : formatter_marker_wrapping_WrappingOrigin.TypeParameterWrapping, start : token, end : null, items : this.makeWrappableItems(token), rules : this.config.wrapping.typeParameter, useTrailing : true, overrideAdditionalIndent : null},"wrapTypeParameter");
	}
	,markBrWrapping: function(token) {
		switch(tokentree_utils_TokenTreeCheckUtils.getBrOpenType(token)._hx_index) {
		case 0:
			break;
		case 1:
			this.typedefWrapping(token);
			break;
		case 2:
			this.objectLiteralWrapping(token);
			break;
		case 3:
			this.anonTypeWrapping(token);
			break;
		case 4:
			break;
		}
	}
	,typedefWrapping: function(token) {
		var brClose = this.getCloseToken(token);
		if(this.isNewLineBefore(token)) {
			return;
		}
		if(this.parsedCode.isOriginalSameLine(token,brClose)) {
			this.noWrap(token,brClose);
			return;
		}
	}
	,anonTypeWrapping: function(token) {
		var brClose = this.getCloseToken(token);
		if(token.children == null || token.children.length <= 0) {
			return;
		}
		if(token.index + 1 == brClose.index) {
			this.whitespace(token,"noneAfter");
			this.whitespace(brClose,"noneBefore");
			return;
		}
		var next = this.getNextToken(brClose);
		if(next != null) {
			var _g = next.token.tok;
			switch(_g._hx_index) {
			case 1:
				this.lineEndAfter(brClose);
				break;
			case 2:
				var _g1 = _g.c;
				if(_g1._hx_index == 3) {
					switch(_g1.s) {
					case "from":case "to":
						this.noLineEndAfter(brClose);
						break;
					default:
						this.lineEndAfter(brClose);
					}
				} else {
					this.lineEndAfter(brClose);
				}
				break;
			case 6:
				if(_g.op._hx_index == 7) {
					this.noLineEndAfter(brClose);
				}
				break;
			case 17:
				switch(this.config.lineEnds.leftCurly) {
				case "after":case "none":
					this.noLineEndAfter(brClose);
					break;
				case "before":case "both":
					break;
				}
				break;
			default:
			}
		}
		if(!this.parsedCode.isOriginalSameLine(token,brClose)) {
			this.wrapChildOneLineEach(token,brClose,0);
			return;
		}
		this.applyWrappingPlace({ origin : formatter_marker_wrapping_WrappingOrigin.AnonTypeWrapping, start : token, end : brClose, items : this.makeWrappableItems(token), rules : this.config.wrapping.anonType, useTrailing : true, overrideAdditionalIndent : null});
	}
	,objectLiteralWrapping: function(token) {
		var brClose = this.getCloseToken(token);
		if(token.children == null || token.children.length <= 1) {
			return;
		}
		if(token.index + 1 == brClose.index) {
			this.whitespace(token,"noneAfter");
			this.whitespace(brClose,"noneBefore");
			return;
		}
		if(!this.parsedCode.isOriginalSameLine(token,brClose)) {
			this.wrapChildOneLineEach(token,brClose,0);
			return;
		}
		var maxLength = 0;
		var totalLength = 0;
		var itemCount = 0;
		var _g = 0;
		var _g1 = token.children;
		_hx_loop1: while(_g < _g1.length) {
			var child = _g1[_g];
			++_g;
			switch(child.tok._hx_index) {
			case 8:
				this.wrapChildOneLineEach(token,brClose,0);
				return;
			case 18:
				break _hx_loop1;
			default:
			}
			var length = this.calcLength(child);
			totalLength += length;
			if(length > maxLength) {
				maxLength = length;
			}
			++itemCount;
		}
		var lineLength = this.calcLineLength(token);
		var rule = this.determineWrapType(this.config.wrapping.objectLiteral,itemCount,maxLength,totalLength,lineLength);
		switch(rule.type) {
		case "equalNumber":
			break;
		case "fillLine":
			this.wrapFillLine(token,brClose,this.config.wrapping.maxLineLength,rule.additionalIndent);
			break;
		case "fillLineWithLeadingBreak":
			this.wrapFillLine(token,brClose,this.config.wrapping.maxLineLength,rule.additionalIndent);
			break;
		case "keep":
			this.keep(token,brClose,rule.additionalIndent);
			break;
		case "noWrap":
			this.noWrap(token,brClose);
			var next = this.getNextToken(brClose);
			if(next != null) {
				switch(next.token.tok._hx_index) {
				case 12:
					this.noLineEndAfter(brClose);
					break;
				case 11:case 14:
					this.whitespace(brClose,"noneAfter");
					break;
				default:
				}
			}
			var prev = this.getPreviousToken(token);
			if(prev != null) {
				switch(prev.token.tok._hx_index) {
				case 1:
					this.noLineEndBefore(token);
					this.whitespace(token,"before");
					break;
				case 6:
					this.noLineEndBefore(token);
					break;
				case 14:case 19:
					this.noLineEndBefore(token);
					break;
				default:
				}
			}
			break;
		case "onePerLine":
			this.wrapChildOneLineEach(token,brClose,rule.additionalIndent);
			break;
		case "onePerLineAfterFirst":
			this.wrapChildOneLineEach(token,brClose,rule.additionalIndent,true);
			break;
		}
	}
	,markPWrapping: function(token) {
		this.getCloseToken(token);
		switch(tokentree_utils_TokenTreeCheckUtils.getPOpenType(token)._hx_index) {
		case 0:
			this.wrapMetadataCallParameter(token);
			break;
		case 1:
			this.wrapFunctionSignature(token);
			break;
		case 2:
			this.wrapCallParameter(token);
			break;
		case 3:
			break;
		case 4:
			break;
		case 5:
			break;
		case 6:
			break;
		case 7:
			break;
		case 8:
			break;
		case 9:
			break;
		}
	}
	,arrayWrapping: function(token) {
		var bkClose = this.getCloseToken(token);
		if(token.children == null || token.children.length <= 0) {
			return;
		}
		var items = this.makeWrappableItems(token);
		var itemsWithoutMetadata = [];
		var _g = 0;
		while(_g < items.length) {
			var item = items[_g];
			++_g;
			var _g1 = item.first.tok;
			switch(_g1._hx_index) {
			case 1:
				switch(_g1.k._hx_index) {
				case 5:case 7:
					if(this.config.sameLine.comprehensionFor == "keep") {
						return;
					}
					itemsWithoutMetadata.push(item);
					break;
				default:
					itemsWithoutMetadata.push(item);
				}
				break;
			case 22:
				if(item.firstLineLength > 30) {
					this.lineEndBefore(token);
					this.lineEndBefore(item.first);
				}
				break;
			default:
				itemsWithoutMetadata.push(item);
			}
		}
		if(this.config.wrapping.arrayMatrixWrap != "noMatrixWrap") {
			if(this.tryMatrixWrap(token,bkClose,itemsWithoutMetadata)) {
				return;
			}
		}
		this.applyWrappingPlace({ origin : formatter_marker_wrapping_WrappingOrigin.ArrayWrapping, start : token, end : bkClose, items : itemsWithoutMetadata, rules : this.config.wrapping.arrayWrap, useTrailing : true, overrideAdditionalIndent : null});
	}
	,tryMatrixWrap: function(open,close,items) {
		var prev = null;
		var run = 1;
		var lineRun = 0;
		var _g = 0;
		var _g1 = items.length;
		while(_g < _g1) {
			var item = items[_g++];
			if(prev == null) {
				prev = item;
				continue;
			}
			if(item.multiline) {
				return false;
			}
			if(this.parsedCode.isOriginalSameLine(prev.first,item.first)) {
				++run;
				prev = item;
				continue;
			}
			if(lineRun != 0) {
				if(lineRun != run) {
					return false;
				}
			}
			lineRun = run;
			run = 1;
			prev = item;
		}
		if(lineRun <= 1) {
			return false;
		}
		if(lineRun != run) {
			return false;
		}
		this.lineEndAfter(open);
		if(this.config.wrapping.arrayMatrixWrap == "matrixWrapWithAlign") {
			var _g = [];
			var _g1 = 0;
			var _g2 = lineRun;
			while(_g1 < _g2) {
				++_g1;
				_g.push(0);
			}
			var _g1 = 0;
			var _g2 = items.length;
			while(_g1 < _g2) {
				var index = _g1++;
				var item = items[index];
				var col = index % lineRun;
				if(item.firstLineLength > _g[col]) {
					_g[col] = item.firstLineLength;
				}
			}
			var _g1 = 0;
			var _g2 = items.length;
			while(_g1 < _g2) {
				var index = _g1++;
				var item = items[index];
				var expectedLength = _g[index % lineRun];
				if(index == items.length - 1) {
					if(item.last.tok._hx_index == 14) {
						--expectedLength;
					} else {
						expectedLength -= 2;
					}
				}
				if(item.firstLineLength < expectedLength) {
					this.spacesBefore(item.first,expectedLength - item.firstLineLength);
				}
			}
		}
		var index = lineRun - 1;
		while(index < items.length) {
			this.lineEndAfter(items[index].last);
			index += lineRun;
		}
		return true;
	}
	,calcLineLength: function(token) {
		if(token == null) {
			return 0;
		}
		return formatter_marker_wrapping_MarkWrappingBase.prototype.calcLineLength.call(this,token);
	}
	,wrapFunctionSignature: function(token) {
		var pClose = this.getCloseToken(token);
		if(token.children == null || token.children.length <= 0) {
			return;
		}
		var rules = this.config.wrapping.functionSignature;
		var _g = token.parent.tok;
		if(_g._hx_index == 1) {
			if(_g.k._hx_index == 0) {
				rules = this.config.wrapping.anonFunctionSignature;
			}
		}
		var emptyBody = this.hasEmptyFunctionBody(token);
		var items = this.makeWrappableItems(token);
		var addIndent = null;
		if(emptyBody) {
			addIndent = 0;
		}
		this.queueWrapping({ origin : formatter_marker_wrapping_WrappingOrigin.FunctionSignatureWrapping, start : token, end : pClose, items : items, rules : rules, useTrailing : true, overrideAdditionalIndent : addIndent},"wrapFunctionSignature");
	}
	,wrapCallParameter: function(token) {
		var pClose = this.getCloseToken(token);
		if(token.children == null || token.children.length <= 0) {
			return;
		}
		this.queueWrapping({ origin : formatter_marker_wrapping_WrappingOrigin.CallParameterWrapping, start : token, end : pClose, items : this.makeWrappableItems(token), rules : this.config.wrapping.callParameter, useTrailing : true, overrideAdditionalIndent : null},"wrapCallParameter");
	}
	,wrapMetadataCallParameter: function(token) {
		var pClose = this.getCloseToken(token);
		if(token.children == null || token.children.length <= 0) {
			return;
		}
		this.queueWrapping({ origin : formatter_marker_wrapping_WrappingOrigin.MetadataCallParameterWrapping, start : token, end : pClose, items : this.makeWrappableItems(token), rules : this.config.wrapping.metadataCallParameter, useTrailing : false, overrideAdditionalIndent : null},"wrapMetadataCallParameter");
	}
	,markMethodChaining: function(startToken) {
		var _gthis = this;
		if(startToken == null) {
			return;
		}
		var chainStarts = startToken.filterCallback(function(token,index) {
			if(token.tok._hx_index == 11) {
				var prev = _gthis.getPreviousToken(token);
				_hx_loop1: while(prev != null) {
					switch(prev.token.tok._hx_index) {
					case 7:
						break;
					case 8:
						break;
					case 20:
						_gthis.wrapBefore(token,true);
						return tokentree_FilterResult.FoundSkipSubtree;
					default:
						break _hx_loop1;
					}
					prev = _gthis.getPreviousToken(prev.token);
				}
			}
			return tokentree_FilterResult.GoDeeper;
		});
		var _g = 0;
		while(_g < chainStarts.length) {
			var chainStart = chainStarts[_g];
			++_g;
			this.markInternalMethodChaining(chainStart);
			this.markSingleMethodChain(chainStart);
		}
	}
	,markInternalMethodChaining: function(startToken) {
		var _gthis = this;
		startToken.filterCallback(function(token,index) {
			switch(token.tok._hx_index) {
			case 15:case 17:case 19:
				_gthis.markMethodChaining(token);
				break;
			default:
			}
			return tokentree_FilterResult.GoDeeper;
		});
	}
	,markSingleMethodChain: function(chainStart) {
		var _gthis = this;
		var chainedCalls = chainStart.filterCallback(function(token,index) {
			switch(token.tok._hx_index) {
			case 11:
				var prev = _gthis.getPreviousToken(token);
				_hx_loop1: while(prev != null) {
					switch(prev.token.tok._hx_index) {
					case 7:
						break;
					case 8:
						break;
					case 20:
						return tokentree_FilterResult.FoundGoDeeper;
					default:
						break _hx_loop1;
					}
					prev = _gthis.getPreviousToken(prev.token);
				}
				return tokentree_FilterResult.GoDeeper;
			case 15:case 17:case 19:
				return tokentree_FilterResult.SkipSubtree;
			default:
			}
			return tokentree_FilterResult.GoDeeper;
		});
		var this1 = tokentree_TokenTreeAccessHelper.matches(tokentree_TokenTreeAccessHelper.parent(tokentree_TokenTreeAccessHelper.isCIdent(tokentree_TokenTreeAccessHelper.parent(chainStart))),tokentree_TokenTreeDef.Dot);
		if(this1 != null) {
			chainedCalls.unshift(this1);
			chainStart = this1;
		}
		var items = [];
		var chainEnd = tokentree_utils_TokenTreeCheckUtils.getLastToken(chainStart);
		var info = this.getPreviousToken(chainStart);
		var chainOpen = chainStart.parent;
		if(info != null) {
			chainOpen = info.token;
		}
		var _g = 0;
		var _g1 = chainedCalls.length;
		while(_g < _g1) {
			var index = _g++;
			var child = chainedCalls[index];
			var endToken = chainEnd;
			if(index + 1 < chainedCalls.length) {
				info = this.getPreviousToken(chainedCalls[index + 1]);
				if(info != null) {
					endToken = info.token;
				}
			}
			items.push(this.makeWrappableItem(child,endToken));
		}
		chainEnd = null;
		if(chainOpen != null) {
			chainEnd = this.getCloseToken(chainOpen);
		}
		this.queueWrapping({ origin : formatter_marker_wrapping_WrappingOrigin.MethodChainWrapping, start : chainOpen, end : chainEnd, items : items, rules : this.config.wrapping.methodChain, useTrailing : false, overrideAdditionalIndent : null},"markSingleMethodChain");
	}
	,markOpBoolChaining: function() {
		var chainStarts = this.parsedCode.root.filterCallback(function(token,index) {
			if(!token.hasChildren()) {
				return tokentree_FilterResult.SkipSubtree;
			}
			var _g = 0;
			var _g1 = token.children;
			while(_g < _g1.length) {
				var _g2 = _g1[_g++].tok;
				if(_g2._hx_index == 6) {
					switch(_g2.op._hx_index) {
					case 14:case 15:
						return tokentree_FilterResult.FoundGoDeeper;
					default:
					}
				}
			}
			return tokentree_FilterResult.GoDeeper;
		});
		var _g = 0;
		while(_g < chainStarts.length) this.markSingleOpBoolChain(chainStarts[_g++]);
	}
	,markSingleOpBoolChain: function(itemStart) {
		var items = [];
		var firstItemStart = itemStart;
		if(itemStart.tok._hx_index == 6) {
			if(itemStart.previousSibling != null) {
				firstItemStart = itemStart.previousSibling;
			}
		}
		var prev = this.getPreviousToken(firstItemStart);
		var chainStart = itemStart;
		if(prev != null) {
			chainStart = prev.token;
		}
		var chainEnd = itemStart.getLastChild();
		if(chainEnd != null) {
			chainEnd = tokentree_utils_TokenTreeCheckUtils.getLastToken(chainEnd);
			switch(chainEnd.tok._hx_index) {
			case 10:case 14:case 20:
				break;
			default:
				var next = this.getNextToken(chainEnd);
				if(next != null) {
					chainEnd = next.token;
				}
			}
		}
		var first = true;
		var _g = 0;
		var _g1 = itemStart.children;
		while(_g < _g1.length) {
			var child = _g1[_g];
			++_g;
			var _g2 = child.tok;
			if(_g2._hx_index == 6) {
				switch(_g2.op._hx_index) {
				case 14:case 15:
					if(first) {
						itemStart = firstItemStart;
						first = false;
					}
					items.push(this.makeWrappableItem(itemStart,child));
					var next = this.getNextToken(child);
					if(next == null) {
						return;
					}
					itemStart = next.token;
					break;
				default:
					continue;
				}
			} else {
				continue;
			}
		}
		items.push(this.makeWrappableItem(itemStart,tokentree_utils_TokenTreeCheckUtils.getLastToken(itemStart)));
		this.queueWrapping({ origin : formatter_marker_wrapping_WrappingOrigin.OpBoolChainWrapping, start : chainStart, end : chainEnd, items : items, rules : this.config.wrapping.opBoolChain, useTrailing : false, overrideAdditionalIndent : null},"markSingleOpBoolChain");
	}
	,markCasePatternChaining: function() {
		var chainStarts = this.parsedCode.root.filterCallback(function(token,index) {
			var _g = token.tok;
			if(_g._hx_index == 1) {
				if(_g.k._hx_index == 15) {
					return tokentree_FilterResult.FoundGoDeeper;
				} else {
					return tokentree_FilterResult.GoDeeper;
				}
			} else {
				return tokentree_FilterResult.GoDeeper;
			}
		});
		var _g = 0;
		while(_g < chainStarts.length) this.markSingleCasePatternChain(chainStarts[_g++]);
	}
	,markSingleCasePatternChain: function(itemContainer) {
		var items = [];
		var this1 = tokentree_TokenTreeAccessHelper.firstOf(itemContainer,tokentree_TokenTreeDef.DblDot);
		if(this.getNextToken(itemContainer) == null) {
			return;
		}
		var _g = 0;
		var _g1 = itemContainer.children;
		while(_g < _g1.length) {
			var child = _g1[_g];
			++_g;
			if(child.tok._hx_index == 12) {
				break;
			} else {
				items.push(this.makeWrappableItem(child,tokentree_utils_TokenTreeCheckUtils.getLastToken(child)));
			}
		}
		this.queueWrapping({ origin : formatter_marker_wrapping_WrappingOrigin.CasePatternWrapping, start : itemContainer, end : this1, items : items, rules : this.config.wrapping.casePattern, useTrailing : false, overrideAdditionalIndent : null},"markSingleCasePatternChain");
	}
	,markOpAddChaining: function() {
		var chainStarts = this.parsedCode.root.filterCallback(function(token,index) {
			if(!token.hasChildren()) {
				return tokentree_FilterResult.SkipSubtree;
			}
			var _g = 0;
			var _g1 = token.children;
			while(_g < _g1.length) {
				var _g2 = _g1[_g++].tok;
				if(_g2._hx_index == 6) {
					switch(_g2.op._hx_index) {
					case 0:case 3:
						return tokentree_FilterResult.FoundGoDeeper;
					default:
					}
				}
			}
			return tokentree_FilterResult.GoDeeper;
		});
		var _g = 0;
		while(_g < chainStarts.length) this.markSingleOpAddChain(chainStarts[_g++]);
	}
	,markSingleOpAddChain: function(itemContainer) {
		var items = [];
		this.getPreviousToken(this.findOpAddItemStart(itemContainer));
		var chainStart = this.findOpAddItemStart(itemContainer);
		var chainEnd = itemContainer.getLastChild();
		if(chainStart.tok._hx_index == 19) {
			switch(tokentree_utils_TokenTreeCheckUtils.getPOpenType(chainStart)._hx_index) {
			case 0:
				return;
			case 1:
				break;
			case 2:
				break;
			case 3:
				break;
			case 4:
				break;
			case 5:
				break;
			case 6:
				break;
			case 7:
				break;
			case 8:
				break;
			case 9:
				break;
			}
		}
		if(chainEnd != null) {
			chainEnd = tokentree_utils_TokenTreeCheckUtils.getLastToken(chainEnd);
			switch(chainEnd.tok._hx_index) {
			case 10:case 14:
				break;
			default:
				var next = this.getNextToken(chainEnd);
				if(next != null) {
					chainEnd = next.token;
				}
			}
		}
		var next = this.getNextToken(chainStart);
		if(next == null) {
			return;
		}
		var itemStart = next.token;
		var _g = 0;
		var _g1 = itemContainer.children;
		while(_g < _g1.length) {
			var child = _g1[_g];
			++_g;
			var _g2 = child.tok;
			if(_g2._hx_index == 6) {
				switch(_g2.op._hx_index) {
				case 0:case 3:
					items.push(this.makeWrappableItem(itemStart,child));
					var next = this.getNextToken(child);
					if(next == null) {
						continue;
					}
					itemStart = next.token;
					break;
				default:
					continue;
				}
			} else {
				continue;
			}
		}
		items.push(this.makeWrappableItem(itemStart,tokentree_utils_TokenTreeCheckUtils.getLastToken(itemStart)));
		this.queueWrapping({ origin : formatter_marker_wrapping_WrappingOrigin.OpAddChainWrapping, start : chainStart, end : null, items : items, rules : this.config.wrapping.opAddSubChain, useTrailing : false, overrideAdditionalIndent : null},"markSingleOpAddChain");
	}
	,findOpAddItemStart: function(itemStart) {
		if(itemStart == null || itemStart.tok == tokentree_TokenTreeDef.Root) {
			return itemStart;
		}
		var parent = itemStart;
		while(parent != null && parent.tok != tokentree_TokenTreeDef.Root) {
			var _g = parent.tok;
			switch(_g._hx_index) {
			case 1:
				switch(_g.k._hx_index) {
				case 23:case 28:case 36:
					break;
				default:
					return parent;
				}
				break;
			case 6:
				switch(_g.op._hx_index) {
				case 4:
					return parent;
				case 20:
					return parent;
				default:
				}
				break;
			case 15:
				var this1 = tokentree_TokenTreeAccessHelper.firstOf(parent,tokentree_TokenTreeDef.BkClose);
				if(this1 == null || this1.index > itemStart.index) {
					return parent;
				}
				break;
			case 17:
				var this2 = tokentree_TokenTreeAccessHelper.firstOf(parent,tokentree_TokenTreeDef.BrClose);
				if(this2 == null || this2.index > itemStart.index) {
					return parent;
				}
				break;
			case 19:
				var this3 = tokentree_TokenTreeAccessHelper.firstOf(parent,tokentree_TokenTreeDef.PClose);
				if(this3 == null || this3.index > itemStart.index) {
					return parent;
				}
				break;
			default:
			}
			itemStart = parent;
			parent = parent.parent;
		}
		return itemStart;
	}
	,makeWrappableItem: function(start,end) {
		var sameLine = this.isSameLineBetween(start,end,false);
		var firstLineLength = 0;
		var lastLineLength = 0;
		if(sameLine) {
			firstLineLength = this.calcLengthBetween(start,end) + this.calcTokenLength(end);
		} else {
			firstLineLength = this.calcLengthUntilNewline(start,end);
			lastLineLength = this.calcLineLengthBefore(end) + this.calcTokenLength(end);
		}
		return { first : start, last : end, multiline : !sameLine, firstLineLength : firstLineLength, lastLineLength : lastLineLength};
	}
	,markImplementsExtendsChaining: function() {
		var classesAndInterfaces = this.parsedCode.root.filterCallback(function(token,index) {
			var _g = token.tok;
			if(_g._hx_index == 1) {
				switch(_g.k._hx_index) {
				case 1:case 27:
					return tokentree_FilterResult.FoundSkipSubtree;
				case 26:case 31:case 39:
					return tokentree_FilterResult.SkipSubtree;
				default:
					return tokentree_FilterResult.GoDeeper;
				}
			} else {
				return tokentree_FilterResult.GoDeeper;
			}
		});
		var _g = 0;
		while(_g < classesAndInterfaces.length) {
			var items = [];
			var impls = classesAndInterfaces[_g++].filterCallback(function(token,index) {
				var _g = token.tok;
				if(_g._hx_index == 1) {
					switch(_g.k._hx_index) {
					case 0:case 2:
						return tokentree_FilterResult.SkipSubtree;
					case 11:case 12:
						return tokentree_FilterResult.FoundSkipSubtree;
					default:
						return tokentree_FilterResult.GoDeeper;
					}
				} else {
					return tokentree_FilterResult.GoDeeper;
				}
			});
			var _g1 = 0;
			while(_g1 < impls.length) {
				var impl = impls[_g1];
				++_g1;
				items.push(this.makeWrappableItem(impl,tokentree_utils_TokenTreeCheckUtils.getLastToken(impl)));
			}
			if(items.length <= 0) {
				continue;
			}
			var chainOpen = items[0].first;
			var prev = this.getPreviousToken(items[0].first);
			if(prev != null) {
				chainOpen = prev.token;
			}
			this.queueWrapping({ origin : formatter_marker_wrapping_WrappingOrigin.ImplementsWrapping, start : chainOpen, end : items[items.length - 1].last, items : items, rules : this.config.wrapping.implementsExtends, useTrailing : false, overrideAdditionalIndent : null},"markImplementsExtendsChaining");
		}
	}
	,markMultiVarChaining: function() {
		var allVars = this.parsedCode.root.filterCallback(function(token,index) {
			var _g = token.tok;
			if(_g._hx_index == 1) {
				if(_g.k._hx_index == 2) {
					if(token.hasChildren() && token.children.length > 1) {
						return tokentree_FilterResult.FoundSkipSubtree;
					}
					return tokentree_FilterResult.SkipSubtree;
				} else {
					return tokentree_FilterResult.GoDeeper;
				}
			} else {
				return tokentree_FilterResult.GoDeeper;
			}
		});
		var _g = 0;
		while(_g < allVars.length) {
			var v = allVars[_g];
			++_g;
			var items = [];
			var _g1 = 0;
			var _g2 = v.children;
			while(_g1 < _g2.length) {
				var child = _g2[_g1];
				++_g1;
				items.push(this.makeWrappableItem(child,tokentree_utils_TokenTreeCheckUtils.getLastToken(child)));
			}
			if(items.length <= 0) {
				continue;
			}
			this.queueWrapping({ origin : formatter_marker_wrapping_WrappingOrigin.MultiVarWrapping, start : v, end : tokentree_utils_TokenTreeCheckUtils.getLastToken(v), items : items, rules : this.config.wrapping.multiVar, useTrailing : false, overrideAdditionalIndent : null},"markMultiVarChaining");
		}
	}
	,__class__: formatter_marker_wrapping_MarkWrapping
});
var formatter_marker_wrapping_WrappingOrigin = $hxEnums["formatter.marker.wrapping.WrappingOrigin"] = { __ename__ : true, __constructs__ : ["AnonTypeWrapping","ArrayWrapping","CallParameterWrapping","CasePatternWrapping","FunctionSignatureWrapping","ImplementsWrapping","MetadataCallParameterWrapping","MethodChainWrapping","MultiVarWrapping","OpAddChainWrapping","OpBoolChainWrapping","TypeParameterWrapping"]
	,AnonTypeWrapping: {_hx_index:0,__enum__:"formatter.marker.wrapping.WrappingOrigin",toString:$estr}
	,ArrayWrapping: {_hx_index:1,__enum__:"formatter.marker.wrapping.WrappingOrigin",toString:$estr}
	,CallParameterWrapping: {_hx_index:2,__enum__:"formatter.marker.wrapping.WrappingOrigin",toString:$estr}
	,CasePatternWrapping: {_hx_index:3,__enum__:"formatter.marker.wrapping.WrappingOrigin",toString:$estr}
	,FunctionSignatureWrapping: {_hx_index:4,__enum__:"formatter.marker.wrapping.WrappingOrigin",toString:$estr}
	,ImplementsWrapping: {_hx_index:5,__enum__:"formatter.marker.wrapping.WrappingOrigin",toString:$estr}
	,MetadataCallParameterWrapping: {_hx_index:6,__enum__:"formatter.marker.wrapping.WrappingOrigin",toString:$estr}
	,MethodChainWrapping: {_hx_index:7,__enum__:"formatter.marker.wrapping.WrappingOrigin",toString:$estr}
	,MultiVarWrapping: {_hx_index:8,__enum__:"formatter.marker.wrapping.WrappingOrigin",toString:$estr}
	,OpAddChainWrapping: {_hx_index:9,__enum__:"formatter.marker.wrapping.WrappingOrigin",toString:$estr}
	,OpBoolChainWrapping: {_hx_index:10,__enum__:"formatter.marker.wrapping.WrappingOrigin",toString:$estr}
	,TypeParameterWrapping: {_hx_index:11,__enum__:"formatter.marker.wrapping.WrappingOrigin",toString:$estr}
};
var haxe_StackItem = $hxEnums["haxe.StackItem"] = { __ename__ : true, __constructs__ : ["CFunction","Module","FilePos","Method","LocalFunction"]
	,CFunction: {_hx_index:0,__enum__:"haxe.StackItem",toString:$estr}
	,Module: ($_=function(m) { return {_hx_index:1,m:m,__enum__:"haxe.StackItem",toString:$estr}; },$_.__params__ = ["m"],$_)
	,FilePos: ($_=function(s,file,line,column) { return {_hx_index:2,s:s,file:file,line:line,column:column,__enum__:"haxe.StackItem",toString:$estr}; },$_.__params__ = ["s","file","line","column"],$_)
	,Method: ($_=function(classname,method) { return {_hx_index:3,classname:classname,method:method,__enum__:"haxe.StackItem",toString:$estr}; },$_.__params__ = ["classname","method"],$_)
	,LocalFunction: ($_=function(v) { return {_hx_index:4,v:v,__enum__:"haxe.StackItem",toString:$estr}; },$_.__params__ = ["v"],$_)
};
var haxe_CallStack = {};
haxe_CallStack.callStack = function() {
	return haxe_NativeStackTrace.toHaxe(haxe_NativeStackTrace.callStack());
};
haxe_CallStack.exceptionStack = function(fullStack) {
	if(fullStack == null) {
		fullStack = false;
	}
	var eStack = haxe_NativeStackTrace.toHaxe(haxe_NativeStackTrace.exceptionStack());
	return fullStack ? eStack : haxe_CallStack.subtract(eStack,haxe_CallStack.callStack());
};
haxe_CallStack.toString = function(stack) {
	var b = new StringBuf();
	var _g = 0;
	var _g1 = stack;
	while(_g < _g1.length) {
		var s = _g1[_g++];
		b.b += "\nCalled from ";
		haxe_CallStack.itemToString(b,s);
	}
	return b.b;
};
haxe_CallStack.subtract = function(this1,stack) {
	var startIndex = -1;
	var i = -1;
	while(++i < this1.length) {
		var _g = 0;
		var _g1 = stack.length;
		while(_g < _g1) if(haxe_CallStack.equalItems(this1[i],stack[_g++])) {
			if(startIndex < 0) {
				startIndex = i;
			}
			++i;
			if(i >= this1.length) {
				break;
			}
		} else {
			startIndex = -1;
		}
		if(startIndex >= 0) {
			break;
		}
	}
	if(startIndex >= 0) {
		return this1.slice(0,startIndex);
	} else {
		return this1;
	}
};
haxe_CallStack.equalItems = function(item1,item2) {
	if(item1 == null) {
		if(item2 == null) {
			return true;
		} else {
			return false;
		}
	} else {
		switch(item1._hx_index) {
		case 0:
			if(item2 == null) {
				return false;
			} else if(item2._hx_index == 0) {
				return true;
			} else {
				return false;
			}
			break;
		case 1:
			if(item2 == null) {
				return false;
			} else if(item2._hx_index == 1) {
				return item1.m == item2.m;
			} else {
				return false;
			}
			break;
		case 2:
			if(item2 == null) {
				return false;
			} else if(item2._hx_index == 2) {
				if(item1.file == item2.file && item1.line == item2.line && item1.column == item2.column) {
					return haxe_CallStack.equalItems(item1.s,item2.s);
				} else {
					return false;
				}
			} else {
				return false;
			}
			break;
		case 3:
			if(item2 == null) {
				return false;
			} else if(item2._hx_index == 3) {
				if(item1.classname == item2.classname) {
					return item1.method == item2.method;
				} else {
					return false;
				}
			} else {
				return false;
			}
			break;
		case 4:
			if(item2 == null) {
				return false;
			} else if(item2._hx_index == 4) {
				return item1.v == item2.v;
			} else {
				return false;
			}
			break;
		}
	}
};
haxe_CallStack.itemToString = function(b,s) {
	switch(s._hx_index) {
	case 0:
		b.b += "a C function";
		break;
	case 1:
		var _g = s.m;
		b.b = (b.b += "module ") + (_g == null ? "null" : "" + _g);
		break;
	case 2:
		var _g = s.column;
		var _g1 = s.line;
		var _g2 = s.file;
		var _g3 = s.s;
		if(_g3 != null) {
			haxe_CallStack.itemToString(b,_g3);
			b.b += " (";
		}
		b.b = (b.b += _g2 == null ? "null" : "" + _g2) + " line ";
		b.b += _g1 == null ? "null" : "" + _g1;
		if(_g != null) {
			b.b = (b.b += " column ") + (_g == null ? "null" : "" + _g);
		}
		if(_g3 != null) {
			b.b += ")";
		}
		break;
	case 3:
		var _g = s.method;
		var _g1 = s.classname;
		b.b = (b.b += Std.string(_g1 == null ? "<unknown>" : _g1)) + ".";
		b.b += _g == null ? "null" : "" + _g;
		break;
	case 4:
		var _g = s.v;
		b.b = (b.b += "local function #") + (_g == null ? "null" : "" + _g);
		break;
	}
};
var haxe_IMap = function() { };
haxe_IMap.__name__ = true;
haxe_IMap.__isInterface__ = true;
var haxe_Exception = function(message,previous,native) {
	Error.call(this,message);
	this.message = message;
	this.__previousException = previous;
	this.__nativeException = native != null ? native : this;
	this.__skipStack = 0;
	var old = Error.prepareStackTrace;
	Error.prepareStackTrace = function(e) { return e.stack; }
	if(((native) instanceof Error)) {
		this.stack = native.stack;
	} else {
		var e = null;
		if(Error.captureStackTrace) {
			Error.captureStackTrace(this,haxe_Exception);
			e = this;
		} else {
			e = new Error();
			if(typeof(e.stack) == "undefined") {
				try { throw e; } catch(_) {}
				this.__skipStack++;
			}
		}
		this.stack = e.stack;
	}
	Error.prepareStackTrace = old;
};
haxe_Exception.__name__ = true;
haxe_Exception.caught = function(value) {
	if(((value) instanceof haxe_Exception)) {
		return value;
	} else if(((value) instanceof Error)) {
		return new haxe_Exception(value.message,null,value);
	} else {
		return new haxe_ValueException(value,null,value);
	}
};
haxe_Exception.thrown = function(value) {
	if(((value) instanceof haxe_Exception)) {
		return value.get_native();
	} else if(((value) instanceof Error)) {
		return value;
	} else {
		var e = new haxe_ValueException(value);
		e.__skipStack++;
		return e;
	}
};
haxe_Exception.__super__ = Error;
haxe_Exception.prototype = $extend(Error.prototype,{
	unwrap: function() {
		return this.__nativeException;
	}
	,__shiftStack: function() {
		this.__skipStack++;
	}
	,get_native: function() {
		return this.__nativeException;
	}
	,get_stack: function() {
		var _g = this.__exceptionStack;
		if(_g == null) {
			var value = haxe_NativeStackTrace.toHaxe(haxe_NativeStackTrace.normalize(this.stack),this.__skipStack);
			this.setProperty("__exceptionStack",value);
			return value;
		} else {
			return _g;
		}
	}
	,setProperty: function(name,value) {
		try {
			Object.defineProperty(this,name,{ value : value});
		} catch( _g ) {
			this[name] = value;
		}
	}
	,__class__: haxe_Exception
});
var haxe_NativeStackTrace = function() { };
haxe_NativeStackTrace.__name__ = true;
haxe_NativeStackTrace.saveStack = function(e) {
	haxe_NativeStackTrace.lastError = e;
};
haxe_NativeStackTrace.callStack = function() {
	var e = new Error("");
	var stack = haxe_NativeStackTrace.tryHaxeStack(e);
	if(typeof(stack) == "undefined") {
		try {
			throw e;
		} catch( _g ) {
		}
		stack = e.stack;
	}
	return haxe_NativeStackTrace.normalize(stack,2);
};
haxe_NativeStackTrace.exceptionStack = function() {
	return haxe_NativeStackTrace.normalize(haxe_NativeStackTrace.tryHaxeStack(haxe_NativeStackTrace.lastError));
};
haxe_NativeStackTrace.toHaxe = function(s,skip) {
	if(skip == null) {
		skip = 0;
	}
	if(s == null) {
		return [];
	} else if(typeof(s) == "string") {
		var stack = s.split("\n");
		if(stack[0] == "Error") {
			stack.shift();
		}
		var m = [];
		var _g = 0;
		var _g1 = stack.length;
		while(_g < _g1) {
			var i = _g++;
			if(skip > i) {
				continue;
			}
			var line = stack[i];
			var matched = line.match(/^    at ([A-Za-z0-9_. ]+) \(([^)]+):([0-9]+):([0-9]+)\)$/);
			if(matched != null) {
				var path = matched[1].split(".");
				if(path[0] == "$hxClasses") {
					path.shift();
				}
				var meth = path.pop();
				var file = matched[2];
				var line1 = Std.parseInt(matched[3]);
				var column = Std.parseInt(matched[4]);
				m.push(haxe_StackItem.FilePos(meth == "Anonymous function" ? haxe_StackItem.LocalFunction() : meth == "Global code" ? null : haxe_StackItem.Method(path.join("."),meth),file,line1,column));
			} else {
				m.push(haxe_StackItem.Module(StringTools.trim(line)));
			}
		}
		return m;
	} else if(skip > 0 && Array.isArray(s)) {
		return s.slice(skip);
	} else {
		return s;
	}
};
haxe_NativeStackTrace.tryHaxeStack = function(e) {
	if(e == null) {
		return [];
	}
	var oldValue = Error.prepareStackTrace;
	Error.prepareStackTrace = haxe_NativeStackTrace.prepareHxStackTrace;
	Error.prepareStackTrace = oldValue;
	return e.stack;
};
haxe_NativeStackTrace.prepareHxStackTrace = function(e,callsites) {
	var stack = [];
	var _g = 0;
	while(_g < callsites.length) {
		var site = callsites[_g];
		++_g;
		if(haxe_NativeStackTrace.wrapCallSite != null) {
			site = haxe_NativeStackTrace.wrapCallSite(site);
		}
		var method = null;
		var fullName = site.getFunctionName();
		if(fullName != null) {
			var idx = fullName.lastIndexOf(".");
			if(idx >= 0) {
				method = haxe_StackItem.Method(fullName.substring(0,idx),fullName.substring(idx + 1));
			} else {
				method = haxe_StackItem.Method(null,fullName);
			}
		}
		var fileName = site.getFileName();
		var fileAddr = fileName == null ? -1 : fileName.indexOf("file:");
		if(haxe_NativeStackTrace.wrapCallSite != null && fileAddr > 0) {
			fileName = fileName.substring(fileAddr + 6);
		}
		stack.push(haxe_StackItem.FilePos(method,fileName,site.getLineNumber(),site.getColumnNumber()));
	}
	return stack;
};
haxe_NativeStackTrace.normalize = function(stack,skipItems) {
	if(skipItems == null) {
		skipItems = 0;
	}
	if(Array.isArray(stack) && skipItems > 0) {
		return stack.slice(skipItems);
	} else if(typeof(stack) == "string") {
		switch(stack.substring(0,6)) {
		case "Error\n":case "Error:":
			++skipItems;
			break;
		default:
		}
		return haxe_NativeStackTrace.skipLines(stack,skipItems);
	} else {
		return stack;
	}
};
haxe_NativeStackTrace.skipLines = function(stack,skip,pos) {
	if(pos == null) {
		pos = 0;
	}
	while(true) if(skip > 0) {
		pos = stack.indexOf("\n",pos);
		if(pos < 0) {
			return "";
		} else {
			skip = --skip;
			pos += 1;
			continue;
		}
	} else {
		return stack.substring(pos);
	}
};
var haxe_ValueException = function(value,previous,native) {
	haxe_Exception.call(this,String(value),previous,native);
	this.value = value;
	this.__skipStack++;
};
haxe_ValueException.__name__ = true;
haxe_ValueException.__super__ = haxe_Exception;
haxe_ValueException.prototype = $extend(haxe_Exception.prototype,{
	unwrap: function() {
		return this.value;
	}
	,__class__: haxe_ValueException
});
var haxe_ds_IntMap = function() {
	this.h = { };
};
haxe_ds_IntMap.__name__ = true;
haxe_ds_IntMap.__interfaces__ = [haxe_IMap];
haxe_ds_IntMap.prototype = {
	__class__: haxe_ds_IntMap
};
var haxe_ds_List = function() {
	this.length = 0;
};
haxe_ds_List.__name__ = true;
haxe_ds_List.prototype = {
	push: function(item) {
		var x = new haxe_ds__$List_ListNode(item,this.h);
		this.h = x;
		if(this.q == null) {
			this.q = x;
		}
		this.length++;
	}
	,remove: function(v) {
		var prev = null;
		var l = this.h;
		while(l != null) {
			if(l.item == v) {
				if(prev == null) {
					this.h = l.next;
				} else {
					prev.next = l.next;
				}
				if(this.q == l) {
					this.q = prev;
				}
				this.length--;
				return true;
			}
			prev = l;
			l = l.next;
		}
		return false;
	}
	,__class__: haxe_ds_List
};
var haxe_ds__$List_ListNode = function(item,next) {
	this.item = item;
	this.next = next;
};
haxe_ds__$List_ListNode.__name__ = true;
haxe_ds__$List_ListNode.prototype = {
	__class__: haxe_ds__$List_ListNode
};
var haxe_ds_StringMap = function() {
	this.h = Object.create(null);
};
haxe_ds_StringMap.__name__ = true;
haxe_ds_StringMap.__interfaces__ = [haxe_IMap];
haxe_ds_StringMap.keysIterator = function(h) {
	var keys = Object.keys(h);
	var len = keys.length;
	var idx = 0;
	return { hasNext : function() {
		return idx < len;
	}, next : function() {
		idx += 1;
		return keys[idx - 1];
	}};
};
haxe_ds_StringMap.prototype = {
	__class__: haxe_ds_StringMap
};
var haxe_io_Bytes = function(data) {
	this.length = data.byteLength;
	this.b = new Uint8Array(data);
	this.b.bufferValue = data;
	data.hxBytes = this;
	data.bytes = this.b;
};
haxe_io_Bytes.__name__ = true;
haxe_io_Bytes.ofString = function(s,encoding) {
	if(encoding == haxe_io_Encoding.RawNative) {
		var buf = new Uint8Array(s.length << 1);
		var _g = 0;
		var _g1 = s.length;
		while(_g < _g1) {
			var i = _g++;
			var c = s.charCodeAt(i);
			buf[i << 1] = c & 255;
			buf[i << 1 | 1] = c >> 8;
		}
		return new haxe_io_Bytes(buf.buffer);
	}
	var a = [];
	var i = 0;
	while(i < s.length) {
		var c = s.charCodeAt(i++);
		if(55296 <= c && c <= 56319) {
			c = c - 55232 << 10 | s.charCodeAt(i++) & 1023;
		}
		if(c <= 127) {
			a.push(c);
		} else if(c <= 2047) {
			a.push(192 | c >> 6);
			a.push(128 | c & 63);
		} else if(c <= 65535) {
			a.push(224 | c >> 12);
			a.push(128 | c >> 6 & 63);
			a.push(128 | c & 63);
		} else {
			a.push(240 | c >> 18);
			a.push(128 | c >> 12 & 63);
			a.push(128 | c >> 6 & 63);
			a.push(128 | c & 63);
		}
	}
	return new haxe_io_Bytes(new Uint8Array(a).buffer);
};
haxe_io_Bytes.prototype = {
	sub: function(pos,len) {
		if(pos < 0 || len < 0 || pos + len > this.length) {
			throw haxe_Exception.thrown(haxe_io_Error.OutsideBounds);
		}
		return new haxe_io_Bytes(this.b.buffer.slice(pos + this.b.byteOffset,pos + this.b.byteOffset + len));
	}
	,getString: function(pos,len,encoding) {
		if(pos < 0 || len < 0 || pos + len > this.length) {
			throw haxe_Exception.thrown(haxe_io_Error.OutsideBounds);
		}
		if(encoding == null) {
			encoding = haxe_io_Encoding.UTF8;
		}
		var s = "";
		var b = this.b;
		var i = pos;
		var max = pos + len;
		switch(encoding._hx_index) {
		case 0:
			while(i < max) {
				var c = b[i++];
				if(c < 128) {
					if(c == 0) {
						break;
					}
					s += String.fromCodePoint(c);
				} else if(c < 224) {
					var code = (c & 63) << 6 | b[i++] & 127;
					s += String.fromCodePoint(code);
				} else if(c < 240) {
					var code1 = (c & 31) << 12 | (b[i++] & 127) << 6 | b[i++] & 127;
					s += String.fromCodePoint(code1);
				} else {
					var u = (c & 15) << 18 | (b[i++] & 127) << 12 | (b[i++] & 127) << 6 | b[i++] & 127;
					s += String.fromCodePoint(u);
				}
			}
			break;
		case 1:
			while(i < max) {
				var c = b[i++] | b[i++] << 8;
				s += String.fromCodePoint(c);
			}
			break;
		}
		return s;
	}
	,toString: function() {
		return this.getString(0,this.length);
	}
	,__class__: haxe_io_Bytes
};
var haxe_io_BytesBuffer = function() {
	this.pos = 0;
	this.size = 0;
};
haxe_io_BytesBuffer.__name__ = true;
haxe_io_BytesBuffer.prototype = {
	addBytes: function(src,pos,len) {
		if(pos < 0 || len < 0 || pos + len > src.length) {
			throw haxe_Exception.thrown(haxe_io_Error.OutsideBounds);
		}
		if(this.pos + len > this.size) {
			this.grow(len);
		}
		if(this.size == 0) {
			return;
		}
		this.u8.set(new Uint8Array(src.b.buffer,src.b.byteOffset + pos,len),this.pos);
		this.pos += len;
	}
	,grow: function(delta) {
		var req = this.pos + delta;
		var nsize = this.size == 0 ? 16 : this.size;
		while(nsize < req) nsize = nsize * 3 >> 1;
		var nbuf = new ArrayBuffer(nsize);
		var nu8 = new Uint8Array(nbuf);
		if(this.size > 0) {
			nu8.set(this.u8);
		}
		this.size = nsize;
		this.buffer = nbuf;
		this.u8 = nu8;
		this.view = new DataView(this.buffer);
	}
	,getBytes: function() {
		if(this.size == 0) {
			return new haxe_io_Bytes(new ArrayBuffer(0));
		}
		var b = new haxe_io_Bytes(this.buffer);
		b.length = this.pos;
		return b;
	}
	,__class__: haxe_io_BytesBuffer
};
var haxe_io_Encoding = $hxEnums["haxe.io.Encoding"] = { __ename__ : true, __constructs__ : ["UTF8","RawNative"]
	,UTF8: {_hx_index:0,__enum__:"haxe.io.Encoding",toString:$estr}
	,RawNative: {_hx_index:1,__enum__:"haxe.io.Encoding",toString:$estr}
};
var haxe_io_Eof = function() {
};
haxe_io_Eof.__name__ = true;
haxe_io_Eof.prototype = {
	toString: function() {
		return "Eof";
	}
	,__class__: haxe_io_Eof
};
var haxe_io_Error = $hxEnums["haxe.io.Error"] = { __ename__ : true, __constructs__ : ["Blocked","Overflow","OutsideBounds","Custom"]
	,Blocked: {_hx_index:0,__enum__:"haxe.io.Error",toString:$estr}
	,Overflow: {_hx_index:1,__enum__:"haxe.io.Error",toString:$estr}
	,OutsideBounds: {_hx_index:2,__enum__:"haxe.io.Error",toString:$estr}
	,Custom: ($_=function(e) { return {_hx_index:3,e:e,__enum__:"haxe.io.Error",toString:$estr}; },$_.__params__ = ["e"],$_)
};
var haxe_io_Path = function(path) {
	switch(path) {
	case ".":case "..":
		this.dir = path;
		this.file = "";
		return;
	}
	var c1 = path.lastIndexOf("/");
	var c2 = path.lastIndexOf("\\");
	if(c1 < c2) {
		this.dir = HxOverrides.substr(path,0,c2);
		path = HxOverrides.substr(path,c2 + 1,null);
		this.backslash = true;
	} else if(c2 < c1) {
		this.dir = HxOverrides.substr(path,0,c1);
		path = HxOverrides.substr(path,c1 + 1,null);
	} else {
		this.dir = null;
	}
	var cp = path.lastIndexOf(".");
	if(cp != -1) {
		this.ext = HxOverrides.substr(path,cp + 1,null);
		this.file = HxOverrides.substr(path,0,cp);
	} else {
		this.ext = null;
		this.file = path;
	}
};
haxe_io_Path.__name__ = true;
haxe_io_Path.directory = function(path) {
	var s = new haxe_io_Path(path);
	if(s.dir == null) {
		return "";
	}
	return s.dir;
};
haxe_io_Path.join = function(paths) {
	var _g = [];
	var _g1 = 0;
	while(_g1 < paths.length) {
		var v = paths[_g1];
		++_g1;
		if(v != null && v != "") {
			_g.push(v);
		}
	}
	if(_g.length == 0) {
		return "";
	}
	var path = _g[0];
	var _g1 = 1;
	var _g2 = _g.length;
	while(_g1 < _g2) {
		path = haxe_io_Path.addTrailingSlash(path);
		path += _g[_g1++];
	}
	return haxe_io_Path.normalize(path);
};
haxe_io_Path.normalize = function(path) {
	var slash = "/";
	path = path.split("\\").join(slash);
	if(path == slash) {
		return slash;
	}
	var target = [];
	var _g = 0;
	var _g1 = path.split(slash);
	while(_g < _g1.length) {
		var token = _g1[_g];
		++_g;
		if(token == ".." && target.length > 0 && target[target.length - 1] != "..") {
			target.pop();
		} else if(token == "") {
			if(target.length > 0 || HxOverrides.cca(path,0) == 47) {
				target.push(token);
			}
		} else if(token != ".") {
			target.push(token);
		}
	}
	var acc_b = "";
	var colon = false;
	var slashes = false;
	var _g2_offset = 0;
	var _g2_s = target.join(slash);
	while(_g2_offset < _g2_s.length) {
		var s = _g2_s;
		var index = _g2_offset++;
		var c = s.charCodeAt(index);
		if(c >= 55296 && c <= 56319) {
			c = c - 55232 << 10 | s.charCodeAt(index + 1) & 1023;
		}
		var c1 = c;
		if(c1 >= 65536) {
			++_g2_offset;
		}
		var c2 = c1;
		switch(c2) {
		case 47:
			if(!colon) {
				slashes = true;
			} else {
				var i = c2;
				colon = false;
				if(slashes) {
					acc_b += "/";
					slashes = false;
				}
				acc_b += String.fromCodePoint(i);
			}
			break;
		case 58:
			acc_b += ":";
			colon = true;
			break;
		default:
			var i1 = c2;
			colon = false;
			if(slashes) {
				acc_b += "/";
				slashes = false;
			}
			acc_b += String.fromCodePoint(i1);
		}
	}
	return acc_b;
};
haxe_io_Path.addTrailingSlash = function(path) {
	if(path.length == 0) {
		return "/";
	}
	var c1 = path.lastIndexOf("/");
	var c2 = path.lastIndexOf("\\");
	if(c1 < c2) {
		if(c2 != path.length - 1) {
			return path + "\\";
		} else {
			return path;
		}
	} else if(c1 != path.length - 1) {
		return path + "/";
	} else {
		return path;
	}
};
haxe_io_Path.prototype = {
	__class__: haxe_io_Path
};
var haxe_iterators_ArrayIterator = function(array) {
	this.current = 0;
	this.array = array;
};
haxe_iterators_ArrayIterator.__name__ = true;
haxe_iterators_ArrayIterator.prototype = {
	hasNext: function() {
		return this.current < this.array.length;
	}
	,next: function() {
		return this.array[this.current++];
	}
	,__class__: haxe_iterators_ArrayIterator
};
var haxe_macro_StringLiteralKind = $hxEnums["haxe.macro.StringLiteralKind"] = { __ename__ : true, __constructs__ : ["DoubleQuotes","SingleQuotes"]
	,DoubleQuotes: {_hx_index:0,__enum__:"haxe.macro.StringLiteralKind",toString:$estr}
	,SingleQuotes: {_hx_index:1,__enum__:"haxe.macro.StringLiteralKind",toString:$estr}
};
var haxe_macro_Constant = $hxEnums["haxe.macro.Constant"] = { __ename__ : true, __constructs__ : ["CInt","CFloat","CString","CIdent","CRegexp"]
	,CInt: ($_=function(v) { return {_hx_index:0,v:v,__enum__:"haxe.macro.Constant",toString:$estr}; },$_.__params__ = ["v"],$_)
	,CFloat: ($_=function(f) { return {_hx_index:1,f:f,__enum__:"haxe.macro.Constant",toString:$estr}; },$_.__params__ = ["f"],$_)
	,CString: ($_=function(s,kind) { return {_hx_index:2,s:s,kind:kind,__enum__:"haxe.macro.Constant",toString:$estr}; },$_.__params__ = ["s","kind"],$_)
	,CIdent: ($_=function(s) { return {_hx_index:3,s:s,__enum__:"haxe.macro.Constant",toString:$estr}; },$_.__params__ = ["s"],$_)
	,CRegexp: ($_=function(r,opt) { return {_hx_index:4,r:r,opt:opt,__enum__:"haxe.macro.Constant",toString:$estr}; },$_.__params__ = ["r","opt"],$_)
};
var haxe_macro_Binop = $hxEnums["haxe.macro.Binop"] = { __ename__ : true, __constructs__ : ["OpAdd","OpMult","OpDiv","OpSub","OpAssign","OpEq","OpNotEq","OpGt","OpGte","OpLt","OpLte","OpAnd","OpOr","OpXor","OpBoolAnd","OpBoolOr","OpShl","OpShr","OpUShr","OpMod","OpAssignOp","OpInterval","OpArrow","OpIn"]
	,OpAdd: {_hx_index:0,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpMult: {_hx_index:1,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpDiv: {_hx_index:2,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpSub: {_hx_index:3,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpAssign: {_hx_index:4,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpEq: {_hx_index:5,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpNotEq: {_hx_index:6,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpGt: {_hx_index:7,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpGte: {_hx_index:8,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpLt: {_hx_index:9,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpLte: {_hx_index:10,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpAnd: {_hx_index:11,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpOr: {_hx_index:12,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpXor: {_hx_index:13,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpBoolAnd: {_hx_index:14,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpBoolOr: {_hx_index:15,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpShl: {_hx_index:16,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpShr: {_hx_index:17,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpUShr: {_hx_index:18,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpMod: {_hx_index:19,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpAssignOp: ($_=function(op) { return {_hx_index:20,op:op,__enum__:"haxe.macro.Binop",toString:$estr}; },$_.__params__ = ["op"],$_)
	,OpInterval: {_hx_index:21,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpArrow: {_hx_index:22,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpIn: {_hx_index:23,__enum__:"haxe.macro.Binop",toString:$estr}
};
var haxe_macro_Unop = $hxEnums["haxe.macro.Unop"] = { __ename__ : true, __constructs__ : ["OpIncrement","OpDecrement","OpNot","OpNeg","OpNegBits"]
	,OpIncrement: {_hx_index:0,__enum__:"haxe.macro.Unop",toString:$estr}
	,OpDecrement: {_hx_index:1,__enum__:"haxe.macro.Unop",toString:$estr}
	,OpNot: {_hx_index:2,__enum__:"haxe.macro.Unop",toString:$estr}
	,OpNeg: {_hx_index:3,__enum__:"haxe.macro.Unop",toString:$estr}
	,OpNegBits: {_hx_index:4,__enum__:"haxe.macro.Unop",toString:$estr}
};
var haxe_macro_Printer = function(tabString) {
	if(tabString == null) {
		tabString = "\t";
	}
	this.tabs = "";
	this.tabString = tabString;
};
haxe_macro_Printer.__name__ = true;
haxe_macro_Printer.prototype = {
	printUnop: function(op) {
		switch(op._hx_index) {
		case 0:
			return "++";
		case 1:
			return "--";
		case 2:
			return "!";
		case 3:
			return "-";
		case 4:
			return "~";
		}
	}
	,printBinop: function(op) {
		switch(op._hx_index) {
		case 0:
			return "+";
		case 1:
			return "*";
		case 2:
			return "/";
		case 3:
			return "-";
		case 4:
			return "=";
		case 5:
			return "==";
		case 6:
			return "!=";
		case 7:
			return ">";
		case 8:
			return ">=";
		case 9:
			return "<";
		case 10:
			return "<=";
		case 11:
			return "&";
		case 12:
			return "|";
		case 13:
			return "^";
		case 14:
			return "&&";
		case 15:
			return "||";
		case 16:
			return "<<";
		case 17:
			return ">>";
		case 18:
			return ">>>";
		case 19:
			return "%";
		case 20:
			return this.printBinop(op.op) + "=";
		case 21:
			return "...";
		case 22:
			return "=>";
		case 23:
			return "in";
		}
	}
	,__class__: haxe_macro_Printer
};
var haxeparser_Keyword = $hxEnums["haxeparser.Keyword"] = { __ename__ : true, __constructs__ : ["KwdFunction","KwdClass","KwdVar","KwdIf","KwdElse","KwdWhile","KwdDo","KwdFor","KwdBreak","KwdContinue","KwdReturn","KwdExtends","KwdImplements","KwdImport","KwdSwitch","KwdCase","KwdDefault","KwdStatic","KwdPublic","KwdPrivate","KwdTry","KwdCatch","KwdNew","KwdThis","KwdThrow","KwdExtern","KwdEnum","KwdInterface","KwdUntyped","KwdCast","KwdOverride","KwdTypedef","KwdDynamic","KwdPackage","KwdInline","KwdUsing","KwdNull","KwdTrue","KwdFalse","KwdAbstract","KwdMacro","KwdFinal","KwdOperator","KwdOverload"]
	,KwdFunction: {_hx_index:0,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdClass: {_hx_index:1,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdVar: {_hx_index:2,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdIf: {_hx_index:3,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdElse: {_hx_index:4,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdWhile: {_hx_index:5,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdDo: {_hx_index:6,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdFor: {_hx_index:7,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdBreak: {_hx_index:8,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdContinue: {_hx_index:9,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdReturn: {_hx_index:10,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdExtends: {_hx_index:11,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdImplements: {_hx_index:12,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdImport: {_hx_index:13,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdSwitch: {_hx_index:14,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdCase: {_hx_index:15,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdDefault: {_hx_index:16,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdStatic: {_hx_index:17,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdPublic: {_hx_index:18,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdPrivate: {_hx_index:19,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdTry: {_hx_index:20,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdCatch: {_hx_index:21,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdNew: {_hx_index:22,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdThis: {_hx_index:23,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdThrow: {_hx_index:24,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdExtern: {_hx_index:25,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdEnum: {_hx_index:26,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdInterface: {_hx_index:27,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdUntyped: {_hx_index:28,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdCast: {_hx_index:29,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdOverride: {_hx_index:30,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdTypedef: {_hx_index:31,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdDynamic: {_hx_index:32,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdPackage: {_hx_index:33,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdInline: {_hx_index:34,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdUsing: {_hx_index:35,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdNull: {_hx_index:36,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdTrue: {_hx_index:37,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdFalse: {_hx_index:38,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdAbstract: {_hx_index:39,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdMacro: {_hx_index:40,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdFinal: {_hx_index:41,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdOperator: {_hx_index:42,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdOverload: {_hx_index:43,__enum__:"haxeparser.Keyword",toString:$estr}
};
var haxeparser_TokenDef = $hxEnums["haxeparser.TokenDef"] = { __ename__ : true, __constructs__ : ["Kwd","Const","Sharp","Dollar","Unop","Binop","Comment","CommentLine","IntInterval","Semicolon","Dot","DblDot","Arrow","Comma","BkOpen","BkClose","BrOpen","BrClose","POpen","PClose","Question","At","Eof"]
	,Kwd: ($_=function(k) { return {_hx_index:0,k:k,__enum__:"haxeparser.TokenDef",toString:$estr}; },$_.__params__ = ["k"],$_)
	,Const: ($_=function(c) { return {_hx_index:1,c:c,__enum__:"haxeparser.TokenDef",toString:$estr}; },$_.__params__ = ["c"],$_)
	,Sharp: ($_=function(s) { return {_hx_index:2,s:s,__enum__:"haxeparser.TokenDef",toString:$estr}; },$_.__params__ = ["s"],$_)
	,Dollar: ($_=function(s) { return {_hx_index:3,s:s,__enum__:"haxeparser.TokenDef",toString:$estr}; },$_.__params__ = ["s"],$_)
	,Unop: ($_=function(op) { return {_hx_index:4,op:op,__enum__:"haxeparser.TokenDef",toString:$estr}; },$_.__params__ = ["op"],$_)
	,Binop: ($_=function(op) { return {_hx_index:5,op:op,__enum__:"haxeparser.TokenDef",toString:$estr}; },$_.__params__ = ["op"],$_)
	,Comment: ($_=function(s) { return {_hx_index:6,s:s,__enum__:"haxeparser.TokenDef",toString:$estr}; },$_.__params__ = ["s"],$_)
	,CommentLine: ($_=function(s) { return {_hx_index:7,s:s,__enum__:"haxeparser.TokenDef",toString:$estr}; },$_.__params__ = ["s"],$_)
	,IntInterval: ($_=function(s) { return {_hx_index:8,s:s,__enum__:"haxeparser.TokenDef",toString:$estr}; },$_.__params__ = ["s"],$_)
	,Semicolon: {_hx_index:9,__enum__:"haxeparser.TokenDef",toString:$estr}
	,Dot: {_hx_index:10,__enum__:"haxeparser.TokenDef",toString:$estr}
	,DblDot: {_hx_index:11,__enum__:"haxeparser.TokenDef",toString:$estr}
	,Arrow: {_hx_index:12,__enum__:"haxeparser.TokenDef",toString:$estr}
	,Comma: {_hx_index:13,__enum__:"haxeparser.TokenDef",toString:$estr}
	,BkOpen: {_hx_index:14,__enum__:"haxeparser.TokenDef",toString:$estr}
	,BkClose: {_hx_index:15,__enum__:"haxeparser.TokenDef",toString:$estr}
	,BrOpen: {_hx_index:16,__enum__:"haxeparser.TokenDef",toString:$estr}
	,BrClose: {_hx_index:17,__enum__:"haxeparser.TokenDef",toString:$estr}
	,POpen: {_hx_index:18,__enum__:"haxeparser.TokenDef",toString:$estr}
	,PClose: {_hx_index:19,__enum__:"haxeparser.TokenDef",toString:$estr}
	,Question: {_hx_index:20,__enum__:"haxeparser.TokenDef",toString:$estr}
	,At: {_hx_index:21,__enum__:"haxeparser.TokenDef",toString:$estr}
	,Eof: {_hx_index:22,__enum__:"haxeparser.TokenDef",toString:$estr}
};
var haxeparser_TokenDefPrinter = function() { };
haxeparser_TokenDefPrinter.__name__ = true;
haxeparser_TokenDefPrinter.toString = function(def) {
	switch(def._hx_index) {
	case 0:
		var _g = def.k;
		return HxOverrides.substr($hxEnums[_g.__enum__].__constructs__[_g._hx_index],3,null).toLowerCase();
	case 1:
		var _g = def.c;
		switch(_g._hx_index) {
		case 0:
			return _g.v;
		case 1:
			return _g.f;
		case 2:
			return "\"" + _g.s + "\"";
		case 3:
			return _g.s;
		case 4:
			return "~/" + _g.r + "/" + _g.opt;
		}
		break;
	case 2:
		return "#" + def.s;
	case 3:
		return "$" + def.s;
	case 4:
		return new haxe_macro_Printer("").printUnop(def.op);
	case 5:
		return new haxe_macro_Printer("").printBinop(def.op);
	case 6:
		return "/*" + def.s + "*/";
	case 7:
		return "//" + def.s;
	case 8:
		return "" + def.s + "...";
	case 9:
		return ";";
	case 10:
		return ".";
	case 11:
		return ":";
	case 12:
		return "->";
	case 13:
		return ",";
	case 14:
		return "[";
	case 15:
		return "]";
	case 16:
		return "{";
	case 17:
		return "}";
	case 18:
		return "(";
	case 19:
		return ")";
	case 20:
		return "?";
	case 21:
		return "@";
	case 22:
		return "<eof>";
	}
};
var haxeparser_Token = function(tok,pos) {
	this.tok = tok;
	this.pos = pos;
};
haxeparser_Token.__name__ = true;
haxeparser_Token.prototype = {
	toString: function() {
		return haxeparser_TokenDefPrinter.toString(this.tok);
	}
	,__class__: haxeparser_Token
};
var haxeparser_LexerErrorMsg = $hxEnums["haxeparser.LexerErrorMsg"] = { __ename__ : true, __constructs__ : ["UnterminatedString","UnterminatedRegExp","UnclosedComment","UnterminatedEscapeSequence","InvalidEscapeSequence","UnknownEscapeSequence","UnclosedCode"]
	,UnterminatedString: {_hx_index:0,__enum__:"haxeparser.LexerErrorMsg",toString:$estr}
	,UnterminatedRegExp: {_hx_index:1,__enum__:"haxeparser.LexerErrorMsg",toString:$estr}
	,UnclosedComment: {_hx_index:2,__enum__:"haxeparser.LexerErrorMsg",toString:$estr}
	,UnterminatedEscapeSequence: {_hx_index:3,__enum__:"haxeparser.LexerErrorMsg",toString:$estr}
	,InvalidEscapeSequence: ($_=function(c) { return {_hx_index:4,c:c,__enum__:"haxeparser.LexerErrorMsg",toString:$estr}; },$_.__params__ = ["c"],$_)
	,UnknownEscapeSequence: ($_=function(c) { return {_hx_index:5,c:c,__enum__:"haxeparser.LexerErrorMsg",toString:$estr}; },$_.__params__ = ["c"],$_)
	,UnclosedCode: {_hx_index:6,__enum__:"haxeparser.LexerErrorMsg",toString:$estr}
};
var haxeparser_LexerError = function(msg,pos) {
	this.msg = msg;
	this.pos = pos;
};
haxeparser_LexerError.__name__ = true;
haxeparser_LexerError.prototype = {
	__class__: haxeparser_LexerError
};
var hxparse_Lexer = function(input,sourceName) {
	if(sourceName == null) {
		sourceName = "<null>";
	}
	this.current = "";
	this.input = input;
	this.source = sourceName;
	this.pos = 0;
};
hxparse_Lexer.__name__ = true;
hxparse_Lexer.buildRuleset = function(rules,name) {
	if(name == null) {
		name = "";
	}
	var cases = [];
	var functions = [];
	var eofFunction = null;
	var _g = 0;
	while(_g < rules.length) {
		var rule = rules[_g];
		++_g;
		if(rule.rule == "") {
			eofFunction = rule.func;
		} else {
			cases.push(hxparse_LexEngine.parse(rule.rule));
			functions.push(rule.func);
		}
	}
	return new hxparse_Ruleset(new hxparse_LexEngine(cases).firstState(),functions,eofFunction,name);
};
hxparse_Lexer.prototype = {
	token: function(ruleset) {
		if(this.pos == this.input.length) {
			if(ruleset.eofFunction != null) {
				return ruleset.eofFunction(this);
			} else {
				throw haxe_Exception.thrown(new haxe_io_Eof());
			}
		}
		var state = ruleset.state;
		var lastMatch = null;
		var lastMatchPos = this.pos;
		var start = this.pos;
		while(true) {
			if(state.finalId > -1) {
				lastMatch = state;
				lastMatchPos = this.pos;
			}
			if(this.pos == this.input.length) {
				break;
			}
			var i = this.input.b[this.pos];
			++this.pos;
			state = state.trans[i];
			if(state == null) {
				break;
			}
		}
		this.pos = lastMatchPos;
		this.current = this.input.getString(start,this.pos - start);
		if(lastMatch == null || lastMatch.finalId == -1) {
			var code = this.input.b[this.pos];
			throw haxe_Exception.thrown(new hxparse_UnexpectedChar(String.fromCodePoint(code),new hxparse_Position(this.source,this.pos - this.current.length,this.pos)));
		}
		return ruleset.functions[lastMatch.finalId](this);
	}
	,__class__: hxparse_Lexer
};
var hxparse_RuleBuilder = function() { };
hxparse_RuleBuilder.__name__ = true;
hxparse_RuleBuilder.__isInterface__ = true;
var hxparse__$LexEngine_CharRange = function(min,max) {
	this.min = min;
	this.max = max;
};
hxparse__$LexEngine_CharRange.__name__ = true;
hxparse__$LexEngine_CharRange.prototype = {
	__class__: hxparse__$LexEngine_CharRange
};
var hxparse_LexEngine = function(patterns) {
	this.nodes = [];
	this.finals = [];
	this.states = [];
	this.hstates = new haxe_ds_StringMap();
	this.uid = 0;
	var pid = 0;
	var _g = 0;
	while(_g < patterns.length) {
		var p = patterns[_g++];
		var id = pid++;
		var f = new hxparse__$LexEngine_Node(this.uid++,id);
		var n = this.initNode(p,f,id);
		this.nodes.push(n);
		this.finals.push(f);
	}
	this.makeState(this.addNodes([],this.nodes));
};
hxparse_LexEngine.__name__ = true;
hxparse_LexEngine.parse = function(pattern) {
	var p = hxparse_LexEngine.parseInner(haxe_io_Bytes.ofString(pattern));
	if(p == null) {
		throw haxe_Exception.thrown("Invalid pattern '" + pattern + "'");
	}
	return p.pattern;
};
hxparse_LexEngine.next = function(a,b) {
	if(a == hxparse__$LexEngine_Pattern.Empty) {
		return b;
	} else {
		return hxparse__$LexEngine_Pattern.Next(a,b);
	}
};
hxparse_LexEngine.plus = function(r) {
	if(r._hx_index == 4) {
		return hxparse__$LexEngine_Pattern.Next(r.p1,hxparse_LexEngine.plus(r.p2));
	} else {
		return hxparse__$LexEngine_Pattern.Plus(r);
	}
};
hxparse_LexEngine.star = function(r) {
	if(r._hx_index == 4) {
		return hxparse__$LexEngine_Pattern.Next(r.p1,hxparse_LexEngine.star(r.p2));
	} else {
		return hxparse__$LexEngine_Pattern.Star(r);
	}
};
hxparse_LexEngine.opt = function(r) {
	if(r._hx_index == 4) {
		return hxparse__$LexEngine_Pattern.Next(r.p1,hxparse_LexEngine.opt(r.p2));
	} else {
		return hxparse__$LexEngine_Pattern.Choice(r,hxparse__$LexEngine_Pattern.Empty);
	}
};
hxparse_LexEngine.cinter = function(c1,c2) {
	return hxparse_LexEngine.ccomplement(hxparse_LexEngine.cunion(hxparse_LexEngine.ccomplement(c1),hxparse_LexEngine.ccomplement(c2)));
};
hxparse_LexEngine.cdiff = function(c1,c2) {
	return hxparse_LexEngine.ccomplement(hxparse_LexEngine.cunion(hxparse_LexEngine.ccomplement(c1),c2));
};
hxparse_LexEngine.ccomplement = function(c) {
	var first = c[0];
	var start = first != null && first.min == -1 ? c.shift().max + 1 : -1;
	var out = [];
	var _g = 0;
	while(_g < c.length) {
		var k = c[_g];
		++_g;
		out.push(new hxparse__$LexEngine_CharRange(start,k.min - 1));
		start = k.max + 1;
	}
	if(start <= 255) {
		out.push(new hxparse__$LexEngine_CharRange(start,255));
	}
	return out;
};
hxparse_LexEngine.cunion = function(ca,cb) {
	var i = 0;
	var j = 0;
	var out = [];
	i = 1;
	var a = ca[0];
	j = 1;
	var b = cb[0];
	while(true) {
		if(a == null) {
			out.push(b);
			while(j < cb.length) out.push(cb[j++]);
			break;
		}
		if(b == null) {
			out.push(a);
			while(i < ca.length) out.push(ca[i++]);
			break;
		}
		if(a.min <= b.min) {
			if(a.max + 1 < b.min) {
				out.push(a);
				a = ca[i++];
			} else if(a.max < b.max) {
				b = new hxparse__$LexEngine_CharRange(a.min,b.max);
				a = ca[i++];
			} else {
				b = cb[j++];
			}
		} else {
			var tmp = ca;
			ca = cb;
			cb = tmp;
			var tmp1 = j;
			j = i;
			i = tmp1;
			var tmp2 = a;
			a = b;
			b = tmp2;
		}
	}
	return out;
};
hxparse_LexEngine.parseInner = function(pattern,i,pDepth) {
	if(pDepth == null) {
		pDepth = 0;
	}
	if(i == null) {
		i = 0;
	}
	var readChar = function() {
		i += 1;
		var c = pattern.b[i - 1];
		if(c != c) {
			c = 92;
		} else if(c == 120) {
			c = Std.parseInt("0x" + pattern.getString(i,2));
			i += 2;
		} else if(c >= 48 && c <= 57) {
			var v = c - 48;
			while(true) {
				var cNext = pattern.b[i];
				if(cNext >= 48 && cNext <= 57) {
					v = v * 10 + (cNext - 48);
					i += 1;
				} else {
					break;
				}
			}
			c = v;
		}
		return c;
	};
	var r = hxparse__$LexEngine_Pattern.Empty;
	var l = pattern.length;
	while(i < l) {
		i += 1;
		var c = pattern.b[i - 1];
		if(c > 255) {
			throw haxe_Exception.thrown(c);
		}
		switch(c) {
		case 40:
			var r2 = hxparse_LexEngine.parseInner(pattern,i,pDepth + 1);
			i = r2.pos;
			r = hxparse_LexEngine.next(r,r2.pattern);
			break;
		case 41:
			if(r == hxparse__$LexEngine_Pattern.Empty) {
				throw haxe_Exception.thrown("Empty group");
			}
			return { pattern : hxparse__$LexEngine_Pattern.Group(r), pos : i};
		case 42:
			if(r != hxparse__$LexEngine_Pattern.Empty) {
				r = hxparse_LexEngine.star(r);
			} else {
				r = hxparse_LexEngine.next(r,hxparse__$LexEngine_Pattern.Match([new hxparse__$LexEngine_CharRange(c,c)]));
			}
			break;
		case 43:
			if(r != hxparse__$LexEngine_Pattern.Empty) {
				r = hxparse_LexEngine.plus(r);
			} else {
				r = hxparse_LexEngine.next(r,hxparse__$LexEngine_Pattern.Match([new hxparse__$LexEngine_CharRange(c,c)]));
			}
			break;
		case 46:
			r = hxparse_LexEngine.next(r,hxparse__$LexEngine_Pattern.Match(hxparse_LexEngine.ALL_CHARS));
			break;
		case 63:
			if(r != hxparse__$LexEngine_Pattern.Empty) {
				r = hxparse_LexEngine.opt(r);
			} else {
				r = hxparse_LexEngine.next(r,hxparse__$LexEngine_Pattern.Match([new hxparse__$LexEngine_CharRange(c,c)]));
			}
			break;
		case 91:
			if(pattern.length > 1) {
				var range = 0;
				var acc = [];
				var not = pattern.b[i] == 94;
				if(not) {
					i += 1;
				}
				while(true) {
					i += 1;
					var c1 = pattern.b[i - 1];
					if(c1 == 93) {
						if(range != 0) {
							return null;
						}
						break;
					} else if(c1 == 45) {
						if(range != 0) {
							return null;
						}
						var last = acc.pop();
						if(last == null) {
							acc.push(new hxparse__$LexEngine_CharRange(c1,c1));
						} else {
							if(last.min != last.max) {
								return null;
							}
							range = last.min;
						}
					} else {
						if(c1 == 92) {
							c1 = readChar();
						}
						if(range == 0) {
							acc.push(new hxparse__$LexEngine_CharRange(c1,c1));
						} else {
							acc.push(new hxparse__$LexEngine_CharRange(range,c1));
							range = 0;
						}
					}
				}
				var g = [];
				var _g = 0;
				while(_g < acc.length) g = hxparse_LexEngine.cunion(g,[acc[_g++]]);
				if(not) {
					g = hxparse_LexEngine.cdiff(hxparse_LexEngine.ALL_CHARS,g);
				}
				r = hxparse_LexEngine.next(r,hxparse__$LexEngine_Pattern.Match(g));
			} else {
				r = hxparse_LexEngine.next(r,hxparse__$LexEngine_Pattern.Match([new hxparse__$LexEngine_CharRange(c,c)]));
			}
			break;
		case 92:
			c = readChar();
			r = hxparse_LexEngine.next(r,hxparse__$LexEngine_Pattern.Match([new hxparse__$LexEngine_CharRange(c,c)]));
			break;
		case 124:
			if(r != hxparse__$LexEngine_Pattern.Empty) {
				var r21 = hxparse_LexEngine.parseInner(pattern,i);
				return { pattern : hxparse__$LexEngine_Pattern.Choice(r,r21.pattern), pos : r21.pos};
			} else {
				r = hxparse_LexEngine.next(r,hxparse__$LexEngine_Pattern.Match([new hxparse__$LexEngine_CharRange(c,c)]));
			}
			break;
		default:
			r = hxparse_LexEngine.next(r,hxparse__$LexEngine_Pattern.Match([new hxparse__$LexEngine_CharRange(c,c)]));
		}
	}
	if(pDepth != 0) {
		throw haxe_Exception.thrown("Found unclosed parenthesis while parsing \"" + Std.string(pattern) + "\"");
	}
	return { pattern : r, pos : i};
};
hxparse_LexEngine.prototype = {
	firstState: function() {
		return this.states[0];
	}
	,makeState: function(nodes) {
		var _gthis = this;
		var buf_b = "";
		var _g = 0;
		while(_g < nodes.length) {
			buf_b += Std.string(nodes[_g++].id);
			buf_b += String.fromCodePoint(45);
		}
		var key = buf_b;
		var s = this.hstates.h[key];
		if(s != null) {
			return s;
		}
		s = new hxparse_State();
		this.states.push(s);
		this.hstates.h[key] = s;
		var trans = this.getTransitions(nodes);
		var _g = 0;
		while(_g < trans.length) {
			var t = trans[_g];
			++_g;
			var target = this.makeState(t.n);
			var _g1 = 0;
			var _g2 = t.chars;
			while(_g1 < _g2.length) {
				var chr = _g2[_g1];
				++_g1;
				var _g3 = chr.min;
				var _g4 = chr.max + 1;
				while(_g3 < _g4) s.trans[_g3++] = target;
			}
		}
		var setFinal = function() {
			var _g = 0;
			var _g1 = _gthis.finals;
			while(_g < _g1.length) {
				var f = _g1[_g++];
				var _g2 = 0;
				while(_g2 < nodes.length) {
					var n = nodes[_g2];
					++_g2;
					if(n == f) {
						s.finalId = n.pid;
						return;
					}
				}
			}
		};
		if(s.finalId == -1) {
			setFinal();
		}
		return s;
	}
	,getTransitions: function(nodes) {
		var tl = [];
		var _g = 0;
		while(_g < nodes.length) {
			var _g1 = 0;
			var _g2 = nodes[_g++].trans;
			while(_g1 < _g2.length) tl.push(_g2[_g1++]);
		}
		tl.sort(function(t1,t2) {
			return t1.n.id - t2.n.id;
		});
		var t0 = tl[0];
		var _g = 1;
		var _g1 = tl.length;
		while(_g < _g1) {
			var i = _g++;
			var t1 = tl[i];
			if(t0.n == t1.n) {
				tl[i - 1] = null;
				t1 = { chars : hxparse_LexEngine.cunion(t0.chars,t1.chars), n : t1.n};
				tl[i] = t1;
			}
			t0 = t1;
		}
		while(HxOverrides.remove(tl,null)) {
		}
		var allChars = hxparse_LexEngine.EMPTY;
		var allStates = new haxe_ds_List();
		var _g = 0;
		while(_g < tl.length) {
			var t = tl[_g];
			++_g;
			var states = new haxe_ds_List();
			states.push({ chars : hxparse_LexEngine.cdiff(t.chars,allChars), n : [t.n]});
			var _g3_head = allStates.h;
			while(_g3_head != null) {
				var val = _g3_head.item;
				_g3_head = _g3_head.next;
				var nodes = val.n.slice();
				nodes.push(t.n);
				states.push({ chars : hxparse_LexEngine.cinter(val.chars,t.chars), n : nodes});
				states.push({ chars : hxparse_LexEngine.cdiff(val.chars,t.chars), n : val.n});
			}
			var _g4_head = states.h;
			while(_g4_head != null) {
				var val1 = _g4_head.item;
				_g4_head = _g4_head.next;
				if(val1.chars.length == 0) {
					states.remove(val1);
				}
			}
			allChars = hxparse_LexEngine.cunion(allChars,t.chars);
			allStates = states;
		}
		var states = [];
		var _g4_head = allStates.h;
		while(_g4_head != null) {
			var val = _g4_head.item;
			_g4_head = _g4_head.next;
			states.push({ chars : val.chars, n : this.addNodes([],val.n)});
		}
		states.sort(function(s1,s2) {
			var a = s1.chars.length;
			var b = s2.chars.length;
			var _g = 0;
			var _g1 = a < b ? a : b;
			while(_g < _g1) {
				var i = _g++;
				var a1 = s1.chars[i];
				var b1 = s2.chars[i];
				if(a1.min != b1.min) {
					return b1.min - a1.min;
				}
				if(a1.max != b1.max) {
					return b1.max - a1.max;
				}
			}
			if(a < b) {
				return b - a;
			}
			return 0;
		});
		return states;
	}
	,addNode: function(nodes,n) {
		var _g = 0;
		while(_g < nodes.length) if(n == nodes[_g++]) {
			return;
		}
		nodes.push(n);
		this.addNodes(nodes,n.epsilon);
	}
	,addNodes: function(nodes,add) {
		var _g = 0;
		while(_g < add.length) this.addNode(nodes,add[_g++]);
		return nodes;
	}
	,initNode: function(p,finalId,pid) {
		switch(p._hx_index) {
		case 0:
			return finalId;
		case 1:
			var n = new hxparse__$LexEngine_Node(this.uid++,pid);
			n.trans.push({ chars : p.c, n : finalId});
			return n;
		case 2:
			var n = new hxparse__$LexEngine_Node(this.uid++,pid);
			var an = this.initNode(p.p,n,pid);
			n.epsilon.push(an);
			n.epsilon.push(finalId);
			return n;
		case 3:
			var n = new hxparse__$LexEngine_Node(this.uid++,pid);
			var an = this.initNode(p.p,n,pid);
			n.epsilon.push(an);
			n.epsilon.push(finalId);
			return an;
		case 4:
			return this.initNode(p.p1,this.initNode(p.p2,finalId,pid),pid);
		case 5:
			var n = new hxparse__$LexEngine_Node(this.uid++,pid);
			n.epsilon.push(this.initNode(p.p1,finalId,pid));
			n.epsilon.push(this.initNode(p.p2,finalId,pid));
			return n;
		case 6:
			return this.initNode(p.p,finalId,pid);
		}
	}
	,__class__: hxparse_LexEngine
};
var hxparse__$LexEngine_Pattern = $hxEnums["hxparse._LexEngine.Pattern"] = { __ename__ : true, __constructs__ : ["Empty","Match","Star","Plus","Next","Choice","Group"]
	,Empty: {_hx_index:0,__enum__:"hxparse._LexEngine.Pattern",toString:$estr}
	,Match: ($_=function(c) { return {_hx_index:1,c:c,__enum__:"hxparse._LexEngine.Pattern",toString:$estr}; },$_.__params__ = ["c"],$_)
	,Star: ($_=function(p) { return {_hx_index:2,p:p,__enum__:"hxparse._LexEngine.Pattern",toString:$estr}; },$_.__params__ = ["p"],$_)
	,Plus: ($_=function(p) { return {_hx_index:3,p:p,__enum__:"hxparse._LexEngine.Pattern",toString:$estr}; },$_.__params__ = ["p"],$_)
	,Next: ($_=function(p1,p2) { return {_hx_index:4,p1:p1,p2:p2,__enum__:"hxparse._LexEngine.Pattern",toString:$estr}; },$_.__params__ = ["p1","p2"],$_)
	,Choice: ($_=function(p1,p2) { return {_hx_index:5,p1:p1,p2:p2,__enum__:"hxparse._LexEngine.Pattern",toString:$estr}; },$_.__params__ = ["p1","p2"],$_)
	,Group: ($_=function(p) { return {_hx_index:6,p:p,__enum__:"hxparse._LexEngine.Pattern",toString:$estr}; },$_.__params__ = ["p"],$_)
};
var js_Boot = function() { };
js_Boot.__name__ = true;
js_Boot.getClass = function(o) {
	if(o == null) {
		return null;
	} else if(((o) instanceof Array)) {
		return Array;
	} else {
		var cl = o.__class__;
		if(cl != null) {
			return cl;
		}
		var name = js_Boot.__nativeClassName(o);
		if(name != null) {
			return js_Boot.__resolveNativeClass(name);
		}
		return null;
	}
};
js_Boot.__string_rec = function(o,s) {
	if(o == null) {
		return "null";
	}
	if(s.length >= 5) {
		return "<...>";
	}
	var t = typeof(o);
	if(t == "function" && (o.__name__ || o.__ename__)) {
		t = "object";
	}
	switch(t) {
	case "function":
		return "<function>";
	case "object":
		if(o.__enum__) {
			var e = $hxEnums[o.__enum__];
			var n = e.__constructs__[o._hx_index];
			var con = e[n];
			if(con.__params__) {
				s = s + "\t";
				return n + "(" + ((function($this) {
					var $r;
					var _g = [];
					{
						var _g1 = 0;
						var _g2 = con.__params__;
						while(true) {
							if(!(_g1 < _g2.length)) {
								break;
							}
							var p = _g2[_g1];
							_g1 = _g1 + 1;
							_g.push(js_Boot.__string_rec(o[p],s));
						}
					}
					$r = _g;
					return $r;
				}(this))).join(",") + ")";
			} else {
				return n;
			}
		}
		if(((o) instanceof Array)) {
			var str = "[";
			s += "\t";
			var _g = 0;
			var _g1 = o.length;
			while(_g < _g1) {
				var i = _g++;
				str += (i > 0 ? "," : "") + js_Boot.__string_rec(o[i],s);
			}
			str += "]";
			return str;
		}
		var tostr;
		try {
			tostr = o.toString;
		} catch( _g ) {
			haxe_NativeStackTrace.lastError = _g;
			return "???";
		}
		if(tostr != null && tostr != Object.toString && typeof(tostr) == "function") {
			var s2 = o.toString();
			if(s2 != "[object Object]") {
				return s2;
			}
		}
		var str = "{\n";
		s += "\t";
		var hasp = o.hasOwnProperty != null;
		var k = null;
		for( k in o ) {
		if(hasp && !o.hasOwnProperty(k)) {
			continue;
		}
		if(k == "prototype" || k == "__class__" || k == "__super__" || k == "__interfaces__" || k == "__properties__") {
			continue;
		}
		if(str.length != 2) {
			str += ", \n";
		}
		str += s + k + " : " + js_Boot.__string_rec(o[k],s);
		}
		s = s.substring(1);
		str += "\n" + s + "}";
		return str;
	case "string":
		return o;
	default:
		return String(o);
	}
};
js_Boot.__interfLoop = function(cc,cl) {
	while(true) {
		if(cc == null) {
			return false;
		}
		if(cc == cl) {
			return true;
		}
		var intf = cc.__interfaces__;
		if(intf != null) {
			var _g = 0;
			var _g1 = intf.length;
			while(_g < _g1) {
				var i = intf[_g++];
				if(i == cl || js_Boot.__interfLoop(i,cl)) {
					return true;
				}
			}
		}
		cc = cc.__super__;
	}
};
js_Boot.__instanceof = function(o,cl) {
	if(cl == null) {
		return false;
	}
	switch(cl) {
	case Array:
		return ((o) instanceof Array);
	case Bool:
		return typeof(o) == "boolean";
	case Dynamic:
		return o != null;
	case Float:
		return typeof(o) == "number";
	case Int:
		if(typeof(o) == "number") {
			return ((o | 0) === o);
		} else {
			return false;
		}
		break;
	case String:
		return typeof(o) == "string";
	default:
		if(o != null) {
			if(typeof(cl) == "function") {
				if(js_Boot.__downcastCheck(o,cl)) {
					return true;
				}
			} else if(typeof(cl) == "object" && js_Boot.__isNativeObj(cl)) {
				if(((o) instanceof cl)) {
					return true;
				}
			}
		} else {
			return false;
		}
		if(cl == Class ? o.__name__ != null : false) {
			return true;
		}
		if(cl == Enum ? o.__ename__ != null : false) {
			return true;
		}
		return o.__enum__ != null ? $hxEnums[o.__enum__] == cl : false;
	}
};
js_Boot.__downcastCheck = function(o,cl) {
	if(!((o) instanceof cl)) {
		if(cl.__isInterface__) {
			return js_Boot.__interfLoop(js_Boot.getClass(o),cl);
		} else {
			return false;
		}
	} else {
		return true;
	}
};
js_Boot.__nativeClassName = function(o) {
	var name = js_Boot.__toStr.call(o).slice(8,-1);
	if(name == "Object" || name == "Function" || name == "Math" || name == "JSON") {
		return null;
	}
	return name;
};
js_Boot.__isNativeObj = function(o) {
	return js_Boot.__nativeClassName(o) != null;
};
js_Boot.__resolveNativeClass = function(name) {
	return $global[name];
};
var hxparse__$LexEngine_Node = function(id,pid) {
	this.id = id;
	this.pid = pid;
	this.trans = [];
	this.epsilon = [];
};
hxparse__$LexEngine_Node.__name__ = true;
hxparse__$LexEngine_Node.prototype = {
	__class__: hxparse__$LexEngine_Node
};
var hxparse_Ruleset = function(state,functions,eofFunction,name) {
	if(name == null) {
		name = "";
	}
	this.state = state;
	this.functions = functions;
	this.eofFunction = eofFunction;
	this.name = name;
};
hxparse_Ruleset.__name__ = true;
hxparse_Ruleset.prototype = {
	__class__: hxparse_Ruleset
};
var hxparse_Position = function(source,min,max) {
	this.psource = source;
	this.pmin = min;
	this.pmax = max;
};
hxparse_Position.__name__ = true;
hxparse_Position.prototype = {
	toString: function() {
		return "" + this.psource + ":characters " + this.pmin + "-" + this.pmax;
	}
	,getLinePosition: function(input) {
		var lineMin = 1;
		var lineMax = 1;
		var posMin = 0;
		var posMax = 0;
		var cur = 0;
		while(cur < this.pmin) {
			if(input.b[cur] == 10) {
				++lineMin;
				posMin = cur + 1;
			}
			++cur;
		}
		lineMax = lineMin;
		posMax = posMin;
		posMin = cur - posMin;
		while(cur < this.pmax) {
			if(input.b[cur] == 10) {
				++lineMax;
				posMax = cur + 1;
			}
			++cur;
		}
		posMax = cur - posMax;
		return { lineMin : lineMin, lineMax : lineMax, posMin : posMin, posMax : posMax};
	}
	,format: function(input) {
		var linePos = this.getLinePosition(input);
		if(linePos.lineMin != linePos.lineMax) {
			return "" + this.psource + ":lines " + linePos.lineMin + "-" + linePos.lineMax;
		} else {
			return "" + this.psource + ":" + linePos.lineMin + ": characters " + linePos.posMin + "-" + linePos.posMax;
		}
	}
	,__class__: hxparse_Position
};
var haxeparser_HaxeLexer = function(input,sourceName) {
	hxparse_Lexer.call(this,input,sourceName);
};
haxeparser_HaxeLexer.__name__ = true;
haxeparser_HaxeLexer.__interfaces__ = [hxparse_RuleBuilder];
haxeparser_HaxeLexer.mkPos = function(p) {
	return { file : p.psource, min : p.pmin, max : p.pmax};
};
haxeparser_HaxeLexer.mk = function(lexer,td) {
	return new haxeparser_Token(td,haxeparser_HaxeLexer.mkPos(new hxparse_Position(lexer.source,lexer.pos - lexer.current.length,lexer.pos)));
};
haxeparser_HaxeLexer.unescape = function(s,pos) {
	var b_b = "";
	var i = 0;
	var esc = false;
	while(s.length != i) {
		var c = HxOverrides.cca(s,i);
		if(esc) {
			var iNext = i + 1;
			var _hx_tmp;
			if(c == null) {
				_hx_tmp = c >= 48 && c <= 51;
				if(_hx_tmp == true) {
					iNext += 2;
				} else {
					var c1 = c;
					throw haxe_Exception.thrown(new haxeparser_LexerError(haxeparser_LexerErrorMsg.UnknownEscapeSequence("\\" + String.fromCodePoint(c1)),{ file : pos.file, min : pos.min + i, max : pos.min + i + 1}));
				}
			} else {
				switch(c) {
				case 34:case 39:case 92:
					b_b += String.fromCodePoint(c);
					break;
				case 110:
					b_b += "\n";
					break;
				case 114:
					b_b += "\r";
					break;
				case 116:
					b_b += "\t";
					break;
				case 117:
					_hx_tmp = c >= 48 && c <= 51;
					if(_hx_tmp == true) {
						iNext += 2;
					} else {
						var c2;
						if(s.charAt(i + 1) == "{") {
							var endIndex = s.indexOf("}",i + 3);
							if(endIndex == -1) {
								throw haxe_Exception.thrown(new haxeparser_LexerError(haxeparser_LexerErrorMsg.UnterminatedEscapeSequence,{ file : pos.file, min : pos.min + i, max : pos.min + i + 2}));
							}
							var l = endIndex - (i + 2);
							var chars = HxOverrides.substr(s,i + 2,l);
							if(!new EReg("^[0-9a-fA-F]+$","").match(chars)) {
								throw haxe_Exception.thrown(new haxeparser_LexerError(haxeparser_LexerErrorMsg.InvalidEscapeSequence("\\u{" + chars + "}"),{ file : pos.file, min : pos.min + i, max : pos.min + i + (3 + l)}));
							}
							c2 = Std.parseInt("0x" + chars);
							if(c2 > 1114111) {
								throw haxe_Exception.thrown(new haxeparser_LexerError(haxeparser_LexerErrorMsg.InvalidEscapeSequence("\\u{" + chars + "}"),{ file : pos.file, min : pos.min + i, max : pos.min + i + (3 + l)}));
							}
							iNext += 2 + l;
						} else {
							var chars1 = HxOverrides.substr(s,i + 1,4);
							if(!new EReg("^[0-9a-fA-F]{4}$","").match(chars1)) {
								throw haxe_Exception.thrown(new haxeparser_LexerError(haxeparser_LexerErrorMsg.InvalidEscapeSequence("\\u" + chars1),{ file : pos.file, min : pos.min + i, max : pos.min + i + 5}));
							}
							c2 = Std.parseInt("0x" + chars1);
							iNext += 4;
						}
						b_b += String.fromCodePoint(c2);
					}
					break;
				case 120:
					_hx_tmp = c >= 48 && c <= 51;
					if(_hx_tmp == true) {
						iNext += 2;
					} else {
						var chars2 = HxOverrides.substr(s,i + 1,2);
						if(!new EReg("^[0-9a-fA-F]{2}$","").match(chars2)) {
							throw haxe_Exception.thrown(new haxeparser_LexerError(haxeparser_LexerErrorMsg.InvalidEscapeSequence("\\x" + chars2),{ file : pos.file, min : pos.min + i, max : pos.min + i + 3}));
						}
						var c3 = Std.parseInt("0x" + chars2);
						b_b += String.fromCodePoint(c3);
						iNext += 2;
					}
					break;
				default:
					_hx_tmp = c >= 48 && c <= 51;
					if(_hx_tmp == true) {
						iNext += 2;
					} else {
						var c4 = c;
						throw haxe_Exception.thrown(new haxeparser_LexerError(haxeparser_LexerErrorMsg.UnknownEscapeSequence("\\" + String.fromCodePoint(c4)),{ file : pos.file, min : pos.min + i, max : pos.min + i + 1}));
					}
				}
			}
			esc = false;
			i = iNext;
		} else if(c == null) {
			b_b += String.fromCodePoint(c);
			++i;
		} else if(c == 92) {
			++i;
			esc = true;
		} else {
			b_b += String.fromCodePoint(c);
			++i;
		}
	}
	return b_b;
};
haxeparser_HaxeLexer.__super__ = hxparse_Lexer;
haxeparser_HaxeLexer.prototype = $extend(hxparse_Lexer.prototype,{
	__class__: haxeparser_HaxeLexer
});
var hxjsonast_Error = function(message,pos) {
	this.message = message;
	this.pos = pos;
};
hxjsonast_Error.__name__ = true;
hxjsonast_Error.prototype = {
	__class__: hxjsonast_Error
};
var hxjsonast_Json = function(value,pos) {
	this.value = value;
	this.pos = pos;
};
hxjsonast_Json.__name__ = true;
hxjsonast_Json.prototype = {
	__class__: hxjsonast_Json
};
var hxjsonast_JsonValue = $hxEnums["hxjsonast.JsonValue"] = { __ename__ : true, __constructs__ : ["JString","JNumber","JObject","JArray","JBool","JNull"]
	,JString: ($_=function(s) { return {_hx_index:0,s:s,__enum__:"hxjsonast.JsonValue",toString:$estr}; },$_.__params__ = ["s"],$_)
	,JNumber: ($_=function(s) { return {_hx_index:1,s:s,__enum__:"hxjsonast.JsonValue",toString:$estr}; },$_.__params__ = ["s"],$_)
	,JObject: ($_=function(fields) { return {_hx_index:2,fields:fields,__enum__:"hxjsonast.JsonValue",toString:$estr}; },$_.__params__ = ["fields"],$_)
	,JArray: ($_=function(values) { return {_hx_index:3,values:values,__enum__:"hxjsonast.JsonValue",toString:$estr}; },$_.__params__ = ["values"],$_)
	,JBool: ($_=function(b) { return {_hx_index:4,b:b,__enum__:"hxjsonast.JsonValue",toString:$estr}; },$_.__params__ = ["b"],$_)
	,JNull: {_hx_index:5,__enum__:"hxjsonast.JsonValue",toString:$estr}
};
var hxjsonast_JObjectField = function(name,namePos,value) {
	this.name = name;
	this.namePos = namePos;
	this.value = value;
};
hxjsonast_JObjectField.__name__ = true;
hxjsonast_JObjectField.prototype = {
	__class__: hxjsonast_JObjectField
};
var hxjsonast_Parser = function(source,filename) {
	this.source = source;
	this.filename = filename;
	this.pos = 0;
};
hxjsonast_Parser.__name__ = true;
hxjsonast_Parser.prototype = {
	parseRec: function() {
		while(true) {
			var c = this.source.charCodeAt(this.pos++);
			switch(c) {
			case 9:case 10:case 13:case 32:
				break;
			case 34:
				var save = this.pos;
				return new hxjsonast_Json(hxjsonast_JsonValue.JString(this.parseString()),new hxjsonast_Position(this.filename,save - 1,this.pos));
			case 45:case 48:case 49:case 50:case 51:case 52:case 53:case 54:case 55:case 56:case 57:
				var start = this.pos - 1;
				var minus = c == 45;
				var digit = !minus;
				var zero = c == 48;
				var point = false;
				var e = false;
				var pm = false;
				var end = false;
				while(true) {
					switch(this.source.charCodeAt(this.pos++)) {
					case 43:case 45:
						if(!e || pm) {
							this.invalidNumber(start);
						}
						digit = false;
						pm = true;
						break;
					case 46:
						if(minus || point) {
							this.invalidNumber(start);
						}
						digit = false;
						point = true;
						break;
					case 48:
						if(zero && !point) {
							this.invalidNumber(start);
						}
						if(minus) {
							minus = false;
							zero = true;
						}
						digit = true;
						break;
					case 49:case 50:case 51:case 52:case 53:case 54:case 55:case 56:case 57:
						if(zero && !point) {
							this.invalidNumber(start);
						}
						if(minus) {
							minus = false;
						}
						digit = true;
						zero = false;
						break;
					case 69:case 101:
						if(minus || zero || e) {
							this.invalidNumber(start);
						}
						digit = false;
						e = true;
						break;
					default:
						if(!digit) {
							this.invalidNumber(start);
						}
						this.pos--;
						end = true;
					}
					if(end) {
						break;
					}
				}
				return new hxjsonast_Json(hxjsonast_JsonValue.JNumber(HxOverrides.substr(this.source,start,this.pos - start)),new hxjsonast_Position(this.filename,start,this.pos));
			case 91:
				var values = [];
				var comma = null;
				var startPos = this.pos - 1;
				while(true) switch(this.source.charCodeAt(this.pos++)) {
				case 9:case 10:case 13:case 32:
					break;
				case 44:
					if(comma) {
						comma = false;
					} else {
						this.invalidChar();
					}
					break;
				case 93:
					if(comma == false) {
						this.invalidChar();
					}
					return new hxjsonast_Json(hxjsonast_JsonValue.JArray(values),new hxjsonast_Position(this.filename,startPos,this.pos));
				default:
					if(comma) {
						this.invalidChar();
					}
					this.pos--;
					values.push(this.parseRec());
					comma = true;
				}
				break;
			case 102:
				var save1 = this.pos;
				if(this.source.charCodeAt(this.pos++) != 97 || this.source.charCodeAt(this.pos++) != 108 || this.source.charCodeAt(this.pos++) != 115 || this.source.charCodeAt(this.pos++) != 101) {
					this.pos = save1;
					this.invalidChar();
				}
				return new hxjsonast_Json(hxjsonast_JsonValue.JBool(false),new hxjsonast_Position(this.filename,save1 - 1,this.pos));
			case 110:
				var save2 = this.pos;
				if(this.source.charCodeAt(this.pos++) != 117 || this.source.charCodeAt(this.pos++) != 108 || this.source.charCodeAt(this.pos++) != 108) {
					this.pos = save2;
					this.invalidChar();
				}
				return new hxjsonast_Json(hxjsonast_JsonValue.JNull,new hxjsonast_Position(this.filename,save2 - 1,this.pos));
			case 116:
				var save3 = this.pos;
				if(this.source.charCodeAt(this.pos++) != 114 || this.source.charCodeAt(this.pos++) != 117 || this.source.charCodeAt(this.pos++) != 101) {
					this.pos = save3;
					this.invalidChar();
				}
				return new hxjsonast_Json(hxjsonast_JsonValue.JBool(true),new hxjsonast_Position(this.filename,save3 - 1,this.pos));
			case 123:
				var fields = [];
				var names_h = Object.create(null);
				var field = null;
				var fieldPos = null;
				var comma1 = null;
				var startPos1 = this.pos - 1;
				while(true) switch(this.source.charCodeAt(this.pos++)) {
				case 9:case 10:case 13:case 32:
					break;
				case 34:
					if(comma1) {
						this.invalidChar();
					}
					var fieldStartPos = this.pos - 1;
					field = this.parseString();
					fieldPos = new hxjsonast_Position(this.filename,fieldStartPos,this.pos);
					if(Object.prototype.hasOwnProperty.call(names_h,field)) {
						throw haxe_Exception.thrown(new hxjsonast_Error("Duplicate field name \"" + field + "\"",fieldPos));
					} else {
						names_h[field] = true;
					}
					break;
				case 44:
					if(comma1) {
						comma1 = false;
					} else {
						this.invalidChar();
					}
					break;
				case 58:
					if(field == null) {
						this.invalidChar();
					}
					fields.push(new hxjsonast_JObjectField(field,fieldPos,this.parseRec()));
					field = null;
					fieldPos = null;
					comma1 = true;
					break;
				case 125:
					if(field != null || comma1 == false) {
						this.invalidChar();
					}
					return new hxjsonast_Json(hxjsonast_JsonValue.JObject(fields),new hxjsonast_Position(this.filename,startPos1,this.pos));
				default:
					this.invalidChar();
				}
				break;
			default:
				this.invalidChar();
			}
		}
	}
	,parseString: function() {
		var start = this.pos;
		var buf = null;
		while(true) {
			var c = this.source.charCodeAt(this.pos++);
			if(c == 34) {
				break;
			}
			if(c == 92) {
				if(buf == null) {
					buf = new StringBuf();
				}
				var s = this.source;
				var len = this.pos - start - 1;
				buf.b += len == null ? HxOverrides.substr(s,start,null) : HxOverrides.substr(s,start,len);
				c = this.source.charCodeAt(this.pos++);
				switch(c) {
				case 34:case 47:case 92:
					buf.b += String.fromCodePoint(c);
					break;
				case 98:
					buf.b += String.fromCodePoint(8);
					break;
				case 102:
					buf.b += String.fromCodePoint(12);
					break;
				case 110:
					buf.b += String.fromCodePoint(10);
					break;
				case 114:
					buf.b += String.fromCodePoint(13);
					break;
				case 116:
					buf.b += String.fromCodePoint(9);
					break;
				case 117:
					var uc = Std.parseInt("0x" + HxOverrides.substr(this.source,this.pos,4));
					this.pos += 4;
					buf.b += String.fromCodePoint(uc);
					break;
				default:
					throw haxe_Exception.thrown(new hxjsonast_Error("Invalid escape sequence \\" + String.fromCodePoint(c),new hxjsonast_Position(this.filename,this.pos - 2,this.pos)));
				}
				start = this.pos;
			} else if(c != c) {
				this.pos--;
				throw haxe_Exception.thrown(new hxjsonast_Error("Unclosed string",new hxjsonast_Position(this.filename,start - 1,this.pos)));
			}
		}
		if(buf == null) {
			return HxOverrides.substr(this.source,start,this.pos - start - 1);
		} else {
			var s = this.source;
			var len = this.pos - start - 1;
			buf.b += len == null ? HxOverrides.substr(s,start,null) : HxOverrides.substr(s,start,len);
			return buf.b;
		}
	}
	,invalidChar: function() {
		this.pos--;
		throw haxe_Exception.thrown(new hxjsonast_Error("Invalid character: " + this.source.charAt(this.pos),new hxjsonast_Position(this.filename,this.pos,this.pos + 1)));
	}
	,invalidNumber: function(start) {
		throw haxe_Exception.thrown(new hxjsonast_Error("Invalid number: " + this.source.substring(start,this.pos),new hxjsonast_Position(this.filename,start,this.pos)));
	}
	,__class__: hxjsonast_Parser
};
var hxjsonast_Position = function(file,min,max) {
	this.file = file;
	this.min = min;
	this.max = max;
};
hxjsonast_Position.__name__ = true;
hxjsonast_Position.prototype = {
	__class__: hxjsonast_Position
};
var hxparse_ParserError = function(pos) {
	this.pos = pos;
};
hxparse_ParserError.__name__ = true;
hxparse_ParserError.prototype = {
	toString: function() {
		return "Parser error";
	}
	,__class__: hxparse_ParserError
};
var hxparse_State = function() {
	this.finalId = -1;
	this.trans = new Array(256);
};
hxparse_State.__name__ = true;
hxparse_State.prototype = {
	__class__: hxparse_State
};
var hxparse_UnexpectedChar = function(char,pos) {
	hxparse_ParserError.call(this,pos);
	this.char = char;
};
hxparse_UnexpectedChar.__name__ = true;
hxparse_UnexpectedChar.__super__ = hxparse_ParserError;
hxparse_UnexpectedChar.prototype = $extend(hxparse_ParserError.prototype,{
	toString: function() {
		return "Unexpected " + this.char;
	}
	,__class__: hxparse_UnexpectedChar
});
var js_lib__$ArrayBuffer_ArrayBufferCompat = function() { };
js_lib__$ArrayBuffer_ArrayBufferCompat.__name__ = true;
js_lib__$ArrayBuffer_ArrayBufferCompat.sliceImpl = function(begin,end) {
	var u = new Uint8Array(this,begin,end == null ? null : end - begin);
	var resultArray = new Uint8Array(u.byteLength);
	resultArray.set(u);
	return resultArray.buffer;
};
var js_node_Fs = require("fs");
var js_node_Path = require("path");
var js_node_buffer_Buffer = require("buffer").Buffer;
var js_node_buffer__$Buffer_Helper = function() { };
js_node_buffer__$Buffer_Helper.__name__ = true;
js_node_buffer__$Buffer_Helper.bytesOfBuffer = function(b) {
	var o = Object.create(haxe_io_Bytes.prototype);
	o.length = b.byteLength;
	o.b = b;
	b.bufferValue = b;
	b.hxBytes = o;
	b.bytes = b;
	return o;
};
var json2object_Error = $hxEnums["json2object.Error"] = { __ename__ : true, __constructs__ : ["IncorrectType","IncorrectEnumValue","InvalidEnumConstructor","UninitializedVariable","UnknownVariable","ParserError","CustomFunctionException"]
	,IncorrectType: ($_=function(variable,expected,pos) { return {_hx_index:0,variable:variable,expected:expected,pos:pos,__enum__:"json2object.Error",toString:$estr}; },$_.__params__ = ["variable","expected","pos"],$_)
	,IncorrectEnumValue: ($_=function(value,expected,pos) { return {_hx_index:1,value:value,expected:expected,pos:pos,__enum__:"json2object.Error",toString:$estr}; },$_.__params__ = ["value","expected","pos"],$_)
	,InvalidEnumConstructor: ($_=function(value,expected,pos) { return {_hx_index:2,value:value,expected:expected,pos:pos,__enum__:"json2object.Error",toString:$estr}; },$_.__params__ = ["value","expected","pos"],$_)
	,UninitializedVariable: ($_=function(variable,pos) { return {_hx_index:3,variable:variable,pos:pos,__enum__:"json2object.Error",toString:$estr}; },$_.__params__ = ["variable","pos"],$_)
	,UnknownVariable: ($_=function(variable,pos) { return {_hx_index:4,variable:variable,pos:pos,__enum__:"json2object.Error",toString:$estr}; },$_.__params__ = ["variable","pos"],$_)
	,ParserError: ($_=function(message,pos) { return {_hx_index:5,message:message,pos:pos,__enum__:"json2object.Error",toString:$estr}; },$_.__params__ = ["message","pos"],$_)
	,CustomFunctionException: ($_=function(e,pos) { return {_hx_index:6,e:e,pos:pos,__enum__:"json2object.Error",toString:$estr}; },$_.__params__ = ["e","pos"],$_)
};
var json2object_InternalError = $hxEnums["json2object.InternalError"] = { __ename__ : true, __constructs__ : ["AbstractNoJsonRepresentation","CannotGenerateSchema","HandleExpr","ParsingThrow","UnsupportedAbstractEnumType","UnsupportedEnumAbstractValue","UnsupportedMapKeyType","UnsupportedSchemaObjectType","UnsupportedSchemaType"]
	,AbstractNoJsonRepresentation: ($_=function(name) { return {_hx_index:0,name:name,__enum__:"json2object.InternalError",toString:$estr}; },$_.__params__ = ["name"],$_)
	,CannotGenerateSchema: ($_=function(name) { return {_hx_index:1,name:name,__enum__:"json2object.InternalError",toString:$estr}; },$_.__params__ = ["name"],$_)
	,HandleExpr: {_hx_index:2,__enum__:"json2object.InternalError",toString:$estr}
	,ParsingThrow: {_hx_index:3,__enum__:"json2object.InternalError",toString:$estr}
	,UnsupportedAbstractEnumType: ($_=function(name) { return {_hx_index:4,name:name,__enum__:"json2object.InternalError",toString:$estr}; },$_.__params__ = ["name"],$_)
	,UnsupportedEnumAbstractValue: ($_=function(name) { return {_hx_index:5,name:name,__enum__:"json2object.InternalError",toString:$estr}; },$_.__params__ = ["name"],$_)
	,UnsupportedMapKeyType: ($_=function(name) { return {_hx_index:6,name:name,__enum__:"json2object.InternalError",toString:$estr}; },$_.__params__ = ["name"],$_)
	,UnsupportedSchemaObjectType: ($_=function(name) { return {_hx_index:7,name:name,__enum__:"json2object.InternalError",toString:$estr}; },$_.__params__ = ["name"],$_)
	,UnsupportedSchemaType: ($_=function(type) { return {_hx_index:8,type:type,__enum__:"json2object.InternalError",toString:$estr}; },$_.__params__ = ["type"],$_)
};
var json2object_PositionUtils = function(content) {
	this.linesInfo = [];
	var s = 0;
	var e = 0;
	var i = 0;
	var lineCount = 0;
	while(i < content.length) switch(content.charAt(i)) {
	case "\n":
		e = i;
		this.linesInfo.push({ number : lineCount, start : s, end : e});
		++lineCount;
		++i;
		s = i;
		break;
	case "\r":
		e = i;
		if(content.charAt(i + 1) == "\n") {
			++e;
		}
		this.linesInfo.push({ number : lineCount, start : s, end : e});
		++lineCount;
		i = e + 1;
		s = i;
		break;
	default:
		++i;
	}
	this.linesInfo.push({ number : lineCount, start : s, end : i});
};
json2object_PositionUtils.__name__ = true;
json2object_PositionUtils.prototype = {
	convertPosition: function(position) {
		var min = position.min;
		var max = position.max;
		var pos = { file : position.file, min : min + 1, max : max + 1, lines : []};
		var bounds_min = 0;
		var bounds_max = this.linesInfo.length - 1;
		if(min > this.linesInfo[0].end) {
			while(bounds_max > bounds_min) {
				var i = (bounds_min + bounds_max) / 2 | 0;
				var line = this.linesInfo[i];
				if(line.start == min) {
					bounds_min = i;
					bounds_max = i;
				}
				if(line.end < min) {
					bounds_min = i + 1;
				}
				if(line.start > min || line.end >= min && line.start < min) {
					bounds_max = i;
				}
			}
		}
		var _g = bounds_min;
		var _g1 = this.linesInfo.length;
		while(_g < _g1) {
			var line = this.linesInfo[_g++];
			if(line.start <= min && line.end >= max) {
				pos.lines.push({ number : line.number + 1, start : min - line.start + 1, end : max - line.start + 1});
				break;
			}
			if(line.start <= min && min <= line.end) {
				pos.lines.push({ number : line.number + 1, start : min - line.start + 1, end : line.end + 1});
			}
			if(line.start <= max && max <= line.end) {
				pos.lines.push({ number : line.number + 1, start : line.start + 1, end : max - line.start + 1});
			}
			if(line.start >= max || line.end >= max) {
				break;
			}
		}
		return pos;
	}
	,__class__: json2object_PositionUtils
};
var sys_FileSystem = function() { };
sys_FileSystem.__name__ = true;
sys_FileSystem.exists = function(path) {
	try {
		js_node_Fs.accessSync(path);
		return true;
	} catch( _g ) {
		haxe_NativeStackTrace.lastError = _g;
		return false;
	}
};
sys_FileSystem.isDirectory = function(path) {
	try {
		return js_node_Fs.statSync(path).isDirectory();
	} catch( _g ) {
		haxe_NativeStackTrace.lastError = _g;
		return false;
	}
};
var tokentree_ToTokenTreeDef = {};
tokentree_ToTokenTreeDef._new = function(tok) {
	return tok;
};
tokentree_ToTokenTreeDef.toTokenTreeDef = function(this1) {
	return this1;
};
tokentree_ToTokenTreeDef.fromTokenDef = function(tok) {
	var tmp;
	switch(tok._hx_index) {
	case 0:
		tmp = tokentree_TokenTreeDef.Kwd(tok.k);
		break;
	case 1:
		tmp = tokentree_TokenTreeDef.Const(tok.c);
		break;
	case 2:
		tmp = tokentree_TokenTreeDef.Sharp(tok.s);
		break;
	case 3:
		tmp = tokentree_TokenTreeDef.Dollar(tok.s);
		break;
	case 4:
		tmp = tokentree_TokenTreeDef.Unop(tok.op);
		break;
	case 5:
		tmp = tokentree_TokenTreeDef.Binop(tok.op);
		break;
	case 6:
		tmp = tokentree_TokenTreeDef.Comment(tok.s);
		break;
	case 7:
		tmp = tokentree_TokenTreeDef.CommentLine(tok.s);
		break;
	case 8:
		tmp = tokentree_TokenTreeDef.IntInterval(tok.s);
		break;
	case 9:
		tmp = tokentree_TokenTreeDef.Semicolon;
		break;
	case 10:
		tmp = tokentree_TokenTreeDef.Dot;
		break;
	case 11:
		tmp = tokentree_TokenTreeDef.DblDot;
		break;
	case 12:
		tmp = tokentree_TokenTreeDef.Arrow;
		break;
	case 13:
		tmp = tokentree_TokenTreeDef.Comma;
		break;
	case 14:
		tmp = tokentree_TokenTreeDef.BkOpen;
		break;
	case 15:
		tmp = tokentree_TokenTreeDef.BkClose;
		break;
	case 16:
		tmp = tokentree_TokenTreeDef.BrOpen;
		break;
	case 17:
		tmp = tokentree_TokenTreeDef.BrClose;
		break;
	case 18:
		tmp = tokentree_TokenTreeDef.POpen;
		break;
	case 19:
		tmp = tokentree_TokenTreeDef.PClose;
		break;
	case 20:
		tmp = tokentree_TokenTreeDef.Question;
		break;
	case 21:
		tmp = tokentree_TokenTreeDef.At;
		break;
	case 22:
		tmp = tokentree_TokenTreeDef.Eof;
		break;
	}
	return tokentree_ToTokenTreeDef._new(tmp);
};
var tokentree_TokenStreamMode = $hxEnums["tokentree.TokenStreamMode"] = { __ename__ : true, __constructs__ : ["Strict","Relaxed"]
	,Strict: {_hx_index:0,__enum__:"tokentree.TokenStreamMode",toString:$estr}
	,Relaxed: {_hx_index:1,__enum__:"tokentree.TokenStreamMode",toString:$estr}
};
var tokentree_TokenStream = function(tokens,bytes) {
	this.tokens = tokens;
	this.bytes = bytes;
	this.sharpIfStack = [];
	this.tempStore = [];
	this.current = 0;
};
tokentree_TokenStream.__name__ = true;
tokentree_TokenStream.prototype = {
	hasMore: function() {
		return this.current < this.tokens.length;
	}
	,consumeToken: function() {
		if(this.current < 0 || this.current >= this.tokens.length) {
			switch(tokentree_TokenStream.MODE._hx_index) {
			case 0:
				throw haxe_Exception.thrown("no more tokens");
			case 1:
				return this.createDummyToken(tokentree_TokenTreeDef.CommentLine("auto insert"));
			}
		}
		var token = this.tokens[this.current];
		this.current++;
		return new tokentree_TokenTree(tokentree_ToTokenTreeDef.toTokenTreeDef(tokentree_ToTokenTreeDef.fromTokenDef(token.tok)),"",token.pos,this.current - 1);
	}
	,consumeConstIdent: function() {
		var _g = this.token();
		switch(_g._hx_index) {
		case 2:
			if(_g.c._hx_index == 3) {
				return this.consumeToken();
			} else {
				switch(tokentree_TokenStream.MODE._hx_index) {
				case 0:
					var s = "bad token " + Std.string(this.token()) + " != Const(CIdent(_))";
					throw haxe_Exception.thrown(this.formatCurrentPos() + ": " + s);
				case 1:
					return this.createDummyToken(tokentree_TokenTreeDef.Const(haxe_macro_Constant.CIdent("autoInsert")));
				}
			}
			break;
		case 4:
			return this.consumeToken();
		default:
			switch(tokentree_TokenStream.MODE._hx_index) {
			case 0:
				var s = "bad token " + Std.string(this.token()) + " != Const(CIdent(_))";
				throw haxe_Exception.thrown(this.formatCurrentPos() + ": " + s);
			case 1:
				return this.createDummyToken(tokentree_TokenTreeDef.Const(haxe_macro_Constant.CIdent("autoInsert")));
			}
		}
	}
	,consumeConst: function() {
		if(this.token()._hx_index == 2) {
			return this.consumeToken();
		} else {
			switch(tokentree_TokenStream.MODE._hx_index) {
			case 0:
				var s = "bad token " + Std.string(this.token()) + " != Const(_)";
				throw haxe_Exception.thrown(this.formatCurrentPos() + ": " + s);
			case 1:
				return this.createDummyToken(tokentree_TokenTreeDef.Const(haxe_macro_Constant.CString("autoInsert")));
			}
		}
	}
	,consumeTokenDef: function(tokenDef) {
		if(this.matches(tokenDef)) {
			return this.consumeToken();
		}
		switch(tokentree_TokenStream.MODE._hx_index) {
		case 0:
			var s = "bad token " + Std.string(this.token()) + " != " + Std.string(tokenDef);
			throw haxe_Exception.thrown(this.formatCurrentPos() + ": " + s);
		case 1:
			return this.createDummyToken(tokenDef);
		}
	}
	,consumeToTempStore: function() {
		this.tempStore.push(this.consumeToken());
	}
	,addToTempStore: function(token) {
		this.tempStore.push(token);
	}
	,applyTempStore: function(parent) {
		while(this.tempStore.length > 0) parent.addChild(this.tempStore.shift());
	}
	,hasTempStore: function() {
		return this.tempStore.length > 0;
	}
	,getTempStore: function() {
		return this.tempStore;
	}
	,clearTempStore: function() {
		this.tempStore = [];
	}
	,formatCurrentPos: function() {
		var pos = this.tokens[this.current].pos;
		return new hxparse_Position(pos.file,pos.min,pos.max).format(this.bytes);
	}
	,matches: function(tokenDef) {
		if(this.current < 0 || this.current >= this.tokens.length) {
			return false;
		}
		return Type.enumEq(tokenDef,tokentree_ToTokenTreeDef.toTokenTreeDef(tokentree_ToTokenTreeDef.fromTokenDef(this.tokens[this.current].tok)));
	}
	,isSharp: function() {
		if(this.current < 0 || this.current >= this.tokens.length) {
			return false;
		}
		if(this.tokens[this.current].tok._hx_index == 2) {
			return true;
		} else {
			return false;
		}
	}
	,isTypedParam: function() {
		if(this.current < 0 || this.current >= this.tokens.length) {
			return false;
		}
		var index = this.current + 1;
		var token = this.tokens[this.current];
		var _g = token.tok;
		if(_g._hx_index == 5) {
			if(_g.op._hx_index != 9) {
				return false;
			}
		} else {
			return false;
		}
		var depth = 1;
		var brDepth = 0;
		var bkDepth = 0;
		var pDepth = 0;
		while(true) {
			token = this.tokens[index++];
			var _g = token.tok;
			switch(_g._hx_index) {
			case 1:
				break;
			case 3:
				break;
			case 5:
				switch(_g.op._hx_index) {
				case 7:
					--depth;
					if(depth <= 0) {
						return true;
					}
					break;
				case 9:
					++depth;
					break;
				default:
					return false;
				}
				break;
			case 10:
				break;
			case 11:
				break;
			case 12:
				break;
			case 13:
				break;
			case 14:
				++bkDepth;
				break;
			case 15:
				if(bkDepth <= 0) {
					return false;
				}
				--bkDepth;
				break;
			case 16:
				++brDepth;
				break;
			case 17:
				if(brDepth <= 0) {
					return false;
				}
				--brDepth;
				break;
			case 18:
				++pDepth;
				break;
			case 19:
				if(pDepth <= 0) {
					return false;
				}
				--pDepth;
				break;
			default:
				return false;
			}
			if(index >= this.tokens.length) {
				return false;
			}
		}
	}
	,token: function() {
		if(this.current < 0 || this.current >= this.tokens.length) {
			switch(tokentree_TokenStream.MODE._hx_index) {
			case 0:
				throw haxe_Exception.thrown("no more tokens");
			case 1:
				return tokentree_TokenTreeDef.CommentLine("auto insert");
			}
		}
		return tokentree_ToTokenTreeDef.toTokenTreeDef(tokentree_ToTokenTreeDef.fromTokenDef(this.tokens[this.current].tok));
	}
	,tokenForMatch: function() {
		if(this.current < 0 || this.current >= this.tokens.length) {
			return tokentree_TokenTreeDef.Root;
		}
		return tokentree_ToTokenTreeDef.toTokenTreeDef(tokentree_ToTokenTreeDef.fromTokenDef(this.tokens[this.current].tok));
	}
	,peekNonCommentToken: function() {
		if(this.current < 0 || this.current >= this.tokens.length) {
			switch(tokentree_TokenStream.MODE._hx_index) {
			case 0:
				throw haxe_Exception.thrown("no more tokens");
			case 1:
				return tokentree_TokenTreeDef.Const(haxe_macro_Constant.CString("auto insert"));
			}
		}
		var index = this.current;
		while(index < this.tokens.length) {
			var token = this.tokens[index++];
			if(haxeparser_Token == null) {
				continue;
			}
			switch(token.tok._hx_index) {
			case 6:
				break;
			case 7:
				break;
			default:
				return tokentree_ToTokenTreeDef.toTokenTreeDef(tokentree_ToTokenTreeDef.fromTokenDef(token.tok));
			}
		}
		return tokentree_TokenTreeDef.Root;
	}
	,getTokenPos: function() {
		if(this.current < 0 || this.current >= this.tokens.length) {
			return null;
		}
		return this.tokens[this.current].pos;
	}
	,getStreamIndex: function() {
		return this.current;
	}
	,rewindTo: function(pos) {
		this.current = pos;
	}
	,consumeOpGt: function() {
		var tok = this.consumeTokenDef(tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpGt));
		var _g = this.token();
		if(_g._hx_index == 6) {
			switch(_g.op._hx_index) {
			case 4:
				var assignTok = this.consumeToken();
				return new tokentree_TokenTree(tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpGte),tok.space + assignTok.space,{ file : tok.pos.file, min : tok.pos.min, max : assignTok.pos.max},tok.index);
			case 7:
				return this.consumeOpShr(tok);
			default:
				return tok;
			}
		} else {
			return tok;
		}
	}
	,consumeOpShr: function(parent) {
		var tok = this.consumeTokenDef(tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpGt));
		var _g = this.token();
		if(_g._hx_index == 6) {
			switch(_g.op._hx_index) {
			case 4:
				var assignTok = this.consumeToken();
				return new tokentree_TokenTree(tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpAssignOp(haxe_macro_Binop.OpShr)),assignTok.space,{ file : parent.pos.file, min : parent.pos.min, max : assignTok.pos.max},parent.index);
			case 7:
				var innerGt = this.consumeToken();
				var _g = this.token();
				if(_g._hx_index == 6) {
					if(_g.op._hx_index == 4) {
						var assignTok = this.consumeToken();
						return new tokentree_TokenTree(tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpAssignOp(haxe_macro_Binop.OpUShr)),assignTok.space,{ file : parent.pos.file, min : parent.pos.min, max : assignTok.pos.max},parent.index);
					}
				}
				return new tokentree_TokenTree(tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpUShr),innerGt.space,{ file : parent.pos.file, min : parent.pos.min, max : innerGt.pos.max},parent.index);
			default:
				return new tokentree_TokenTree(tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpShr),tok.space,{ file : parent.pos.file, min : parent.pos.min, max : tok.pos.max},parent.index);
			}
		} else {
			return new tokentree_TokenTree(tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpShr),tok.space,{ file : parent.pos.file, min : parent.pos.min, max : tok.pos.max},parent.index);
		}
	}
	,consumeOpSub: function(parent) {
		var tok = this.consumeTokenDef(tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpSub));
		var _g = this.token();
		if(_g._hx_index == 2) {
			switch(_g.c._hx_index) {
			case 0:
				break;
			case 1:
				break;
			default:
				return new tokentree_TokenTree(tok.tok,tok.space,tok.pos,tok.index);
			}
		} else {
			return new tokentree_TokenTree(tok.tok,tok.space,tok.pos,tok.index);
		}
		var previous = this.current - 2;
		if(previous < 0) {
			throw haxe_Exception.thrown("no more tokens");
		}
		var _g = this.tokens[previous].tok;
		switch(_g._hx_index) {
		case 0:
			switch(_g.k._hx_index) {
			case 3:case 4:case 5:case 6:case 7:case 10:case 15:case 29:
				break;
			default:
				return new tokentree_TokenTree(tok.tok,tok.space,tok.pos,tok.index);
			}
			break;
		case 4:
			break;
		case 5:
			break;
		case 8:
			break;
		case 9:case 11:case 13:case 14:case 16:case 18:case 20:
			break;
		case 19:
			if(parent == null || parent.tok == tokentree_TokenTreeDef.Root) {
				return new tokentree_TokenTree(tok.tok,tok.space,tok.pos,tok.index);
			}
			var _g = parent.tok;
			if(_g._hx_index == 1) {
				switch(_g.k._hx_index) {
				case 3:case 4:case 5:case 6:case 7:case 21:
					break;
				default:
					return new tokentree_TokenTree(tok.tok,tok.space,tok.pos,tok.index);
				}
			} else {
				return new tokentree_TokenTree(tok.tok,tok.space,tok.pos,tok.index);
			}
			break;
		default:
			return new tokentree_TokenTree(tok.tok,tok.space,tok.pos,tok.index);
		}
		var _g = this.token();
		if(_g._hx_index == 2) {
			var _g1 = _g.c;
			switch(_g1._hx_index) {
			case 0:
				var $const = this.consumeConst();
				return new tokentree_TokenTree(tokentree_TokenTreeDef.Const(haxe_macro_Constant.CInt("-" + _g1.v)),$const.space,{ file : tok.pos.file, min : tok.pos.min, max : $const.pos.max},tok.index);
			case 1:
				var $const = this.consumeConst();
				return new tokentree_TokenTree(tokentree_TokenTreeDef.Const(haxe_macro_Constant.CFloat("-" + _g1.f)),$const.space,{ file : tok.pos.file, min : tok.pos.min, max : $const.pos.max},tok.index);
			default:
				throw haxe_Exception.thrown("no more tokens");
			}
		} else {
			throw haxe_Exception.thrown("no more tokens");
		}
	}
	,pushSharpIf: function(token) {
		this.sharpIfStack.push(token);
	}
	,popSharpIf: function() {
		var token = this.sharpIfStack.pop();
		if(token == null) {
			switch(tokentree_TokenStream.MODE._hx_index) {
			case 0:
				throw haxe_Exception.thrown("no more tokens");
			case 1:
				return this.createDummyToken(tokentree_TokenTreeDef.CommentLine("dummy token"));
			}
		}
		return token;
	}
	,peekSharpIf: function() {
		if(this.sharpIfStack.length <= 0) {
			switch(tokentree_TokenStream.MODE._hx_index) {
			case 0:
				throw haxe_Exception.thrown("no more tokens");
			case 1:
				return this.createDummyToken(tokentree_TokenTreeDef.CommentLine("dummy token"));
			}
		}
		return this.sharpIfStack[this.sharpIfStack.length - 1];
	}
	,createDummyToken: function(tokDef) {
		var pos;
		if(this.current < 0 || this.current >= this.tokens.length) {
			var prevPos = this.tokens[this.tokens.length - 1].pos;
			pos = { min : prevPos.max, max : prevPos.max, file : prevPos.file};
		} else {
			var prevPos = this.tokens[this.current].pos;
			pos = { min : prevPos.min, max : prevPos.min, file : prevPos.file};
		}
		return new tokentree_TokenTree(tokDef,"",pos,-1,true);
	}
	,__class__: tokentree_TokenStream
};
var tokentree_TokenStreamProgress = function(stream) {
	this.stream = stream;
	this.pos = -1;
};
tokentree_TokenStreamProgress.__name__ = true;
tokentree_TokenStreamProgress.prototype = {
	streamHasChanged: function() {
		if(this.pos == -1) {
			this.pos = this.stream.getStreamIndex();
			return true;
		}
		var oldPos = this.pos;
		this.pos = this.stream.getStreamIndex();
		return this.pos != oldPos;
	}
	,__class__: tokentree_TokenStreamProgress
};
var tokentree_TokenTree = function(tok,space,pos,index,inserted) {
	if(inserted == null) {
		inserted = false;
	}
	this.tok = tok;
	this.pos = pos;
	this.index = index;
	this.inserted = inserted;
	this.space = space;
	this.tokenTypeCache = { };
};
tokentree_TokenTree.__name__ = true;
tokentree_TokenTree.prototype = {
	isCIdent: function() {
		var _g = this.tok;
		if(_g._hx_index == 2) {
			if(_g.c._hx_index == 3) {
				return true;
			} else {
				return false;
			}
		} else {
			return false;
		}
	}
	,isCIdentOrCString: function() {
		var _g = this.tok;
		if(_g._hx_index == 2) {
			switch(_g.c._hx_index) {
			case 2:
				return true;
			case 3:
				return true;
			default:
				return false;
			}
		} else {
			return false;
		}
	}
	,addChild: function(child) {
		if(child == null) {
			return;
		}
		if(this.children == null) {
			this.children = [];
		}
		if(this.children.length > 0) {
			child.previousSibling = this.children[this.children.length - 1];
			this.children[this.children.length - 1].nextSibling = child;
		}
		this.children.push(child);
		child.parent = this;
	}
	,hasChildren: function() {
		if(this.children == null) {
			return false;
		}
		return this.children.length > 0;
	}
	,getFirstChild: function() {
		if(!this.hasChildren()) {
			return null;
		}
		return this.children[0];
	}
	,getLastChild: function() {
		if(!this.hasChildren()) {
			return null;
		}
		return this.children[this.children.length - 1];
	}
	,getPos: function() {
		if(this.children == null || this.children.length <= 0) {
			return this.pos;
		}
		var fullPos = { file : this.pos.file, min : this.pos.min, max : this.pos.max};
		var childPos;
		var _g = 0;
		var _g1 = this.children;
		while(_g < _g1.length) {
			childPos = _g1[_g++].getPos();
			if(childPos.min < fullPos.min) {
				fullPos.min = childPos.min;
			}
			if(childPos.max > fullPos.max) {
				fullPos.max = childPos.max;
			}
		}
		return fullPos;
	}
	,filterCallback: function(callback) {
		var results = [];
		this.internalFilterCallback(callback,results,0);
		return results;
	}
	,internalFilterCallback: function(callback,results,depth) {
		if(depth == null) {
			depth = 0;
		}
		if(this.tok._hx_index != 0) {
			switch(callback(this,depth)._hx_index) {
			case 0:
				results.push(this);
				return;
			case 1:
				results.push(this);
				break;
			case 2:
				return;
			case 3:
				break;
			}
		}
		if(this.children == null) {
			return;
		}
		var _g = 0;
		var _g1 = this.children;
		while(_g < _g1.length) {
			var child = _g1[_g];
			++_g;
			if(child.tok._hx_index == 3) {
				child.internalFilterCallback(callback,results,depth);
			} else {
				child.internalFilterCallback(callback,results,depth + 1);
			}
		}
	}
	,toString: function() {
		return tokentree_TokenTreeDefPrinter.toString(this.tok);
	}
	,__class__: tokentree_TokenTree
};
var tokentree_FilterResult = $hxEnums["tokentree.FilterResult"] = { __ename__ : true, __constructs__ : ["FoundSkipSubtree","FoundGoDeeper","SkipSubtree","GoDeeper"]
	,FoundSkipSubtree: {_hx_index:0,__enum__:"tokentree.FilterResult",toString:$estr}
	,FoundGoDeeper: {_hx_index:1,__enum__:"tokentree.FilterResult",toString:$estr}
	,SkipSubtree: {_hx_index:2,__enum__:"tokentree.FilterResult",toString:$estr}
	,GoDeeper: {_hx_index:3,__enum__:"tokentree.FilterResult",toString:$estr}
};
var tokentree_TokenTreeAccessHelper = {};
tokentree_TokenTreeAccessHelper.parent = function(this1) {
	if(this1 != null) {
		return this1.parent;
	} else {
		return null;
	}
};
tokentree_TokenTreeAccessHelper.previousSibling = function(this1) {
	if(this1 != null) {
		return this1.previousSibling;
	} else {
		return null;
	}
};
tokentree_TokenTreeAccessHelper.firstChild = function(this1) {
	if(this1 != null) {
		return this1.getFirstChild();
	} else {
		return null;
	}
};
tokentree_TokenTreeAccessHelper.lastChild = function(this1) {
	if(this1 != null) {
		return this1.getLastChild();
	} else {
		return null;
	}
};
tokentree_TokenTreeAccessHelper.firstOf = function(this1,token) {
	if(this1 == null || this1.children == null) {
		return null;
	}
	var _g = 0;
	var _g1 = this1.children;
	while(_g < _g1.length) {
		var tok = _g1[_g];
		++_g;
		if(Type.enumEq(tok.tok,token)) {
			return tok;
		}
	}
	return null;
};
tokentree_TokenTreeAccessHelper.lastOf = function(this1,token) {
	if(this1 == null || this1.children == null) {
		return null;
	}
	var found = null;
	var _g = 0;
	var _g1 = this1.children;
	while(_g < _g1.length) {
		var tok = _g1[_g];
		++_g;
		if(Type.enumEq(tok.tok,token)) {
			found = tok;
		}
	}
	return found;
};
tokentree_TokenTreeAccessHelper.child = function(this1,index) {
	if(this1 != null && this1.children != null) {
		return this1.children[index];
	} else {
		return null;
	}
};
tokentree_TokenTreeAccessHelper.matches = function(this1,tok) {
	if(this1 != null && Type.enumEq(this1.tok,tok)) {
		return this1;
	} else {
		return null;
	}
};
tokentree_TokenTreeAccessHelper.isCIdent = function(this1) {
	if(this1 != null && this1.isCIdent()) {
		return this1;
	} else {
		return null;
	}
};
var tokentree_TokenTreeBuilder = function() { };
tokentree_TokenTreeBuilder.__name__ = true;
tokentree_TokenTreeBuilder.buildTokenTree = function(tokens,bytes,entryPoint) {
	if(entryPoint == null) {
		entryPoint = tokentree_TokenTreeEntryPoint.TypeLevel;
	}
	return tokentree_TokenTreeBuilder.buildTokenTreeFromStream(new tokentree_TokenStream(tokens,bytes),entryPoint);
};
tokentree_TokenTreeBuilder.buildTokenTreeFromStream = function(stream,entryPoint) {
	var root = new tokentree_TokenTree(tokentree_TokenTreeDef.Root,"",null,-1);
	switch(entryPoint._hx_index) {
	case 0:
		tokentree_walk_WalkFile.walkFile(stream,root);
		break;
	case 1:
		tokentree_walk_WalkClass.walkClassBody(stream,root);
		break;
	case 2:
		tokentree_walk_WalkStatement.walkStatement(stream,root);
		break;
	case 3:
		tokentree_walk_WalkTypeNameDef.walkTypeNameDef(stream,root);
		break;
	}
	if(stream.hasMore()) {
		switch(tokentree_TokenStream.MODE._hx_index) {
		case 0:
			throw haxe_Exception.thrown("invalid token tree structure - found:" + Std.string(stream.token()));
		case 1:
			var progress = new tokentree_TokenStreamProgress(stream);
			while(progress.streamHasChanged()) tokentree_walk_WalkStatement.walkStatement(stream,root);
			if(stream.hasMore()) {
				throw haxe_Exception.thrown("invalid token tree structure - found:" + Std.string(stream.token()));
			}
			break;
		}
	}
	var tempStore = stream.getTempStore();
	switch(tokentree_TokenStream.MODE._hx_index) {
	case 0:
		if(tempStore.length != 0) {
			throw haxe_Exception.thrown("invalid token tree structure - tokens in temp store:" + tempStore.join(", "));
		}
		break;
	case 1:
		var _g = 0;
		while(_g < tempStore.length) root.addChild(tempStore[_g++]);
		break;
	}
	return root;
};
var tokentree_TokenTreeEntryPoint = $hxEnums["tokentree.TokenTreeEntryPoint"] = { __ename__ : true, __constructs__ : ["TypeLevel","FieldLevel","ExpressionLevel","TypeHintLevel"]
	,TypeLevel: {_hx_index:0,__enum__:"tokentree.TokenTreeEntryPoint",toString:$estr}
	,FieldLevel: {_hx_index:1,__enum__:"tokentree.TokenTreeEntryPoint",toString:$estr}
	,ExpressionLevel: {_hx_index:2,__enum__:"tokentree.TokenTreeEntryPoint",toString:$estr}
	,TypeHintLevel: {_hx_index:3,__enum__:"tokentree.TokenTreeEntryPoint",toString:$estr}
};
var tokentree_TokenTreeDef = $hxEnums["tokentree.TokenTreeDef"] = { __ename__ : true, __constructs__ : ["Root","Kwd","Const","Sharp","Dollar","Unop","Binop","Comment","CommentLine","IntInterval","Semicolon","Dot","DblDot","Arrow","Comma","BkOpen","BkClose","BrOpen","BrClose","POpen","PClose","Question","At","Eof"]
	,Root: {_hx_index:0,__enum__:"tokentree.TokenTreeDef",toString:$estr}
	,Kwd: ($_=function(k) { return {_hx_index:1,k:k,__enum__:"tokentree.TokenTreeDef",toString:$estr}; },$_.__params__ = ["k"],$_)
	,Const: ($_=function(c) { return {_hx_index:2,c:c,__enum__:"tokentree.TokenTreeDef",toString:$estr}; },$_.__params__ = ["c"],$_)
	,Sharp: ($_=function(s) { return {_hx_index:3,s:s,__enum__:"tokentree.TokenTreeDef",toString:$estr}; },$_.__params__ = ["s"],$_)
	,Dollar: ($_=function(s) { return {_hx_index:4,s:s,__enum__:"tokentree.TokenTreeDef",toString:$estr}; },$_.__params__ = ["s"],$_)
	,Unop: ($_=function(op) { return {_hx_index:5,op:op,__enum__:"tokentree.TokenTreeDef",toString:$estr}; },$_.__params__ = ["op"],$_)
	,Binop: ($_=function(op) { return {_hx_index:6,op:op,__enum__:"tokentree.TokenTreeDef",toString:$estr}; },$_.__params__ = ["op"],$_)
	,Comment: ($_=function(s) { return {_hx_index:7,s:s,__enum__:"tokentree.TokenTreeDef",toString:$estr}; },$_.__params__ = ["s"],$_)
	,CommentLine: ($_=function(s) { return {_hx_index:8,s:s,__enum__:"tokentree.TokenTreeDef",toString:$estr}; },$_.__params__ = ["s"],$_)
	,IntInterval: ($_=function(s) { return {_hx_index:9,s:s,__enum__:"tokentree.TokenTreeDef",toString:$estr}; },$_.__params__ = ["s"],$_)
	,Semicolon: {_hx_index:10,__enum__:"tokentree.TokenTreeDef",toString:$estr}
	,Dot: {_hx_index:11,__enum__:"tokentree.TokenTreeDef",toString:$estr}
	,DblDot: {_hx_index:12,__enum__:"tokentree.TokenTreeDef",toString:$estr}
	,Arrow: {_hx_index:13,__enum__:"tokentree.TokenTreeDef",toString:$estr}
	,Comma: {_hx_index:14,__enum__:"tokentree.TokenTreeDef",toString:$estr}
	,BkOpen: {_hx_index:15,__enum__:"tokentree.TokenTreeDef",toString:$estr}
	,BkClose: {_hx_index:16,__enum__:"tokentree.TokenTreeDef",toString:$estr}
	,BrOpen: {_hx_index:17,__enum__:"tokentree.TokenTreeDef",toString:$estr}
	,BrClose: {_hx_index:18,__enum__:"tokentree.TokenTreeDef",toString:$estr}
	,POpen: {_hx_index:19,__enum__:"tokentree.TokenTreeDef",toString:$estr}
	,PClose: {_hx_index:20,__enum__:"tokentree.TokenTreeDef",toString:$estr}
	,Question: {_hx_index:21,__enum__:"tokentree.TokenTreeDef",toString:$estr}
	,At: {_hx_index:22,__enum__:"tokentree.TokenTreeDef",toString:$estr}
	,Eof: {_hx_index:23,__enum__:"tokentree.TokenTreeDef",toString:$estr}
};
var tokentree_TokenTreeDefPrinter = function() { };
tokentree_TokenTreeDefPrinter.__name__ = true;
tokentree_TokenTreeDefPrinter.toString = function(def) {
	switch(def._hx_index) {
	case 0:
		return "<root>";
	case 1:
		var _g = def.k;
		return HxOverrides.substr($hxEnums[_g.__enum__].__constructs__[_g._hx_index],3,null).toLowerCase();
	case 2:
		var _g = def.c;
		switch(_g._hx_index) {
		case 0:
			return _g.v;
		case 1:
			return _g.f;
		case 2:
			return "\"" + _g.s + "\"";
		case 3:
			return _g.s;
		case 4:
			return "~/" + _g.r + "/" + _g.opt;
		}
		break;
	case 3:
		return "#" + def.s;
	case 4:
		return "$" + def.s;
	case 5:
		return new haxe_macro_Printer("").printUnop(def.op);
	case 6:
		return new haxe_macro_Printer("").printBinop(def.op);
	case 7:
		return "/*" + def.s + "*/";
	case 8:
		return "//" + def.s;
	case 9:
		return "" + def.s + "...";
	case 10:
		return ";";
	case 11:
		return ".";
	case 12:
		return ":";
	case 13:
		return "->";
	case 14:
		return ",";
	case 15:
		return "[";
	case 16:
		return "]";
	case 17:
		return "{";
	case 18:
		return "}";
	case 19:
		return "(";
	case 20:
		return ")";
	case 21:
		return "?";
	case 22:
		return "@";
	case 23:
		return "<eof>";
	}
};
var tokentree_utils_FieldUtils = function() { };
tokentree_utils_FieldUtils.__name__ = true;
tokentree_utils_FieldUtils.getFieldType = function(field,defaultVisibility) {
	if(field == null) {
		return tokentree_utils_TokenFieldType.Unknown;
	}
	var _g = field.tok;
	if(_g._hx_index == 1) {
		switch(_g.k._hx_index) {
		case 0:
			return tokentree_utils_FieldUtils.getFunctionFieldType(field,defaultVisibility);
		case 2:case 41:
			return tokentree_utils_FieldUtils.getVarFieldType(field,defaultVisibility);
		default:
		}
	}
	return tokentree_utils_TokenFieldType.Unknown;
};
tokentree_utils_FieldUtils.getFunctionFieldType = function(field,defaultVisibility) {
	var access = tokentree_TokenTreeAccessHelper.firstChild(field);
	if(access == null) {
		return tokentree_utils_TokenFieldType.Unknown;
	}
	var name = tokentree_utils_TokenTreeCheckUtils.getName(tokentree_utils_TokenTreeCheckUtils.getNameToken(field));
	var visibility = defaultVisibility;
	var isStatic = false;
	var isInline = false;
	var isOverride = false;
	var isFinal = false;
	var isExtern = false;
	if(access.children != null) {
		var _g = 0;
		var _g1 = access.children;
		_hx_loop1: while(_g < _g1.length) {
			var _g2 = _g1[_g++].tok;
			switch(_g2._hx_index) {
			case 1:
				switch(_g2.k._hx_index) {
				case 17:
					isStatic = true;
					break;
				case 18:
					visibility = tokentree_utils_TokenFieldVisibility.Public;
					break;
				case 19:
					visibility = tokentree_utils_TokenFieldVisibility.Private;
					break;
				case 25:
					isExtern = true;
					break;
				case 30:
					isOverride = true;
					break;
				case 34:
					isInline = true;
					break;
				case 41:
					isFinal = true;
					break;
				default:
				}
				break;
			case 17:case 19:
				break _hx_loop1;
			default:
			}
		}
	}
	return tokentree_utils_TokenFieldType.Function(name,visibility,isStatic,isInline,isOverride,isFinal,isExtern);
};
tokentree_utils_FieldUtils.getVarFieldType = function(field,defaultVisibility) {
	var access = tokentree_TokenTreeAccessHelper.firstChild(field);
	if(access == null) {
		return tokentree_utils_TokenFieldType.Unknown;
	}
	var name = tokentree_utils_TokenTreeCheckUtils.getName(tokentree_utils_TokenTreeCheckUtils.getNameToken(field));
	var visibility = defaultVisibility;
	var isStatic = false;
	var isInline = false;
	var _g = field.tok;
	var isFinal = _g._hx_index == 1 && _g.k._hx_index == 41;
	var isExtern = false;
	if(access.children != null) {
		var _g = 0;
		var _g1 = access.children;
		while(_g < _g1.length) {
			var _g2 = _g1[_g++].tok;
			if(_g2._hx_index == 1) {
				switch(_g2.k._hx_index) {
				case 17:
					isStatic = true;
					break;
				case 18:
					visibility = tokentree_utils_TokenFieldVisibility.Public;
					break;
				case 19:
					visibility = tokentree_utils_TokenFieldVisibility.Private;
					break;
				case 25:
					isExtern = true;
					break;
				case 34:
					isInline = true;
					break;
				default:
				}
			}
		}
	}
	access = tokentree_TokenTreeAccessHelper.firstOf(access,tokentree_TokenTreeDef.POpen);
	if(isFinal || access == null) {
		return tokentree_utils_TokenFieldType.Var(name,visibility,isStatic,isInline,isFinal,isExtern);
	}
	return tokentree_utils_TokenFieldType.Prop(name,visibility,isStatic,tokentree_utils_FieldUtils.makePropertyAccess(tokentree_TokenTreeAccessHelper.firstChild(access)),tokentree_utils_FieldUtils.makePropertyAccess(tokentree_TokenTreeAccessHelper.child(access,1)));
};
tokentree_utils_FieldUtils.makePropertyAccess = function(accessToken) {
	if(accessToken == null) {
		return tokentree_utils_TokenPropertyAccess.Default;
	}
	var _g = accessToken.tok;
	switch(_g._hx_index) {
	case 1:
		switch(_g.k._hx_index) {
		case 16:
			return tokentree_utils_TokenPropertyAccess.Default;
		case 32:
			return tokentree_utils_TokenPropertyAccess.DynamicAccess;
		case 36:
			return tokentree_utils_TokenPropertyAccess.NullAccess;
		default:
			return tokentree_utils_TokenPropertyAccess.Default;
		}
		break;
	case 2:
		var _g1 = _g.c;
		if(_g1._hx_index == 3) {
			switch(_g1.s) {
			case "get":
				return tokentree_utils_TokenPropertyAccess.Get;
			case "never":
				return tokentree_utils_TokenPropertyAccess.Never;
			case "set":
				return tokentree_utils_TokenPropertyAccess.Set;
			default:
				return tokentree_utils_TokenPropertyAccess.Default;
			}
		} else {
			return tokentree_utils_TokenPropertyAccess.Default;
		}
		break;
	default:
		return tokentree_utils_TokenPropertyAccess.Default;
	}
};
var tokentree_utils_TokenFieldType = $hxEnums["tokentree.utils.TokenFieldType"] = { __ename__ : true, __constructs__ : ["Function","Var","Prop","Unknown"]
	,Function: ($_=function(name,visibility,isStatic,isInline,isOverride,isFinal,isExtern) { return {_hx_index:0,name:name,visibility:visibility,isStatic:isStatic,isInline:isInline,isOverride:isOverride,isFinal:isFinal,isExtern:isExtern,__enum__:"tokentree.utils.TokenFieldType",toString:$estr}; },$_.__params__ = ["name","visibility","isStatic","isInline","isOverride","isFinal","isExtern"],$_)
	,Var: ($_=function(name,visibility,isStatic,isInline,isFinal,isExtern) { return {_hx_index:1,name:name,visibility:visibility,isStatic:isStatic,isInline:isInline,isFinal:isFinal,isExtern:isExtern,__enum__:"tokentree.utils.TokenFieldType",toString:$estr}; },$_.__params__ = ["name","visibility","isStatic","isInline","isFinal","isExtern"],$_)
	,Prop: ($_=function(name,visibility,isStatic,getter,setter) { return {_hx_index:2,name:name,visibility:visibility,isStatic:isStatic,getter:getter,setter:setter,__enum__:"tokentree.utils.TokenFieldType",toString:$estr}; },$_.__params__ = ["name","visibility","isStatic","getter","setter"],$_)
	,Unknown: {_hx_index:3,__enum__:"tokentree.utils.TokenFieldType",toString:$estr}
};
var tokentree_utils_TokenFieldVisibility = $hxEnums["tokentree.utils.TokenFieldVisibility"] = { __ename__ : true, __constructs__ : ["Public","Private"]
	,Public: {_hx_index:0,__enum__:"tokentree.utils.TokenFieldVisibility",toString:$estr}
	,Private: {_hx_index:1,__enum__:"tokentree.utils.TokenFieldVisibility",toString:$estr}
};
var tokentree_utils_TokenPropertyAccess = $hxEnums["tokentree.utils.TokenPropertyAccess"] = { __ename__ : true, __constructs__ : ["Default","NullAccess","Get","Set","DynamicAccess","Never"]
	,Default: {_hx_index:0,__enum__:"tokentree.utils.TokenPropertyAccess",toString:$estr}
	,NullAccess: {_hx_index:1,__enum__:"tokentree.utils.TokenPropertyAccess",toString:$estr}
	,Get: {_hx_index:2,__enum__:"tokentree.utils.TokenPropertyAccess",toString:$estr}
	,Set: {_hx_index:3,__enum__:"tokentree.utils.TokenPropertyAccess",toString:$estr}
	,DynamicAccess: {_hx_index:4,__enum__:"tokentree.utils.TokenPropertyAccess",toString:$estr}
	,Never: {_hx_index:5,__enum__:"tokentree.utils.TokenPropertyAccess",toString:$estr}
};
var tokentree_utils_TokenTreeCheckUtils = function() { };
tokentree_utils_TokenTreeCheckUtils.__name__ = true;
tokentree_utils_TokenTreeCheckUtils.isImport = function(token) {
	var parent = token;
	while(parent != null) {
		if(parent.tok == tokentree_TokenTreeDef.Root) {
			return false;
		}
		var _g = parent.tok;
		switch(_g._hx_index) {
		case 1:
			switch(_g.k._hx_index) {
			case 13:
				return true;
			case 25:
				break;
			case 35:
				return true;
			case 40:
				break;
			default:
				return false;
			}
			break;
		case 2:
			if(_g.c._hx_index != 3) {
				return false;
			}
			break;
		case 6:
			if(_g.op._hx_index != 23) {
				return false;
			}
			break;
		case 11:
			break;
		default:
			return false;
		}
		parent = parent.parent;
	}
	return false;
};
tokentree_utils_TokenTreeCheckUtils.isTypeParameter = function(token) {
	var _g = token.tok;
	if(_g._hx_index == 6) {
		switch(_g.op._hx_index) {
		case 7:
			return tokentree_TokenTreeAccessHelper.matches(tokentree_TokenTreeAccessHelper.parent(token),tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpLt)) != null;
		case 9:
			return tokentree_TokenTreeAccessHelper.firstOf(token,tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpGt)) != null;
		default:
			return false;
		}
	} else {
		return false;
	}
};
tokentree_utils_TokenTreeCheckUtils.isOpGtTypedefExtension = function(token) {
	var _g = token.tok;
	if(_g._hx_index == 6) {
		if(_g.op._hx_index == 7) {
			return tokentree_TokenTreeAccessHelper.matches(tokentree_TokenTreeAccessHelper.parent(tokentree_TokenTreeAccessHelper.isCIdent(tokentree_TokenTreeAccessHelper.parent(tokentree_TokenTreeAccessHelper.matches(tokentree_TokenTreeAccessHelper.parent(tokentree_TokenTreeAccessHelper.matches(tokentree_TokenTreeAccessHelper.parent(token),tokentree_TokenTreeDef.BrOpen)),tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpAssign))))),tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdTypedef)) != null;
		} else {
			return false;
		}
	} else {
		return false;
	}
};
tokentree_utils_TokenTreeCheckUtils.filterOpSub = function(token) {
	if(token == null) {
		return false;
	}
	var _g = token.tok;
	if(!(_g._hx_index == 6 && _g.op._hx_index == 3)) {
		return false;
	}
	var prev = token.previousSibling;
	if(token.previousSibling == null) {
		prev = token.parent;
	} else {
		prev = tokentree_utils_TokenTreeCheckUtils.getLastToken(token.previousSibling);
		if(prev == null) {
			return false;
		}
	}
	var _g = prev.tok;
	switch(_g._hx_index) {
	case 1:
		switch(_g.k._hx_index) {
		case 4:
			return true;
		case 5:
			return true;
		case 6:
			return true;
		case 10:
			return true;
		default:
			return false;
		}
		break;
	case 6:
		if(_g.op._hx_index == 23) {
			return true;
		} else {
			return true;
		}
		break;
	case 12:
		return true;
	case 13:
		return true;
	case 14:
		return true;
	case 15:
		return true;
	case 16:
		return false;
	case 17:
		return true;
	case 18:
		return true;
	case 19:
		return true;
	case 20:
		switch(tokentree_utils_TokenTreeCheckUtils.getPOpenType(prev.parent)._hx_index) {
		case 0:
			return true;
		case 1:
			return true;
		case 2:
			return false;
		case 3:
			return true;
		case 4:
			return true;
		case 5:
			return true;
		case 6:
			return true;
		case 7:
			return false;
		case 8:
			return true;
		case 9:
			return false;
		}
		break;
	case 21:
		return true;
	default:
		return false;
	}
};
tokentree_utils_TokenTreeCheckUtils.isTernary = function(token) {
	while(true) {
		if(token == null) {
			return false;
		}
		if(token.tok._hx_index == 12) {
			token = token.parent;
			continue;
		}
		if(token.tok._hx_index != 21) {
			return false;
		}
		if(tokentree_TokenTreeAccessHelper.firstOf(token,tokentree_TokenTreeDef.DblDot) == null) {
			return false;
		}
		if(token.parent == null) {
			return false;
		}
		var _g = token.parent.tok;
		switch(_g._hx_index) {
		case 1:
			switch(_g.k._hx_index) {
			case 0:case 2:
				return false;
			case 41:
				return false;
			default:
				return true;
			}
			break;
		case 3:
			return false;
		case 6:
			return true;
		case 14:
			return false;
		case 19:
			var prev = token.previousSibling;
			if(prev == null) {
				return false;
			}
			var lastToken = tokentree_utils_TokenTreeCheckUtils.getLastToken(prev);
			if(lastToken == null) {
				return false;
			}
			switch(lastToken.tok._hx_index) {
			case 10:
				return false;
			case 14:
				return false;
			default:
				return true;
			}
			break;
		default:
			return true;
		}
	}
};
tokentree_utils_TokenTreeCheckUtils.isTypeEnumAbstract = function(type) {
	var _g = type.tok;
	if(_g._hx_index == 1) {
		if(_g.k._hx_index == 39) {
			var this1 = tokentree_TokenTreeAccessHelper.firstChild(type);
			if(this1 == null || this1.children == null || this1.children.length <= 0) {
				return false;
			}
			if(tokentree_TokenTreeAccessHelper.firstOf(this1,tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdEnum)) != null) {
				return true;
			}
			var _g = 0;
			var _g1 = this1.children;
			while(_g < _g1.length) {
				var child = _g1[_g];
				++_g;
				if(child.tok._hx_index != 22) {
					continue;
				}
				if(tokentree_TokenTreeAccessHelper.matches(tokentree_TokenTreeAccessHelper.firstChild(tokentree_TokenTreeAccessHelper.matches(tokentree_TokenTreeAccessHelper.firstChild(child),tokentree_TokenTreeDef.DblDot)),tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdEnum)) == null) {
					continue;
				}
				return true;
			}
		}
	}
	return false;
};
tokentree_utils_TokenTreeCheckUtils.getName = function(token) {
	if(token == null) {
		return null;
	}
	var _g = token.tok;
	switch(_g._hx_index) {
	case 1:
		if(_g.k._hx_index == 22) {
			return "new";
		} else {
			return null;
		}
		break;
	case 2:
		var _g1 = _g.c;
		if(_g1._hx_index == 3) {
			return _g1.s;
		} else {
			return null;
		}
		break;
	default:
		return null;
	}
};
tokentree_utils_TokenTreeCheckUtils.getNameToken = function(token) {
	if(tokentree_utils_TokenTreeCheckUtils.isNameToken(token)) {
		return token;
	}
	var nameToken = tokentree_TokenTreeAccessHelper.firstChild(token);
	if(tokentree_utils_TokenTreeCheckUtils.isNameToken(nameToken)) {
		return nameToken;
	}
	nameToken = tokentree_TokenTreeAccessHelper.firstChild(tokentree_TokenTreeAccessHelper.matches(nameToken,tokentree_TokenTreeDef.Question));
	if(tokentree_utils_TokenTreeCheckUtils.isNameToken(nameToken)) {
		return nameToken;
	}
	return null;
};
tokentree_utils_TokenTreeCheckUtils.isNameToken = function(token) {
	if(token == null) {
		return false;
	}
	var _g = token.tok;
	switch(_g._hx_index) {
	case 1:
		if(_g.k._hx_index == 22) {
			return true;
		} else {
			return false;
		}
		break;
	case 2:
		if(_g.c._hx_index == 3) {
			return true;
		} else {
			return false;
		}
		break;
	default:
		return false;
	}
};
tokentree_utils_TokenTreeCheckUtils.getBrOpenType = function(token) {
	if(token == null) {
		return tokentree_utils_BrOpenType.Unknown;
	}
	if(token.tokenTypeCache.brOpenType != null) {
		return token.tokenTypeCache.brOpenType;
	}
	var type = tokentree_utils_TokenTreeCheckUtils.determineBrOpenType(token);
	token.tokenTypeCache.brOpenType = type;
	return type;
};
tokentree_utils_TokenTreeCheckUtils.determineBrOpenType = function(token) {
	if(token == null) {
		return tokentree_utils_BrOpenType.Unknown;
	}
	if(token.parent == null || token.parent.tok == tokentree_TokenTreeDef.Root) {
		return tokentree_utils_TokenTreeCheckUtils.determinBrChildren(token);
	}
	var _g = token.parent.tok;
	switch(_g._hx_index) {
	case 1:
		if(_g.k._hx_index == 10) {
			return tokentree_utils_TokenTreeCheckUtils.determinBrChildren(token);
		}
		break;
	case 2:
		var _g1 = _g.c;
		if(_g1._hx_index == 3) {
			switch(_g1.s) {
			case "from":case "to":
				return tokentree_utils_BrOpenType.AnonType;
			default:
				return tokentree_utils_BrOpenType.Block;
			}
		} else {
			return tokentree_utils_BrOpenType.Block;
		}
		break;
	case 4:
		return tokentree_utils_BrOpenType.Block;
	case 6:
		switch(_g.op._hx_index) {
		case 4:
			if(tokentree_utils_TokenTreeCheckUtils.isInsideTypedef(token.parent)) {
				return tokentree_utils_BrOpenType.TypedefDecl;
			}
			return tokentree_utils_TokenTreeCheckUtils.determinBrChildren(token);
		case 9:
			return tokentree_utils_BrOpenType.AnonType;
		default:
			return tokentree_utils_BrOpenType.ObjectDecl;
		}
		break;
	case 12:
		if(tokentree_utils_TokenTreeCheckUtils.isTernary(token.parent)) {
			return tokentree_utils_BrOpenType.ObjectDecl;
		}
		var parent = token.parent.parent;
		var _g = parent.tok;
		switch(_g._hx_index) {
		case 1:
			switch(_g.k._hx_index) {
			case 15:
				return tokentree_utils_BrOpenType.ObjectDecl;
			case 16:
				return tokentree_utils_BrOpenType.ObjectDecl;
			default:
				return tokentree_utils_BrOpenType.AnonType;
			}
			break;
		case 2:
			switch(_g.c._hx_index) {
			case 2:
				break;
			case 3:
				break;
			default:
				return tokentree_utils_BrOpenType.AnonType;
			}
			break;
		default:
			return tokentree_utils_BrOpenType.AnonType;
		}
		parent = parent.parent;
		var _g = parent.tok;
		switch(_g._hx_index) {
		case 1:
			switch(_g.k._hx_index) {
			case 0:
				return tokentree_utils_BrOpenType.AnonType;
			case 2:
				return tokentree_utils_BrOpenType.AnonType;
			case 41:
				return tokentree_utils_BrOpenType.AnonType;
			default:
				return tokentree_utils_BrOpenType.ObjectDecl;
			}
			break;
		case 6:
			if(_g.op._hx_index == 9) {
				return tokentree_utils_BrOpenType.AnonType;
			} else {
				return tokentree_utils_BrOpenType.ObjectDecl;
			}
			break;
		case 17:
			return tokentree_utils_TokenTreeCheckUtils.getBrOpenType(parent);
		case 19:
			return tokentree_utils_BrOpenType.AnonType;
		case 21:
			return tokentree_utils_BrOpenType.AnonType;
		default:
			return tokentree_utils_BrOpenType.ObjectDecl;
		}
		break;
	case 15:
		return tokentree_utils_BrOpenType.ObjectDecl;
	case 19:
		switch(tokentree_utils_TokenTreeCheckUtils.getPOpenType(token.parent)._hx_index) {
		case 0:
			return tokentree_utils_BrOpenType.ObjectDecl;
		case 1:
			return tokentree_utils_BrOpenType.AnonType;
		case 2:
			return tokentree_utils_BrOpenType.ObjectDecl;
		case 3:
			return tokentree_utils_BrOpenType.Unknown;
		case 4:
			return tokentree_utils_BrOpenType.Unknown;
		case 5:
			return tokentree_utils_BrOpenType.Unknown;
		case 6:
			return tokentree_utils_BrOpenType.Unknown;
		case 7:
			return tokentree_utils_BrOpenType.Unknown;
		case 8:
			return tokentree_utils_BrOpenType.Unknown;
		case 9:
			return tokentree_utils_BrOpenType.ObjectDecl;
		}
		break;
	case 21:
		if(tokentree_utils_TokenTreeCheckUtils.isTernary(token.parent)) {
			return tokentree_utils_BrOpenType.ObjectDecl;
		}
		break;
	default:
	}
	return tokentree_utils_TokenTreeCheckUtils.determinBrChildren(token);
};
tokentree_utils_TokenTreeCheckUtils.determinBrChildren = function(token) {
	if(token.children == null || token.children.length <= 0) {
		if(token.parent.tok._hx_index == 1) {
			return tokentree_utils_BrOpenType.Block;
		} else {
			return tokentree_utils_BrOpenType.ObjectDecl;
		}
	}
	if(token.parent != null && token.parent.tok != tokentree_TokenTreeDef.Root) {
		if(token.children.length == 1) {
			if(token.parent.tok._hx_index == 1) {
				return tokentree_utils_BrOpenType.Block;
			} else {
				return tokentree_utils_BrOpenType.ObjectDecl;
			}
		}
		if(token.children.length == 2 && token.getLastChild().tok._hx_index == 10) {
			if(token.parent.tok._hx_index == 1) {
				return tokentree_utils_BrOpenType.Block;
			} else {
				return tokentree_utils_BrOpenType.ObjectDecl;
			}
		}
	}
	if(tokentree_TokenTreeAccessHelper.firstOf(token,tokentree_TokenTreeDef.Arrow) != null) {
		return tokentree_utils_BrOpenType.AnonType;
	}
	if(token.nextSibling != null && token.nextSibling.tok._hx_index == 13) {
		return tokentree_utils_BrOpenType.AnonType;
	}
	var onlyComment = true;
	var _g = 0;
	var _g1 = token.children;
	while(_g < _g1.length) {
		var child = _g1[_g];
		++_g;
		var _g2 = child.tok;
		switch(_g2._hx_index) {
		case 2:
			switch(_g2.c._hx_index) {
			case 2:
				if(tokentree_TokenTreeAccessHelper.matches(tokentree_TokenTreeAccessHelper.firstChild(child),tokentree_TokenTreeDef.DblDot) == null) {
					return tokentree_utils_BrOpenType.Block;
				}
				onlyComment = false;
				break;
			case 3:
				if(tokentree_TokenTreeAccessHelper.matches(tokentree_TokenTreeAccessHelper.firstChild(child),tokentree_TokenTreeDef.DblDot) == null) {
					return tokentree_utils_BrOpenType.Block;
				}
				onlyComment = false;
				break;
			default:
				return tokentree_utils_BrOpenType.Block;
			}
			break;
		case 3:
			break;
		case 7:
			break;
		case 8:
			break;
		case 18:
			if(onlyComment) {
				if(token.parent != null && token.parent.tok != tokentree_TokenTreeDef.Root) {
					if(token.parent.tok._hx_index == 1) {
						return tokentree_utils_BrOpenType.Block;
					} else {
						return tokentree_utils_BrOpenType.ObjectDecl;
					}
				} else {
					return tokentree_utils_BrOpenType.ObjectDecl;
				}
			}
			return tokentree_utils_BrOpenType.ObjectDecl;
		default:
			return tokentree_utils_BrOpenType.Block;
		}
	}
	return tokentree_utils_BrOpenType.ObjectDecl;
};
tokentree_utils_TokenTreeCheckUtils.getPOpenType = function(token) {
	while(true) {
		if(token == null) {
			return tokentree_utils_POpenType.Expression;
		}
		switch(token.tok._hx_index) {
		case 19:
			break;
		case 20:
			token = token.parent;
			continue;
		default:
			return tokentree_utils_POpenType.Expression;
		}
		if(token.tokenTypeCache.pOpenType != null) {
			return token.tokenTypeCache.pOpenType;
		}
		var type = tokentree_utils_TokenTreeCheckUtils.determinePOpenType(token);
		token.tokenTypeCache.pOpenType = type;
		return type;
	}
};
tokentree_utils_TokenTreeCheckUtils.determinePOpenType = function(token) {
	var parent = token.parent;
	if(parent == null || parent.tok == tokentree_TokenTreeDef.Root) {
		return tokentree_utils_POpenType.Expression;
	}
	if(tokentree_utils_TokenTreeCheckUtils.hasAtParent(token)) {
		return tokentree_utils_POpenType.At;
	}
	if(token.hasChildren() && tokentree_utils_TokenTreeCheckUtils.checkPOpenForArrowChildren(token)) {
		return tokentree_utils_POpenType.Parameter;
	}
	_hx_loop1: while(parent != null && parent.tok != tokentree_TokenTreeDef.Root) {
		var _g = parent.tok;
		switch(_g._hx_index) {
		case 3:
			switch(_g.s) {
			case "elseif":case "if":
				if(parent.getFirstChild() == token) {
					return tokentree_utils_POpenType.SharpCondition;
				}
				parent = parent.parent;
				break;
			default:
				break _hx_loop1;
			}
			break;
		case 6:
			if(_g.op._hx_index == 9) {
				parent = parent.parent;
			} else {
				break _hx_loop1;
			}
			break;
		default:
			break _hx_loop1;
		}
	}
	if(parent == null || parent.tok == tokentree_TokenTreeDef.Root) {
		return tokentree_utils_POpenType.Expression;
	}
	var _g = parent.tok;
	switch(_g._hx_index) {
	case 1:
		switch(_g.k._hx_index) {
		case 0:
			return tokentree_utils_POpenType.Parameter;
		case 3:
			var firstChild = parent.getFirstChild();
			if(firstChild == null) {
				return tokentree_utils_POpenType.IfCondition;
			}
			if(firstChild.index == token.index) {
				return tokentree_utils_POpenType.IfCondition;
			}
			return tokentree_utils_POpenType.Expression;
		case 5:
			return tokentree_utils_POpenType.WhileCondition;
		case 7:
			return tokentree_utils_POpenType.ForLoop;
		case 14:
			return tokentree_utils_POpenType.SwitchCondition;
		case 21:
			return tokentree_utils_POpenType.Catch;
		case 22:
			return tokentree_utils_POpenType.Parameter;
		default:
		}
		break;
	case 2:
		if(_g.c._hx_index == 3) {
			if(parent.parent == null || parent.parent.tok == tokentree_TokenTreeDef.Root) {
				return tokentree_utils_POpenType.Call;
			}
			var _g = parent.parent.tok;
			switch(_g._hx_index) {
			case 1:
				switch(_g.k._hx_index) {
				case 0:
					if(parent.previousSibling == null) {
						var this1 = tokentree_TokenTreeAccessHelper.firstOf(parent,tokentree_TokenTreeDef.POpen);
						if(this1 == null) {
							return tokentree_utils_POpenType.Parameter;
						}
						if(this1.index == token.index) {
							return tokentree_utils_POpenType.Parameter;
						}
						return tokentree_utils_POpenType.Expression;
					}
					return tokentree_utils_POpenType.Call;
				case 39:
					return tokentree_utils_POpenType.Parameter;
				default:
					return tokentree_utils_POpenType.Call;
				}
				break;
			case 17:
				if(tokentree_TokenTreeAccessHelper.matches(tokentree_TokenTreeAccessHelper.parent(tokentree_TokenTreeAccessHelper.parent(parent.parent)),tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdEnum)) != null) {
					return tokentree_utils_POpenType.Parameter;
				}
				return tokentree_utils_POpenType.Call;
			default:
				return tokentree_utils_POpenType.Call;
			}
		}
		break;
	case 19:
		return tokentree_utils_POpenType.Expression;
	default:
	}
	if(tokentree_TokenTreeAccessHelper.firstOf(token,tokentree_TokenTreeDef.Arrow) != null) {
		return tokentree_utils_POpenType.Parameter;
	}
	return tokentree_utils_POpenType.Expression;
};
tokentree_utils_TokenTreeCheckUtils.checkPOpenForArrowChildren = function(token) {
	var skip = true;
	var _g = 0;
	var _g1 = token.children;
	while(_g < _g1.length) {
		var child = _g1[_g];
		++_g;
		if(child.tok._hx_index == 20) {
			skip = false;
		}
		if(skip) {
			continue;
		}
		if(child.tok._hx_index == 13) {
			return true;
		}
	}
	return false;
};
tokentree_utils_TokenTreeCheckUtils.hasAtParent = function(token) {
	var parent = token.parent;
	while(parent.tok != tokentree_TokenTreeDef.Root) {
		var _g = parent.tok;
		switch(_g._hx_index) {
		case 1:
			break;
		case 2:
			break;
		case 6:
			if(_g.op._hx_index != 23) {
				return false;
			}
			break;
		case 11:
			break;
		case 12:
			break;
		case 22:
			return true;
		default:
			return false;
		}
		parent = parent.parent;
	}
	return false;
};
tokentree_utils_TokenTreeCheckUtils.isInsideTypedef = function(token) {
	if(token == null) {
		return false;
	}
	var parent = token;
	while(parent.parent != null) {
		var _g = parent.tok;
		if(_g._hx_index == 1 && _g.k._hx_index == 31) {
			return true;
		}
		parent = parent.parent;
	}
	return false;
};
tokentree_utils_TokenTreeCheckUtils.getArrowType = function(token) {
	if(token == null) {
		return tokentree_utils_ArrowType.ArrowFunction;
	}
	if(token.tokenTypeCache.arrowType != null) {
		return token.tokenTypeCache.arrowType;
	}
	var type = tokentree_utils_TokenTreeCheckUtils.determineArrowType(token);
	if(type == null) {
		type = tokentree_utils_ArrowType.ArrowFunction;
	}
	token.tokenTypeCache.arrowType = type;
	return type;
};
tokentree_utils_TokenTreeCheckUtils.determineArrowType = function(token) {
	if(token == null) {
		return tokentree_utils_ArrowType.ArrowFunction;
	}
	var child = token.getFirstChild();
	while(child != null) {
		var _g = child.tok;
		switch(_g._hx_index) {
		case 1:
			if(_g.k._hx_index != 40) {
				return tokentree_utils_ArrowType.ArrowFunction;
			}
			break;
		case 2:
			if(_g.c._hx_index != 3) {
				return tokentree_utils_ArrowType.ArrowFunction;
			}
			break;
		case 6:
			if(_g.op._hx_index == 9) {
				child = child.nextSibling;
				continue;
			} else {
				return tokentree_utils_ArrowType.ArrowFunction;
			}
			break;
		case 7:
			break;
		case 8:
			break;
		case 10:case 11:case 13:case 21:
			break;
		case 17:
			if(child.getFirstChild().tok._hx_index == 18) {
				return tokentree_utils_ArrowType.ArrowFunction;
			}
			var brType = tokentree_utils_TokenTreeCheckUtils.getBrOpenType(child);
			if(brType == null) {
				brType = tokentree_utils_BrOpenType.Unknown;
			}
			if(brType != null) {
				switch(brType._hx_index) {
				case 0:
					return tokentree_utils_ArrowType.ArrowFunction;
				case 3:
					break;
				default:
				}
			}
			child = child.nextSibling;
			continue;
		case 19:
			break;
		default:
			return tokentree_utils_ArrowType.ArrowFunction;
		}
		child = child.getFirstChild();
	}
	var parent = token.parent;
	if(parent == null) {
		return tokentree_utils_ArrowType.ArrowFunction;
	}
	var resultType = tokentree_utils_TokenTreeCheckUtils.checkArrowParent(parent);
	if(resultType != null) {
		return resultType;
	}
	return tokentree_utils_TokenTreeCheckUtils.checkArrowChildren(parent);
};
tokentree_utils_TokenTreeCheckUtils.checkArrowChildren = function(parent) {
	var child = parent.getFirstChild();
	if(child == null) {
		return tokentree_utils_ArrowType.ArrowFunction;
	}
	var seenArrow = false;
	while(child != null) {
		var _g = child.tok;
		switch(_g._hx_index) {
		case 1:
			return tokentree_utils_ArrowType.ArrowFunction;
		case 2:
			if(_g.c._hx_index != 3) {
				return tokentree_utils_ArrowType.NewFunctionType;
			}
			break;
		case 6:
			if(_g.op._hx_index == 9) {
				child = child.nextSibling;
				continue;
			} else {
				return tokentree_utils_ArrowType.NewFunctionType;
			}
			break;
		case 7:
			break;
		case 8:
			break;
		case 10:case 11:
			break;
		case 12:case 17:
			break;
		case 13:
			seenArrow = true;
			break;
		case 19:
			var result = tokentree_utils_TokenTreeCheckUtils.checkArrowPOpen(child);
			if(result != null) {
				return result;
			}
			child = child.nextSibling;
			continue;
		case 20:
			break;
		case 21:
			break;
		default:
			return tokentree_utils_ArrowType.NewFunctionType;
		}
		child = child.getFirstChild();
	}
	if(seenArrow) {
		return tokentree_utils_ArrowType.OldFunctionType;
	}
	return tokentree_utils_ArrowType.NewFunctionType;
};
tokentree_utils_TokenTreeCheckUtils.checkArrowPOpen = function(token) {
	if(token.children == null || token.children.length <= 1) {
		return null;
	}
	if(token.parent.isCIdent()) {
		return tokentree_utils_ArrowType.ArrowFunction;
	}
	if(token.filterCallback(function(token,index) {
		if(token.tok._hx_index == 13) {
			return tokentree_FilterResult.FoundSkipSubtree;
		} else {
			return tokentree_FilterResult.GoDeeper;
		}
	}).length <= 0) {
		return tokentree_utils_ArrowType.ArrowFunction;
	}
	if(token.filterCallback(function(token,index) {
		if(token.tok._hx_index == 12) {
			return tokentree_FilterResult.FoundSkipSubtree;
		} else {
			return tokentree_FilterResult.GoDeeper;
		}
	}).length > 0) {
		return tokentree_utils_ArrowType.NewFunctionType;
	}
	return tokentree_utils_ArrowType.OldFunctionType;
};
tokentree_utils_TokenTreeCheckUtils.checkArrowParent = function(parent) {
	if(parent == null) {
		return tokentree_utils_ArrowType.ArrowFunction;
	}
	var _g = parent.tok;
	switch(_g._hx_index) {
	case 2:
		if(_g.c._hx_index == 3) {
			if(parent.parent == null || parent.parent.tok == tokentree_TokenTreeDef.Root) {
				return tokentree_utils_ArrowType.ArrowFunction;
			}
			var _g = parent.parent.tok;
			switch(_g._hx_index) {
			case 6:
				switch(_g.op._hx_index) {
				case 4:
					if(tokentree_utils_TokenTreeCheckUtils.isInsideTypedef(parent.parent)) {
						return tokentree_utils_ArrowType.OldFunctionType;
					}
					return tokentree_utils_ArrowType.ArrowFunction;
				case 22:
					return tokentree_utils_ArrowType.ArrowFunction;
				default:
				}
				break;
			case 12:
				switch(tokentree_utils_TokenTreeCheckUtils.getColonType(parent.parent)._hx_index) {
				case 1:
					return tokentree_utils_ArrowType.OldFunctionType;
				case 2:
					return tokentree_utils_ArrowType.OldFunctionType;
				case 0:case 3:case 4:case 5:case 6:
					return tokentree_utils_ArrowType.ArrowFunction;
				}
				break;
			case 13:
				return tokentree_utils_ArrowType.OldFunctionType;
			case 19:
				var type = tokentree_utils_TokenTreeCheckUtils.getPOpenType(parent.parent);
				if(type == null) {
					type = tokentree_utils_POpenType.Expression;
				}
				switch(type._hx_index) {
				case 1:
					return tokentree_utils_ArrowType.OldFunctionType;
				case 9:
					return tokentree_utils_ArrowType.OldFunctionType;
				default:
					return tokentree_utils_ArrowType.ArrowFunction;
				}
				break;
			default:
			}
		} else {
			return tokentree_utils_ArrowType.OldFunctionType;
		}
		break;
	case 19:
		break;
	default:
		return tokentree_utils_ArrowType.OldFunctionType;
	}
	return null;
};
tokentree_utils_TokenTreeCheckUtils.getColonType = function(token) {
	if(token == null) {
		return tokentree_utils_ColonType.Unknown;
	}
	if(token.tokenTypeCache.colonType != null) {
		return token.tokenTypeCache.colonType;
	}
	var type = tokentree_utils_TokenTreeCheckUtils.determineColonType(token);
	token.tokenTypeCache.colonType = type;
	return type;
};
tokentree_utils_TokenTreeCheckUtils.determineColonType = function(token) {
	if(token == null) {
		return tokentree_utils_ColonType.Unknown;
	}
	if(tokentree_utils_TokenTreeCheckUtils.isTernary(token)) {
		return tokentree_utils_ColonType.Ternary;
	}
	var parent = token.parent;
	if(parent == null) {
		return tokentree_utils_ColonType.Unknown;
	}
	if(parent.tok._hx_index == 3) {
		parent = parent.parent;
		if(parent == null || parent.tok == tokentree_TokenTreeDef.Root) {
			return tokentree_utils_ColonType.Unknown;
		}
	}
	var _g = parent.tok;
	switch(_g._hx_index) {
	case 1:
		switch(_g.k._hx_index) {
		case 0:
			return tokentree_utils_ColonType.TypeHint;
		case 15:case 16:
			return tokentree_utils_ColonType.SwitchCase;
		case 22:
			return tokentree_utils_TokenTreeCheckUtils.findColonParent(parent);
		case 23:
			return tokentree_utils_TokenTreeCheckUtils.findColonParent(parent);
		default:
		}
		break;
	case 2:
		return tokentree_utils_TokenTreeCheckUtils.findColonParent(parent);
	case 6:
		if(_g.op._hx_index == 9) {
			return tokentree_utils_TokenTreeCheckUtils.findColonParent(parent);
		}
		break;
	case 17:
		var this1 = tokentree_TokenTreeAccessHelper.firstOf(parent,tokentree_TokenTreeDef.BrClose);
		if(this1 == null) {
			return tokentree_utils_ColonType.Unknown;
		}
		if(this1.pos.max <= token.pos.min) {
			return tokentree_utils_ColonType.TypeCheck;
		}
		break;
	case 19:
		return tokentree_utils_TokenTreeCheckUtils.findColonParent(token);
	case 21:
		return tokentree_utils_TokenTreeCheckUtils.findColonParent(parent);
	case 22:
		return tokentree_utils_ColonType.At;
	default:
	}
	return tokentree_utils_ColonType.Unknown;
};
tokentree_utils_TokenTreeCheckUtils.findColonParent = function(token) {
	var parent = token;
	while(parent.tok != tokentree_TokenTreeDef.Root) {
		var _g = parent.tok;
		switch(_g._hx_index) {
		case 1:
			switch(_g.k._hx_index) {
			case 0:case 2:case 41:
				return tokentree_utils_ColonType.TypeHint;
			default:
			}
			break;
		case 17:
			switch(tokentree_utils_TokenTreeCheckUtils.getBrOpenType(parent)._hx_index) {
			case 0:
				return tokentree_utils_ColonType.Unknown;
			case 1:
				return tokentree_utils_ColonType.TypeHint;
			case 2:
				return tokentree_utils_ColonType.ObjectLiteral;
			case 3:
				return tokentree_utils_ColonType.TypeHint;
			case 4:
				return tokentree_utils_ColonType.Unknown;
			}
			break;
		case 19:
			var this1 = tokentree_TokenTreeAccessHelper.firstOf(parent,tokentree_TokenTreeDef.PClose);
			if(this1 != null && this1.pos.max <= token.pos.min) {
				return tokentree_utils_ColonType.TypeCheck;
			}
			switch(tokentree_utils_TokenTreeCheckUtils.getPOpenType(parent)._hx_index) {
			case 0:
				return tokentree_utils_ColonType.ObjectLiteral;
			case 1:
				return tokentree_utils_ColonType.TypeHint;
			case 2:
				return tokentree_utils_ColonType.Unknown;
			case 3:
				return tokentree_utils_ColonType.TypeCheck;
			case 4:
				return tokentree_utils_ColonType.Unknown;
			case 5:
				return tokentree_utils_ColonType.Unknown;
			case 6:
				return tokentree_utils_ColonType.Unknown;
			case 7:
				return tokentree_utils_ColonType.Unknown;
			case 8:
				return tokentree_utils_ColonType.TypeCheck;
			case 9:
				return tokentree_utils_ColonType.TypeCheck;
			}
			break;
		default:
		}
		parent = parent.parent;
	}
	return tokentree_utils_ColonType.Unknown;
};
tokentree_utils_TokenTreeCheckUtils.getLastToken = function(token) {
	if(token == null) {
		return null;
	}
	if(token.children == null) {
		return token;
	}
	if(token.children.length <= 0) {
		return token;
	}
	var lastChild = token.getLastChild();
	while(lastChild != null) {
		var newLast = lastChild.getLastChild();
		if(newLast == null) {
			return lastChild;
		}
		lastChild = newLast;
	}
	return null;
};
tokentree_utils_TokenTreeCheckUtils.isMetadata = function(token) {
	if(token == null || token.tok == tokentree_TokenTreeDef.Root) {
		return false;
	}
	var parent = token.parent;
	while(parent != null && parent.tok != tokentree_TokenTreeDef.Root) switch(parent.tok._hx_index) {
	case 12:
		parent = parent.parent;
		if(parent == null || parent.tok == tokentree_TokenTreeDef.Root) {
			return false;
		}
		if(parent.tok._hx_index == 22) {
			return true;
		} else {
			return false;
		}
		break;
	case 22:
		return true;
	default:
		parent = parent.parent;
	}
	return false;
};
var tokentree_utils_BrOpenType = $hxEnums["tokentree.utils.BrOpenType"] = { __ename__ : true, __constructs__ : ["Block","TypedefDecl","ObjectDecl","AnonType","Unknown"]
	,Block: {_hx_index:0,__enum__:"tokentree.utils.BrOpenType",toString:$estr}
	,TypedefDecl: {_hx_index:1,__enum__:"tokentree.utils.BrOpenType",toString:$estr}
	,ObjectDecl: {_hx_index:2,__enum__:"tokentree.utils.BrOpenType",toString:$estr}
	,AnonType: {_hx_index:3,__enum__:"tokentree.utils.BrOpenType",toString:$estr}
	,Unknown: {_hx_index:4,__enum__:"tokentree.utils.BrOpenType",toString:$estr}
};
var tokentree_utils_POpenType = $hxEnums["tokentree.utils.POpenType"] = { __ename__ : true, __constructs__ : ["At","Parameter","Call","SwitchCondition","WhileCondition","IfCondition","SharpCondition","Catch","ForLoop","Expression"]
	,At: {_hx_index:0,__enum__:"tokentree.utils.POpenType",toString:$estr}
	,Parameter: {_hx_index:1,__enum__:"tokentree.utils.POpenType",toString:$estr}
	,Call: {_hx_index:2,__enum__:"tokentree.utils.POpenType",toString:$estr}
	,SwitchCondition: {_hx_index:3,__enum__:"tokentree.utils.POpenType",toString:$estr}
	,WhileCondition: {_hx_index:4,__enum__:"tokentree.utils.POpenType",toString:$estr}
	,IfCondition: {_hx_index:5,__enum__:"tokentree.utils.POpenType",toString:$estr}
	,SharpCondition: {_hx_index:6,__enum__:"tokentree.utils.POpenType",toString:$estr}
	,Catch: {_hx_index:7,__enum__:"tokentree.utils.POpenType",toString:$estr}
	,ForLoop: {_hx_index:8,__enum__:"tokentree.utils.POpenType",toString:$estr}
	,Expression: {_hx_index:9,__enum__:"tokentree.utils.POpenType",toString:$estr}
};
var tokentree_utils_ArrowType = $hxEnums["tokentree.utils.ArrowType"] = { __ename__ : true, __constructs__ : ["ArrowFunction","OldFunctionType","NewFunctionType"]
	,ArrowFunction: {_hx_index:0,__enum__:"tokentree.utils.ArrowType",toString:$estr}
	,OldFunctionType: {_hx_index:1,__enum__:"tokentree.utils.ArrowType",toString:$estr}
	,NewFunctionType: {_hx_index:2,__enum__:"tokentree.utils.ArrowType",toString:$estr}
};
var tokentree_utils_ColonType = $hxEnums["tokentree.utils.ColonType"] = { __ename__ : true, __constructs__ : ["SwitchCase","TypeHint","TypeCheck","Ternary","ObjectLiteral","At","Unknown"]
	,SwitchCase: {_hx_index:0,__enum__:"tokentree.utils.ColonType",toString:$estr}
	,TypeHint: {_hx_index:1,__enum__:"tokentree.utils.ColonType",toString:$estr}
	,TypeCheck: {_hx_index:2,__enum__:"tokentree.utils.ColonType",toString:$estr}
	,Ternary: {_hx_index:3,__enum__:"tokentree.utils.ColonType",toString:$estr}
	,ObjectLiteral: {_hx_index:4,__enum__:"tokentree.utils.ColonType",toString:$estr}
	,At: {_hx_index:5,__enum__:"tokentree.utils.ColonType",toString:$estr}
	,Unknown: {_hx_index:6,__enum__:"tokentree.utils.ColonType",toString:$estr}
};
var tokentree_walk_WalkAbstract = function() { };
tokentree_walk_WalkAbstract.__name__ = true;
tokentree_walk_WalkAbstract.walkAbstract = function(stream,parent) {
	var typeTok = stream.consumeToken();
	var _g = stream.token();
	if(_g._hx_index == 1) {
		switch(_g.k._hx_index) {
		case 1:case 27:
			stream.addToTempStore(typeTok);
			tokentree_walk_WalkType.walkType(stream,parent);
			return;
		default:
		}
	}
	parent.addChild(typeTok);
	var name = tokentree_walk_WalkTypeNameDef.walkTypeNameDef(stream,typeTok);
	stream.applyTempStore(name);
	if(stream.tokenForMatch()._hx_index == 19) {
		tokentree_walk_WalkPOpen.walkPOpen(stream,name);
	}
	var typeParent = name;
	var typeChild;
	var progress = new tokentree_TokenStreamProgress(stream);
	_hx_loop1: while(progress.streamHasChanged()) {
		var _g = stream.token();
		switch(_g._hx_index) {
		case 2:
			var _g1 = _g.c;
			if(_g1._hx_index == 3) {
				switch(_g1.s) {
				case "from":case "to":
					var fromToken = stream.consumeToken();
					name.addChild(fromToken);
					tokentree_walk_WalkTypeNameDef.walkTypeNameDef(stream,fromToken);
					break;
				default:
					typeChild = stream.consumeToken();
					typeParent.addChild(typeChild);
					typeParent = typeChild;
				}
			} else {
				typeChild = stream.consumeToken();
				typeParent.addChild(typeChild);
				typeParent = typeChild;
			}
			break;
		case 7:
			name.addChild(stream.consumeToken());
			break;
		case 8:
			name.addChild(stream.consumeToken());
			break;
		case 17:
			break _hx_loop1;
		default:
			typeChild = stream.consumeToken();
			typeParent.addChild(typeChild);
			typeParent = typeChild;
		}
	}
	var block = stream.consumeTokenDef(tokentree_TokenTreeDef.BrOpen);
	name.addChild(block);
	tokentree_walk_WalkAbstract.walkAbstractBody(stream,block);
	block.addChild(stream.consumeTokenDef(tokentree_TokenTreeDef.BrClose));
};
tokentree_walk_WalkAbstract.walkAbstractBody = function(stream,parent) {
	var progress = new tokentree_TokenStreamProgress(stream);
	_hx_loop1: while(progress.streamHasChanged()) {
		var _g = stream.token();
		switch(_g._hx_index) {
		case 1:
			switch(_g.k._hx_index) {
			case 0:
				tokentree_walk_WalkFunction.walkFunction(stream,parent);
				break;
			case 2:
				tokentree_walk_WalkVar.walkVar(stream,parent);
				break;
			case 41:
				tokentree_walk_WalkFinal.walkFinal(stream,parent);
				break;
			default:
				stream.consumeToTempStore();
			}
			break;
		case 3:
			tokentree_walk_WalkSharp.walkSharp(stream,parent,tokentree_walk_WalkAbstract.walkAbstractBody);
			break;
		case 7:
			parent.addChild(stream.consumeToken());
			break;
		case 8:
			parent.addChild(stream.consumeToken());
			break;
		case 10:
			parent.addChild(stream.consumeToken());
			break;
		case 18:
			break _hx_loop1;
		case 22:
			stream.addToTempStore(tokentree_walk_WalkAt.walkAt(stream));
			break;
		default:
			stream.consumeToTempStore();
		}
	}
	stream.applyTempStore(parent);
};
var tokentree_walk_WalkArrayAccess = function() { };
tokentree_walk_WalkArrayAccess.__name__ = true;
tokentree_walk_WalkArrayAccess.walkArrayAccess = function(stream,parent) {
	var bkOpen = stream.consumeTokenDef(tokentree_TokenTreeDef.BkOpen);
	parent.addChild(bkOpen);
	stream.applyTempStore(bkOpen);
	var progress = new tokentree_TokenStreamProgress(stream);
	_hx_loop1: while(progress.streamHasChanged()) {
		var _g = stream.token();
		switch(_g._hx_index) {
		case 1:
			switch(_g.k._hx_index) {
			case 0:
				tokentree_walk_WalkFunction.walkFunction(stream,bkOpen);
				break;
			case 5:
				stream.applyTempStore(bkOpen);
				tokentree_walk_WalkWhile.walkWhile(stream,bkOpen);
				break;
			case 7:
				stream.applyTempStore(bkOpen);
				tokentree_walk_WalkFor.walkFor(stream,bkOpen);
				break;
			default:
				stream.applyTempStore(bkOpen);
				tokentree_walk_WalkStatement.walkStatement(stream,bkOpen);
			}
			break;
		case 6:
			if(_g.op._hx_index == 22) {
				var child = bkOpen.getLastChild();
				if(child == null) {
					child = bkOpen;
				}
				tokentree_walk_WalkStatement.walkStatement(stream,child);
			} else {
				stream.applyTempStore(bkOpen);
				tokentree_walk_WalkStatement.walkStatement(stream,bkOpen);
			}
			break;
		case 14:
			var comma = stream.consumeToken();
			var child1 = bkOpen.getLastChild();
			if(child1 == null) {
				child1 = bkOpen;
			}
			child1.addChild(comma);
			break;
		case 15:
			tokentree_walk_WalkArrayAccess.walkArrayAccess(stream,bkOpen);
			break;
		case 16:
			break _hx_loop1;
		case 17:
			stream.applyTempStore(bkOpen);
			tokentree_walk_WalkBlock.walkBlock(stream,bkOpen);
			break;
		case 19:
			stream.applyTempStore(bkOpen);
			tokentree_walk_WalkPOpen.walkPOpen(stream,bkOpen);
			break;
		case 22:
			stream.addToTempStore(tokentree_walk_WalkAt.walkAt(stream));
			break;
		default:
			stream.applyTempStore(bkOpen);
			tokentree_walk_WalkStatement.walkStatement(stream,bkOpen);
		}
	}
	bkOpen.addChild(stream.consumeTokenDef(tokentree_TokenTreeDef.BkClose));
	if(stream.hasMore()) {
		var _g = stream.token();
		switch(_g._hx_index) {
		case 2:
			var _g1 = _g.c;
			if(_g1._hx_index == 3) {
				if(_g1.s == "is") {
					tokentree_walk_WalkStatement.walkStatementContinue(stream,bkOpen);
				}
			}
			break;
		case 6:
			tokentree_walk_WalkStatement.walkStatementContinue(stream,bkOpen);
			break;
		case 11:case 15:
			tokentree_walk_WalkStatement.walkStatementContinue(stream,bkOpen);
			break;
		default:
		}
	}
};
var tokentree_walk_WalkAt = function() { };
tokentree_walk_WalkAt.__name__ = true;
tokentree_walk_WalkAt.walkAt = function(stream) {
	var atTok = stream.consumeTokenDef(tokentree_TokenTreeDef.At);
	var parent = atTok;
	if(stream.tokenForMatch()._hx_index == 12) {
		var dblDot = stream.consumeToken();
		atTok.addChild(dblDot);
		parent = dblDot;
	}
	tokentree_walk_WalkAt.walkIdent(stream,parent);
	return atTok;
};
tokentree_walk_WalkAt.walkIdent = function(stream,parent) {
	while(true) {
		var ident;
		var _g = stream.token();
		switch(_g._hx_index) {
		case 1:
			ident = stream.consumeToken();
			break;
		case 2:
			if(_g.c._hx_index == 3) {
				ident = stream.consumeConstIdent();
			} else {
				return;
			}
			break;
		case 6:
			if(_g.op._hx_index == 23) {
				ident = stream.consumeToken();
			} else {
				return;
			}
			break;
		default:
			return;
		}
		parent.addChild(ident);
		switch(stream.token()._hx_index) {
		case 11:
			var child = stream.consumeToken();
			ident.addChild(child);
			parent = child;
			continue;
		case 19:
			var pOpenPos = stream.getTokenPos();
			if(ident.pos.max == pOpenPos.min) {
				var tempStore = stream.getTempStore();
				stream.clearTempStore();
				tokentree_walk_WalkPOpen.walkPOpen(stream,ident,false);
				var _g1 = 0;
				while(_g1 < tempStore.length) stream.addToTempStore(tempStore[_g1++]);
			}
			break;
		default:
		}
		return;
	}
};
tokentree_walk_WalkAt.walkAts = function(stream) {
	var progress = new tokentree_TokenStreamProgress(stream);
	while(progress.streamHasChanged()) if(stream.token()._hx_index == 22) {
		stream.addToTempStore(tokentree_walk_WalkAt.walkAt(stream));
	}
};
var tokentree_walk_WalkBinopSub = function() { };
tokentree_walk_WalkBinopSub.__name__ = true;
tokentree_walk_WalkBinopSub.walkBinopSub = function(stream,parent) {
	var sub = stream.consumeOpSub(parent);
	parent.addChild(sub);
	if(sub.tok._hx_index == 2) {
		tokentree_walk_WalkStatement.walkStatementContinue(stream,sub);
	} else {
		tokentree_walk_WalkStatement.walkStatement(stream,sub);
	}
};
var tokentree_walk_WalkBlock = function() { };
tokentree_walk_WalkBlock.__name__ = true;
tokentree_walk_WalkBlock.walkBlock = function(stream,parent) {
	while(stream.tokenForMatch()._hx_index == 22) stream.addToTempStore(tokentree_walk_WalkAt.walkAt(stream));
	if(stream.tokenForMatch()._hx_index == 17) {
		var openTok = stream.consumeTokenDef(tokentree_TokenTreeDef.BrOpen);
		parent.addChild(openTok);
		stream.applyTempStore(openTok);
		tokentree_walk_WalkBlock.walkBlockContinue(stream,openTok);
		stream.applyTempStore(openTok);
	} else {
		tokentree_walk_WalkStatement.walkStatement(stream,parent);
	}
};
tokentree_walk_WalkBlock.walkBlockContinue = function(stream,parent) {
	var progress = new tokentree_TokenStreamProgress(stream);
	_hx_loop1: while(progress.streamHasChanged()) {
		var _g = stream.token();
		switch(_g._hx_index) {
		case 1:
			switch(_g.k._hx_index) {
			case 15:case 16:
				tokentree_walk_WalkSwitch.walkSwitchCases(stream,parent);
				break;
			default:
				tokentree_walk_WalkStatement.walkStatement(stream,parent);
			}
			break;
		case 14:
			var child = stream.consumeToken();
			var lastChild = parent.getLastChild();
			if(lastChild == null) {
				parent.addChild(child);
			} else {
				lastChild.addChild(child);
			}
			break;
		case 18:
			break _hx_loop1;
		case 16:case 20:
			parent.addChild(stream.consumeToken());
			break;
		default:
			tokentree_walk_WalkStatement.walkStatement(stream,parent);
		}
	}
	tokentree_walk_WalkBlock.walkBlockEnd(stream,parent);
};
tokentree_walk_WalkBlock.walkBlockEnd = function(stream,parent) {
	parent.addChild(stream.consumeTokenDef(tokentree_TokenTreeDef.BrClose));
	if(stream.hasMore()) {
		var _g = stream.token();
		if(_g._hx_index == 6) {
			if(_g.op._hx_index == 7) {
				return;
			}
		}
		tokentree_walk_WalkBlock.walkAfterBlock(stream,parent);
		if(stream.hasMore()) {
			if(stream.token()._hx_index == 10) {
				parent.addChild(stream.consumeToken());
			}
		}
	}
};
tokentree_walk_WalkBlock.walkAfterBlock = function(stream,parent) {
	if(!stream.hasMore()) {
		return;
	}
	var _g = stream.token();
	switch(_g._hx_index) {
	case 2:
		var _g1 = _g.c;
		if(_g1._hx_index == 3) {
			if(_g1.s == "is") {
				tokentree_walk_WalkStatement.walkStatementWithoutSemicolon(stream,parent);
			}
		}
		break;
	case 5:
		if(parent.isCIdentOrCString()) {
			tokentree_walk_WalkStatement.walkStatementWithoutSemicolon(stream,parent);
		}
		break;
	case 6:
		tokentree_walk_WalkStatement.walkStatementWithoutSemicolon(stream,parent);
		break;
	case 7:
		var nextTokDef = stream.peekNonCommentToken();
		if(nextTokDef == null) {
			return;
		}
		if(nextTokDef != null) {
			switch(nextTokDef._hx_index) {
			case 5:
				tokentree_walk_WalkComment.walkComment(stream,parent);
				tokentree_walk_WalkStatement.walkStatementContinue(stream,parent);
				break;
			case 6:
				tokentree_walk_WalkComment.walkComment(stream,parent);
				tokentree_walk_WalkStatement.walkStatementContinue(stream,parent);
				break;
			case 11:case 12:case 21:
				tokentree_walk_WalkComment.walkComment(stream,parent);
				tokentree_walk_WalkStatement.walkStatementContinue(stream,parent);
				break;
			default:
			}
		}
		break;
	case 8:
		var nextTokDef = stream.peekNonCommentToken();
		if(nextTokDef == null) {
			return;
		}
		if(nextTokDef != null) {
			switch(nextTokDef._hx_index) {
			case 5:
				tokentree_walk_WalkComment.walkComment(stream,parent);
				tokentree_walk_WalkStatement.walkStatementContinue(stream,parent);
				break;
			case 6:
				tokentree_walk_WalkComment.walkComment(stream,parent);
				tokentree_walk_WalkStatement.walkStatementContinue(stream,parent);
				break;
			case 11:case 12:case 21:
				tokentree_walk_WalkComment.walkComment(stream,parent);
				tokentree_walk_WalkStatement.walkStatementContinue(stream,parent);
				break;
			default:
			}
		}
		break;
	case 10:
		return;
	case 11:
		tokentree_walk_WalkStatement.walkStatementWithoutSemicolon(stream,parent);
		break;
	case 12:
		tokentree_walk_WalkStatement.walkDblDot(stream,parent);
		break;
	case 13:
		tokentree_walk_WalkStatement.walkStatementWithoutSemicolon(stream,parent);
		break;
	case 19:
		if(parent.parent.tok._hx_index == 4) {
			tokentree_walk_WalkStatement.walkStatementWithoutSemicolon(stream,parent);
		}
		break;
	case 21:
		tokentree_walk_WalkQuestion.walkQuestion(stream,parent);
		break;
	default:
	}
};
var tokentree_walk_WalkClass = function() { };
tokentree_walk_WalkClass.__name__ = true;
tokentree_walk_WalkClass.walkClass = function(stream,parent) {
	var typeTok = stream.consumeToken();
	parent.addChild(typeTok);
	tokentree_walk_WalkComment.walkComment(stream,parent);
	var name = typeTok;
	var _g = stream.token();
	switch(_g._hx_index) {
	case 2:
		if(_g.c._hx_index == 3) {
			name = tokentree_walk_WalkTypeNameDef.walkTypeNameDef(stream,typeTok);
			stream.applyTempStore(name);
		}
		break;
	case 4:
		name = tokentree_walk_WalkTypeNameDef.walkTypeNameDef(stream,typeTok);
		stream.applyTempStore(name);
		break;
	default:
	}
	tokentree_walk_WalkClass.walkClassExtends(stream,name);
	var block = stream.consumeTokenDef(tokentree_TokenTreeDef.BrOpen);
	name.addChild(block);
	tokentree_walk_WalkClass.walkClassBody(stream,block);
	block.addChild(stream.consumeTokenDef(tokentree_TokenTreeDef.BrClose));
};
tokentree_walk_WalkClass.walkClassExtends = function(stream,name) {
	var progress = new tokentree_TokenStreamProgress(stream);
	while(progress.streamHasChanged()) {
		tokentree_walk_WalkExtends.walkExtends(stream,name);
		tokentree_walk_WalkImplements.walkImplements(stream,name);
		if(stream.isSharp()) {
			tokentree_walk_WalkSharp.walkSharp(stream,name,tokentree_walk_WalkClass.walkClassExtends);
		}
		tokentree_walk_WalkComment.walkComment(stream,name);
	}
};
tokentree_walk_WalkClass.walkClassBody = function(stream,parent) {
	var progress = new tokentree_TokenStreamProgress(stream);
	_hx_loop1: while(stream.hasMore() && progress.streamHasChanged()) {
		var _g = stream.token();
		switch(_g._hx_index) {
		case 1:
			switch(_g.k._hx_index) {
			case 0:
				tokentree_walk_WalkFunction.walkFunction(stream,parent);
				break;
			case 2:
				tokentree_walk_WalkVar.walkVar(stream,parent);
				break;
			case 17:case 18:case 19:case 25:case 30:case 32:case 34:case 39:case 40:case 43:
				stream.consumeToTempStore();
				break;
			case 41:
				tokentree_walk_WalkFinal.walkFinal(stream,parent);
				break;
			default:
				switch(tokentree_TokenStream.MODE._hx_index) {
				case 0:
					throw haxe_Exception.thrown("invalid token tree structure - found:" + ("" + Std.string(stream.token())));
				case 1:
					tokentree_walk_WalkStatement.walkStatement(stream,parent);
					break;
				}
			}
			break;
		case 3:
			tokentree_walk_WalkSharp.walkSharp(stream,parent,tokentree_walk_WalkClass.walkClassBody);
			tokentree_walk_WalkClass.walkClassContinueAfterSharp(stream,parent);
			break;
		case 7:
			if(stream.hasTempStore()) {
				stream.consumeToTempStore();
			} else {
				parent.addChild(stream.consumeToken());
			}
			break;
		case 8:
			if(stream.hasTempStore()) {
				stream.consumeToTempStore();
			} else {
				parent.addChild(stream.consumeToken());
			}
			break;
		case 10:
			parent.addChild(stream.consumeToken());
			break;
		case 18:
			break _hx_loop1;
		case 22:
			stream.addToTempStore(tokentree_walk_WalkAt.walkAt(stream));
			break;
		default:
			switch(tokentree_TokenStream.MODE._hx_index) {
			case 0:
				throw haxe_Exception.thrown("invalid token tree structure - found:" + ("" + Std.string(stream.token())));
			case 1:
				tokentree_walk_WalkStatement.walkStatement(stream,parent);
				break;
			}
		}
	}
	var tempStore = stream.getTempStore();
	if(tempStore.length > 0) {
		switch(tokentree_TokenStream.MODE._hx_index) {
		case 0:
			throw haxe_Exception.thrown("invalid token tree structure - found:" + ("" + Std.string(tempStore)));
		case 1:
			stream.applyTempStore(parent);
			break;
		}
	}
};
tokentree_walk_WalkClass.walkClassContinueAfterSharp = function(stream,parent) {
	var brOpen = tokentree_TokenTreeAccessHelper.matches(tokentree_TokenTreeAccessHelper.lastChild(tokentree_TokenTreeAccessHelper.firstChild(tokentree_TokenTreeAccessHelper.lastOf(tokentree_TokenTreeAccessHelper.matches(tokentree_TokenTreeAccessHelper.lastChild(parent),tokentree_TokenTreeDef.Sharp("if")),tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdFunction)))),tokentree_TokenTreeDef.BrOpen);
	if(brOpen == null) {
		return;
	}
	if(tokentree_TokenTreeAccessHelper.matches(tokentree_TokenTreeAccessHelper.lastChild(brOpen),tokentree_TokenTreeDef.BrClose) != null) {
		return;
	}
	tokentree_walk_WalkBlock.walkBlockContinue(stream,parent);
};
var tokentree_walk_WalkComment = function() { };
tokentree_walk_WalkComment.__name__ = true;
tokentree_walk_WalkComment.walkComment = function(stream,parent) {
	var progress = new tokentree_TokenStreamProgress(stream);
	while(stream.hasMore() && progress.streamHasChanged()) switch(stream.token()._hx_index) {
	case 7:
		parent.addChild(stream.consumeToken());
		break;
	case 8:
		parent.addChild(stream.consumeToken());
		break;
	default:
		return;
	}
};
tokentree_walk_WalkComment.tryWalkComment = function(stream,parent,expect) {
	var currentPos = stream.getStreamIndex();
	var progress = new tokentree_TokenStreamProgress(stream);
	var comments = [];
	while(stream.hasMore() && progress.streamHasChanged()) switch(stream.token()._hx_index) {
	case 7:
		comments.push(stream.consumeToken());
		break;
	case 8:
		comments.push(stream.consumeToken());
		break;
	default:
		if(stream.matches(expect)) {
			var _g = 0;
			while(_g < comments.length) parent.addChild(comments[_g++]);
			return;
		}
		stream.rewindTo(currentPos);
		return;
	}
};
var tokentree_walk_WalkDoWhile = function() { };
tokentree_walk_WalkDoWhile.__name__ = true;
tokentree_walk_WalkDoWhile.walkDoWhile = function(stream,parent) {
	var doTok = stream.consumeTokenDef(tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdDo));
	parent.addChild(doTok);
	stream.applyTempStore(doTok);
	tokentree_walk_WalkComment.walkComment(stream,doTok);
	tokentree_walk_WalkBlock.walkBlock(stream,doTok);
	var whileTok = stream.consumeTokenDef(tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdWhile));
	doTok.addChild(whileTok);
	tokentree_walk_WalkStatement.walkStatement(stream,whileTok);
	tokentree_walk_WalkComment.walkComment(stream,whileTok);
	if(stream.tokenForMatch()._hx_index == 10) {
		whileTok.addChild(stream.consumeToken());
	}
};
var tokentree_walk_WalkEnum = function() { };
tokentree_walk_WalkEnum.__name__ = true;
tokentree_walk_WalkEnum.walkEnum = function(stream,parent) {
	var typeTok = stream.consumeToken();
	var _g = stream.tokenForMatch();
	if(_g._hx_index == 1 && _g.k._hx_index == 39) {
		stream.addToTempStore(typeTok);
		tokentree_walk_WalkAbstract.walkAbstract(stream,parent);
		return;
	}
	parent.addChild(typeTok);
	var name = tokentree_walk_WalkTypeNameDef.walkTypeNameDef(stream,typeTok);
	stream.applyTempStore(name);
	tokentree_walk_WalkBlock.walkBlock(stream,name);
};
var tokentree_walk_WalkExtends = function() { };
tokentree_walk_WalkExtends.__name__ = true;
tokentree_walk_WalkExtends.walkExtends = function(stream,parent) {
	var _g = stream.tokenForMatch();
	if(!(_g._hx_index == 1 && _g.k._hx_index == 11)) {
		return;
	}
	var parentType = stream.consumeTokenDef(tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdExtends));
	parent.addChild(parentType);
	tokentree_walk_WalkComment.walkComment(stream,parent);
	tokentree_walk_WalkTypeNameDef.walkTypeNameDef(stream,parentType);
	tokentree_walk_WalkComment.walkComment(stream,parent);
	tokentree_walk_WalkExtends.walkExtends(stream,parentType);
	tokentree_walk_WalkComment.walkComment(stream,parent);
};
var tokentree_walk_WalkFieldDef = function() { };
tokentree_walk_WalkFieldDef.__name__ = true;
tokentree_walk_WalkFieldDef.walkFieldDef = function(stream,parent) {
	var progress = new tokentree_TokenStreamProgress(stream);
	_hx_loop1: while(progress.streamHasChanged()) {
		var _g = stream.token();
		switch(_g._hx_index) {
		case 1:
			switch(_g.k._hx_index) {
			case 0:case 2:case 41:
				var tok = stream.consumeToken();
				parent.addChild(tok);
				parent = tok;
				break;
			default:
				break _hx_loop1;
			}
			break;
		case 7:
			tokentree_walk_WalkComment.walkComment(stream,parent);
			break;
		case 8:
			tokentree_walk_WalkComment.walkComment(stream,parent);
			break;
		case 22:
			stream.addToTempStore(tokentree_walk_WalkAt.walkAt(stream));
			break;
		default:
			break _hx_loop1;
		}
	}
	var name = tokentree_walk_WalkTypeNameDef.walkTypeNameDef(stream,parent);
	stream.applyTempStore(name);
	if(stream.tokenForMatch()._hx_index == 12) {
		var dblDot = stream.consumeTokenDef(tokentree_TokenTreeDef.DblDot);
		name.addChild(dblDot);
		tokentree_walk_WalkTypedefBody.walkTypedefBody(stream,dblDot);
	}
	var _g = stream.tokenForMatch();
	if(_g._hx_index == 6 && _g.op._hx_index == 4) {
		tokentree_walk_WalkStatement.walkStatement(stream,name);
	}
	switch(stream.token()._hx_index) {
	case 10:
		name.addChild(stream.consumeTokenDef(tokentree_TokenTreeDef.Semicolon));
		break;
	case 14:
		name.addChild(stream.consumeTokenDef(tokentree_TokenTreeDef.Comma));
		break;
	default:
	}
};
var tokentree_walk_WalkFile = function() { };
tokentree_walk_WalkFile.__name__ = true;
tokentree_walk_WalkFile.walkFile = function(stream,parent) {
	var progress = new tokentree_TokenStreamProgress(stream);
	while(stream.hasMore() && progress.streamHasChanged()) {
		var _g = stream.token();
		switch(_g._hx_index) {
		case 1:
			switch(_g.k._hx_index) {
			case 0:
				tokentree_walk_WalkFunction.walkFunction(stream,parent);
				break;
			case 2:
				tokentree_walk_WalkVar.walkVar(stream,parent);
				break;
			case 13:case 33:case 35:
				stream.applyTempStore(parent);
				tokentree_walk_WalkPackageImport.walkPackageImport(stream,parent);
				break;
			case 17:case 18:case 19:case 25:case 32:case 34:case 40:case 43:
				stream.consumeToTempStore();
				break;
			case 1:case 26:case 27:case 31:case 39:
				tokentree_walk_WalkType.walkType(stream,parent);
				break;
			case 41:
				tokentree_walk_WalkFinal.walkFinal(stream,parent);
				break;
			default:
				tokentree_walk_WalkBlock.walkBlock(stream,parent);
			}
			break;
		case 3:
			tokentree_walk_WalkSharp.walkSharp(stream,parent,tokentree_walk_WalkFile.walkFile);
			if(!stream.hasMore()) {
				return;
			}
			if(stream.token()._hx_index == 17) {
				tokentree_walk_WalkBlock.walkBlock(stream,parent.children[parent.children.length - 1]);
			}
			break;
		case 7:
			if(stream.hasTempStore()) {
				stream.consumeToTempStore();
			} else {
				tokentree_walk_WalkComment.walkComment(stream,parent);
			}
			break;
		case 8:
			if(stream.hasTempStore()) {
				stream.consumeToTempStore();
			} else {
				tokentree_walk_WalkComment.walkComment(stream,parent);
			}
			break;
		case 10:case 14:case 16:case 18:case 20:
			parent.addChild(stream.consumeToken());
			break;
		case 22:
			stream.addToTempStore(tokentree_walk_WalkAt.walkAt(stream));
			break;
		default:
			tokentree_walk_WalkBlock.walkBlock(stream,parent);
		}
	}
	var tempStore = stream.getTempStore();
	var _g = 0;
	while(_g < tempStore.length) {
		var stored = tempStore[_g];
		++_g;
		var _g1 = stored.tok;
		switch(_g1._hx_index) {
		case 1:
			switch(_g1.k._hx_index) {
			case 18:case 19:case 25:
				switch(tokentree_TokenStream.MODE._hx_index) {
				case 0:
					throw haxe_Exception.thrown("invalid token tree structure - found:" + Std.string(stored));
				case 1:
					parent.addChild(stored);
					break;
				}
				break;
			default:
				parent.addChild(stored);
			}
			break;
		case 22:
			switch(tokentree_TokenStream.MODE._hx_index) {
			case 0:
				throw haxe_Exception.thrown("invalid token tree structure - found:" + Std.string(stored));
			case 1:
				parent.addChild(stored);
				break;
			}
			break;
		default:
			parent.addChild(stored);
		}
	}
};
var tokentree_walk_WalkFinal = function() { };
tokentree_walk_WalkFinal.__name__ = true;
tokentree_walk_WalkFinal.walkFinal = function(stream,parent) {
	var name = null;
	var finalTok = stream.consumeToken();
	stream.addToTempStore(finalTok);
	tokentree_walk_WalkComment.walkComment(stream,parent);
	var progress = new tokentree_TokenStreamProgress(stream);
	_hx_loop1: while(progress.streamHasChanged()) {
		var _g = stream.token();
		switch(_g._hx_index) {
		case 1:
			switch(_g.k._hx_index) {
			case 0:
				return;
			case 1:case 27:
				return;
			case 17:case 18:case 19:case 25:case 30:case 32:case 34:case 40:
				stream.consumeToTempStore();
				break;
			default:
			}
			break;
		case 2:
			if(_g.c._hx_index == 3) {
				break _hx_loop1;
			}
			break;
		case 7:
			stream.consumeToTempStore();
			break;
		case 8:
			stream.consumeToTempStore();
			break;
		default:
		}
	}
	parent.addChild(finalTok);
	var progress = new tokentree_TokenStreamProgress(stream);
	while(progress.streamHasChanged()) {
		tokentree_walk_WalkComment.walkComment(stream,parent);
		if(stream.token()._hx_index == 22) {
			tokentree_walk_WalkAt.walkAts(stream);
		}
		tokentree_walk_WalkComment.walkComment(stream,parent);
		var nameParent = finalTok;
		if(stream.tokenForMatch()._hx_index == 21) {
			nameParent = stream.consumeToken();
			finalTok.addChild(nameParent);
		}
		name = stream.consumeConstIdent();
		nameParent.addChild(name);
		var tempStore = stream.getTempStore();
		var _g = 0;
		while(_g < tempStore.length) {
			var stored = tempStore[_g];
			++_g;
			var _g1 = stored.tok;
			if(_g1._hx_index == 1) {
				if(_g1.k._hx_index != 41) {
					name.addChild(stored);
				}
			} else {
				name.addChild(stored);
			}
		}
		stream.clearTempStore();
		tokentree_walk_WalkComment.walkComment(stream,name);
		if(stream.tokenForMatch()._hx_index == 19) {
			tokentree_walk_WalkPOpen.walkPOpen(stream,name);
		}
		if(stream.tokenForMatch()._hx_index == 12) {
			var dblDot = stream.consumeToken();
			name.addChild(dblDot);
			tokentree_walk_WalkTypedefBody.walkTypedefAlias(stream,dblDot);
		}
		var _g2 = stream.tokenForMatch();
		if(_g2._hx_index == 6 && _g2.op._hx_index == 4) {
			tokentree_walk_WalkStatement.walkStatement(stream,name);
		}
		if(stream.tokenForMatch()._hx_index == 14) {
			name.addChild(stream.consumeToken());
			continue;
		}
		break;
	}
	if(stream.tokenForMatch()._hx_index == 10) {
		name.addChild(stream.consumeToken());
	}
};
var tokentree_walk_WalkFor = function() { };
tokentree_walk_WalkFor.__name__ = true;
tokentree_walk_WalkFor.walkFor = function(stream,parent) {
	var forTok = stream.consumeTokenDef(tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdFor));
	parent.addChild(forTok);
	stream.applyTempStore(forTok);
	tokentree_walk_WalkComment.walkComment(stream,forTok);
	tokentree_walk_WalkFor.walkForPOpen(stream,forTok);
	tokentree_walk_WalkComment.walkComment(stream,forTok);
	tokentree_walk_WalkBlock.walkBlock(stream,forTok);
};
tokentree_walk_WalkFor.walkForPOpen = function(stream,parent) {
	var pOpen = stream.consumeTokenDef(tokentree_TokenTreeDef.POpen);
	parent.addChild(pOpen);
	tokentree_walk_WalkComment.walkComment(stream,pOpen);
	var identifier = null;
	if(stream.token()._hx_index == 4) {
		tokentree_walk_WalkStatement.walkStatement(stream,pOpen);
		identifier = pOpen.getLastChild();
	} else {
		identifier = stream.consumeConstIdent();
		pOpen.addChild(identifier);
	}
	tokentree_walk_WalkComment.walkComment(stream,identifier);
	var _g = stream.tokenForMatch();
	if(_g._hx_index == 6 && _g.op._hx_index == 22) {
		var arrowTok = stream.consumeToken();
		identifier.addChild(arrowTok);
		if(stream.token()._hx_index == 4) {
			tokentree_walk_WalkStatement.walkStatement(stream,arrowTok);
		} else {
			arrowTok.addChild(stream.consumeConstIdent());
		}
	}
	var inTok = null;
	var _g = stream.token();
	switch(_g._hx_index) {
	case 6:
		if(_g.op._hx_index == 23) {
			inTok = stream.consumeToken();
			identifier.addChild(inTok);
			tokentree_walk_WalkComment.walkComment(stream,inTok);
			tokentree_walk_WalkStatement.walkStatement(stream,inTok);
			tokentree_walk_WalkComment.walkComment(stream,pOpen);
			pOpen.addChild(stream.consumeTokenDef(tokentree_TokenTreeDef.PClose));
			tokentree_walk_WalkComment.walkComment(stream,parent);
		}
		break;
	case 20:
		pOpen.addChild(stream.consumeToken());
		tokentree_walk_WalkComment.walkComment(stream,parent);
		return;
	default:
	}
};
var tokentree_walk_WalkFunction = function() { };
tokentree_walk_WalkFunction.__name__ = true;
tokentree_walk_WalkFunction.walkFunction = function(stream,parent) {
	var funcTok = stream.consumeTokenDef(tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdFunction));
	parent.addChild(funcTok);
	tokentree_walk_WalkComment.walkComment(stream,funcTok);
	var name = funcTok;
	var _g = stream.token();
	switch(_g._hx_index) {
	case 1:
		if(_g.k._hx_index == 22) {
			name = tokentree_walk_WalkTypeNameDef.walkTypeNameDef(stream,funcTok);
		} else {
			name = tokentree_walk_WalkTypeNameDef.walkTypeNameDef(stream,funcTok);
		}
		break;
	case 6:
		if(_g.op._hx_index == 9) {
			tokentree_walk_WalkLtGt.walkLtGt(stream,funcTok);
			name = funcTok.getLastChild();
		} else {
			name = tokentree_walk_WalkTypeNameDef.walkTypeNameDef(stream,funcTok);
		}
		break;
	case 19:
		break;
	default:
		name = tokentree_walk_WalkTypeNameDef.walkTypeNameDef(stream,funcTok);
	}
	stream.applyTempStore(name);
	tokentree_walk_WalkComment.walkComment(stream,name);
	tokentree_walk_WalkFunction.walkFunctionParameters(stream,name);
	tokentree_walk_WalkComment.walkComment(stream,name);
	if(stream.token()._hx_index == 3) {
		tokentree_walk_WalkSharp.walkSharp(stream,name,tokentree_walk_WalkStatement.walkStatement);
		switch(stream.token()._hx_index) {
		case 12:case 17:
			break;
		default:
			return;
		}
	}
	if(stream.tokenForMatch()._hx_index == 12) {
		var dblDot = stream.consumeToken();
		name.addChild(dblDot);
		tokentree_walk_WalkTypeNameDef.walkTypeNameDef(stream,dblDot);
	}
	tokentree_walk_WalkBlock.walkBlock(stream,name);
};
tokentree_walk_WalkFunction.walkFunctionParameters = function(stream,parent) {
	var pOpen = stream.consumeTokenDef(tokentree_TokenTreeDef.POpen);
	parent.addChild(pOpen);
	var progress = new tokentree_TokenStreamProgress(stream);
	while(progress.streamHasChanged()) {
		tokentree_walk_WalkComment.walkComment(stream,pOpen);
		if(stream.tokenForMatch()._hx_index == 20) {
			break;
		}
		tokentree_walk_WalkFieldDef.walkFieldDef(stream,pOpen);
	}
	pOpen.addChild(stream.consumeTokenDef(tokentree_TokenTreeDef.PClose));
};
var tokentree_walk_WalkIf = function() { };
tokentree_walk_WalkIf.__name__ = true;
tokentree_walk_WalkIf.walkIf = function(stream,parent) {
	var ifTok = stream.consumeTokenDef(tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdIf));
	parent.addChild(ifTok);
	stream.applyTempStore(ifTok);
	tokentree_walk_WalkStatement.walkStatement(stream,ifTok);
	if(stream.tokenForMatch()._hx_index == 12) {
		return;
	}
	tokentree_walk_WalkBlock.walkBlock(stream,ifTok);
	tokentree_walk_WalkComment.tryWalkComment(stream,ifTok,tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdElse));
	var _g = stream.tokenForMatch();
	if(_g._hx_index == 1 && _g.k._hx_index == 4) {
		var elseTok = stream.consumeTokenDef(tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdElse));
		ifTok.addChild(elseTok);
		tokentree_walk_WalkBlock.walkBlock(stream,elseTok);
	}
};
var tokentree_walk_WalkImplements = function() { };
tokentree_walk_WalkImplements.__name__ = true;
tokentree_walk_WalkImplements.walkImplements = function(stream,parent) {
	var _g = stream.tokenForMatch();
	if(!(_g._hx_index == 1 && _g.k._hx_index == 12)) {
		return;
	}
	var interfacePart = stream.consumeTokenDef(tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdImplements));
	parent.addChild(interfacePart);
	tokentree_walk_WalkComment.walkComment(stream,parent);
	tokentree_walk_WalkTypeNameDef.walkTypeNameDef(stream,interfacePart);
	tokentree_walk_WalkComment.walkComment(stream,parent);
	tokentree_walk_WalkImplements.walkImplements(stream,parent);
	tokentree_walk_WalkComment.walkComment(stream,parent);
};
var tokentree_walk_WalkInterface = function() { };
tokentree_walk_WalkInterface.__name__ = true;
tokentree_walk_WalkInterface.walkInterface = function(stream,parent) {
	var typeTok = stream.consumeToken();
	parent.addChild(typeTok);
	var name = tokentree_walk_WalkTypeNameDef.walkTypeNameDef(stream,typeTok);
	stream.applyTempStore(name);
	tokentree_walk_WalkClass.walkClassExtends(stream,name);
	var block = stream.consumeTokenDef(tokentree_TokenTreeDef.BrOpen);
	name.addChild(block);
	tokentree_walk_WalkInterface.walkInterfaceBody(stream,block);
	block.addChild(stream.consumeTokenDef(tokentree_TokenTreeDef.BrClose));
};
tokentree_walk_WalkInterface.walkInterfaceBody = function(stream,parent) {
	var progress = new tokentree_TokenStreamProgress(stream);
	_hx_loop1: while(progress.streamHasChanged()) {
		var _g = stream.token();
		switch(_g._hx_index) {
		case 1:
			switch(_g.k._hx_index) {
			case 0:
				tokentree_walk_WalkFunction.walkFunction(stream,parent);
				break;
			case 2:
				tokentree_walk_WalkVar.walkVar(stream,parent);
				break;
			case 17:case 18:case 19:case 25:case 30:case 32:case 34:case 40:
				stream.consumeToTempStore();
				break;
			case 41:
				tokentree_walk_WalkFinal.walkFinal(stream,parent);
				break;
			default:
				stream.consumeToTempStore();
			}
			break;
		case 3:
			tokentree_walk_WalkSharp.walkSharp(stream,parent,tokentree_walk_WalkInterface.walkInterfaceBody);
			break;
		case 7:
			if(stream.hasTempStore()) {
				stream.consumeToTempStore();
			} else {
				parent.addChild(stream.consumeToken());
			}
			break;
		case 8:
			if(stream.hasTempStore()) {
				stream.consumeToTempStore();
			} else {
				parent.addChild(stream.consumeToken());
			}
			break;
		case 10:
			parent.addChild(stream.consumeToken());
			break;
		case 18:
			break _hx_loop1;
		case 22:
			stream.addToTempStore(tokentree_walk_WalkAt.walkAt(stream));
			break;
		default:
			stream.consumeToTempStore();
		}
	}
	stream.applyTempStore(parent);
};
var tokentree_walk_WalkLtGt = function() { };
tokentree_walk_WalkLtGt.__name__ = true;
tokentree_walk_WalkLtGt.walkLtGt = function(stream,parent) {
	var ltTok = stream.consumeTokenDef(tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpLt));
	parent.addChild(ltTok);
	var progress = new tokentree_TokenStreamProgress(stream);
	_hx_loop1: while(progress.streamHasChanged()) {
		var _g = stream.token();
		switch(_g._hx_index) {
		case 6:
			if(_g.op._hx_index == 7) {
				break _hx_loop1;
			} else {
				tokentree_walk_WalkFieldDef.walkFieldDef(stream,ltTok);
			}
			break;
		case 12:
			ltTok.addChild(stream.consumeToken());
			tokentree_walk_WalkTypeNameDef.walkTypeNameDef(stream,ltTok);
			break;
		case 14:
			ltTok.addChild(stream.consumeToken());
			tokentree_walk_WalkTypeNameDef.walkTypeNameDef(stream,ltTok);
			var _g1 = stream.token();
			if(!(_g1._hx_index == 6 && _g1.op._hx_index == 7)) {
				tokentree_walk_WalkFieldDef.walkFieldDef(stream,ltTok);
			}
			break;
		case 19:
			tokentree_walk_WalkPOpen.walkPOpen(stream,ltTok);
			break;
		default:
			tokentree_walk_WalkFieldDef.walkFieldDef(stream,ltTok);
		}
	}
	ltTok.addChild(stream.consumeTokenDef(tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpGt)));
};
var tokentree_walk_WalkNew = function() { };
tokentree_walk_WalkNew.__name__ = true;
tokentree_walk_WalkNew.walkNew = function(stream,parent) {
	var newTok = stream.consumeTokenDef(tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdNew));
	parent.addChild(newTok);
	var name = tokentree_walk_WalkTypeNameDef.walkTypeNameDef(stream,newTok);
	tokentree_walk_WalkComment.walkComment(stream,name);
	switch(stream.token()._hx_index) {
	case 3:
		tokentree_walk_WalkSharp.walkSharp(stream,parent,tokentree_walk_WalkStatement.walkStatement);
		break;
	case 19:
		tokentree_walk_WalkPOpen.walkPOpen(stream,name);
		break;
	default:
	}
	tokentree_walk_WalkComment.walkComment(stream,name);
	var _g = stream.token();
	switch(_g._hx_index) {
	case 2:
		var _g1 = _g.c;
		if(_g1._hx_index == 3) {
			if(_g1.s == "is") {
				tokentree_walk_WalkStatement.walkStatement(stream,name);
			}
		}
		break;
	case 6:
		tokentree_walk_WalkStatement.walkStatement(stream,name);
		break;
	case 11:case 15:
		tokentree_walk_WalkStatement.walkStatement(stream,name);
		break;
	default:
	}
};
var tokentree_walk_WalkPOpen = function() { };
tokentree_walk_WalkPOpen.__name__ = true;
tokentree_walk_WalkPOpen.walkPOpen = function(stream,parent,walkTrailingComments) {
	if(walkTrailingComments == null) {
		walkTrailingComments = true;
	}
	var pOpen = stream.consumeTokenDef(tokentree_TokenTreeDef.POpen);
	parent.addChild(pOpen);
	tokentree_walk_WalkPOpen.walkPOpenParts(stream,pOpen);
	pOpen.addChild(stream.consumeTokenDef(tokentree_TokenTreeDef.PClose));
	if(walkTrailingComments) {
		tokentree_walk_WalkComment.walkComment(stream,parent);
	}
	if(stream.hasMore()) {
		if(stream.token()._hx_index == 13) {
			var arrow = stream.consumeToken();
			pOpen.addChild(arrow);
			tokentree_walk_WalkBlock.walkBlock(stream,arrow);
		}
	}
	return pOpen;
};
tokentree_walk_WalkPOpen.walkPOpenParts = function(stream,parent) {
	var progress = new tokentree_TokenStreamProgress(stream);
	_hx_loop1: while(progress.streamHasChanged()) switch(stream.token()._hx_index) {
	case 3:
		tokentree_walk_WalkSharp.walkSharp(stream,parent,tokentree_walk_WalkPOpen.walkPOpenParts);
		break;
	case 14:
		var comma = stream.consumeToken();
		var child = parent.getLastChild();
		if(child == null) {
			child = parent;
		}
		child.addChild(comma);
		break;
	case 15:
		tokentree_walk_WalkArrayAccess.walkArrayAccess(stream,parent);
		break;
	case 17:
		tokentree_walk_WalkBlock.walkBlock(stream,parent);
		break;
	case 20:
		break _hx_loop1;
	default:
		tokentree_walk_WalkStatement.walkStatement(stream,parent);
	}
};
var tokentree_walk_WalkPackageImport = function() { };
tokentree_walk_WalkPackageImport.__name__ = true;
tokentree_walk_WalkPackageImport.walkPackageImport = function(stream,parent) {
	var progress = new tokentree_TokenStreamProgress(stream);
	while(stream.hasMore() && progress.streamHasChanged()) switch(stream.token()._hx_index) {
	case 3:
		tokentree_walk_WalkSharp.walkSharp(stream,parent,tokentree_walk_WalkPackageImport.walkPackageImport);
		break;
	case 10:
		parent.addChild(stream.consumeToken());
		return;
	default:
		var newChild = stream.consumeToken();
		parent.addChild(newChild);
		parent = newChild;
	}
};
var tokentree_walk_WalkQuestion = function() { };
tokentree_walk_WalkQuestion.__name__ = true;
tokentree_walk_WalkQuestion.walkQuestion = function(stream,parent) {
	var ternary = tokentree_walk_WalkQuestion.isTernary(parent);
	var question = stream.consumeTokenDef(tokentree_TokenTreeDef.Question);
	parent.addChild(question);
	tokentree_walk_WalkComment.walkComment(stream,question);
	if(!ternary) {
		tokentree_walk_WalkStatement.walkStatement(stream,question);
		return;
	}
	tokentree_walk_WalkStatement.walkStatement(stream,question);
	tokentree_walk_WalkComment.walkComment(stream,question);
	if(stream.tokenForMatch()._hx_index != 12) {
		return;
	}
	var dblDotTok = stream.consumeTokenDef(tokentree_TokenTreeDef.DblDot);
	question.addChild(dblDotTok);
	tokentree_walk_WalkStatement.walkStatement(stream,dblDotTok);
};
tokentree_walk_WalkQuestion.isTernary = function(parent) {
	var lastChild = parent.getLastChild();
	if(lastChild == null) {
		if(parent.tok._hx_index == 2) {
			return true;
		} else {
			lastChild = parent;
		}
	}
	var _g = lastChild.tok;
	switch(_g._hx_index) {
	case 1:
		switch(_g.k._hx_index) {
		case 0:
			return true;
		case 22:
			return true;
		case 23:case 28:case 40:
			return true;
		case 29:
			return true;
		case 36:case 37:case 38:
			return true;
		default:
			return false;
		}
		break;
	case 2:
		return true;
	case 4:
		return true;
	case 5:
		return true;
	case 6:
		switch(_g.op._hx_index) {
		case 0:case 3:
			return true;
		default:
			return false;
		}
		break;
	case 12:
		return true;
	case 15:
		return true;
	case 17:
		return true;
	case 19:
		return true;
	case 20:
		return true;
	default:
		return false;
	}
};
var tokentree_walk_WalkSharp = function() { };
tokentree_walk_WalkSharp.__name__ = true;
tokentree_walk_WalkSharp.walkSharp = function(stream,parent,walker) {
	var _g = stream.token();
	if(_g._hx_index == 3) {
		switch(_g.s) {
		case "else":
			tokentree_walk_WalkSharp.walkSharpElse(stream,parent);
			break;
		case "elseif":
			tokentree_walk_WalkSharp.walkSharpElseIf(stream,parent);
			break;
		case "end":
			tokentree_walk_WalkSharp.walkSharpEnd(stream,parent);
			break;
		case "error":
			var errorToken = stream.consumeToken();
			parent.addChild(errorToken);
			var _g = stream.token();
			if(_g._hx_index == 2) {
				if(_g.c._hx_index == 2) {
					errorToken.addChild(stream.consumeToken());
				}
			}
			break;
		case "if":
			tokentree_walk_WalkSharp.walkSharpIf(stream,parent,walker);
			break;
		default:
			parent.addChild(stream.consumeToken());
		}
	}
};
tokentree_walk_WalkSharp.walkSharpIf = function(stream,parent,walker) {
	var ifToken = stream.consumeToken();
	parent.addChild(ifToken);
	tokentree_walk_WalkSharp.walkSharpIfExpr(stream,ifToken);
	stream.pushSharpIf(ifToken);
	var newParent = ifToken;
	var progress = new tokentree_TokenStreamProgress(stream);
	while(progress.streamHasChanged()) try {
		walker(stream,newParent);
		switch(stream.token()._hx_index) {
		case 14:case 18:case 20:
			newParent.addChild(stream.consumeToken());
			break;
		default:
		}
	} catch( _g ) {
		haxe_NativeStackTrace.lastError = _g;
		var _g1 = haxe_Exception.caught(_g).unwrap();
		if(((_g1) instanceof tokentree_walk_SharpElseException)) {
			newParent = _g1.token;
		} else if(((_g1) instanceof tokentree_walk_SharpEndException)) {
			stream.popSharpIf();
			return;
		} else {
			throw _g;
		}
	}
};
tokentree_walk_WalkSharp.walkSharpElse = function(stream,parent) {
	var sharpIfParent = stream.peekSharpIf();
	var ifToken = stream.consumeToken();
	sharpIfParent.addChild(ifToken);
	stream.applyTempStore(sharpIfParent);
	throw haxe_Exception.thrown(new tokentree_walk_SharpElseException(ifToken));
};
tokentree_walk_WalkSharp.walkSharpElseIf = function(stream,parent) {
	var sharpIfParent = stream.peekSharpIf();
	var ifToken = stream.consumeToken();
	sharpIfParent.addChild(ifToken);
	stream.applyTempStore(sharpIfParent);
	tokentree_walk_WalkSharp.walkSharpIfExpr(stream,ifToken);
	throw haxe_Exception.thrown(new tokentree_walk_SharpElseException(ifToken));
};
tokentree_walk_WalkSharp.walkSharpEnd = function(stream,parent) {
	var sharpIfParent = stream.peekSharpIf();
	var endToken = stream.consumeToken();
	stream.applyTempStore(sharpIfParent);
	sharpIfParent.addChild(endToken);
	throw haxe_Exception.thrown(new tokentree_walk_SharpEndException());
};
tokentree_walk_WalkSharp.walkSharpIfExpr = function(stream,parent) {
	var childToken;
	var progress = new tokentree_TokenStreamProgress(stream);
	while(progress.streamHasChanged()) {
		var _g = stream.token();
		switch(_g._hx_index) {
		case 1:
			childToken = stream.consumeToken();
			parent.addChild(childToken);
			if(!stream.hasMore()) {
				return;
			}
			if(stream.token()._hx_index != 11) {
				return;
			}
			var pos = stream.getTokenPos();
			if(pos == null) {
				return;
			}
			if(pos.min == childToken.pos.max + 1) {
				continue;
			}
			var dot = stream.consumeToken();
			childToken.addChild(dot);
			tokentree_walk_WalkSharp.walkSharpIfExpr(stream,dot);
			return;
		case 2:
			if(_g.c._hx_index == 3) {
				childToken = stream.consumeToken();
				parent.addChild(childToken);
				if(!stream.hasMore()) {
					return;
				}
				if(stream.token()._hx_index != 11) {
					return;
				}
				var pos1 = stream.getTokenPos();
				if(pos1 == null) {
					return;
				}
				if(pos1.min == childToken.pos.max + 1) {
					continue;
				}
				var dot1 = stream.consumeToken();
				childToken.addChild(dot1);
				tokentree_walk_WalkSharp.walkSharpIfExpr(stream,dot1);
				return;
			} else {
				return;
			}
			break;
		case 5:
			if(_g.op._hx_index == 2) {
				childToken = stream.consumeToken();
				parent.addChild(childToken);
				tokentree_walk_WalkSharp.walkSharpIfExpr(stream,childToken);
				return;
			} else {
				return;
			}
			break;
		case 19:
			tokentree_walk_WalkPOpen.walkPOpen(stream,parent);
			return;
		default:
			return;
		}
	}
};
var tokentree_walk_SharpElseException = function(token) {
	this.token = token;
};
tokentree_walk_SharpElseException.__name__ = true;
tokentree_walk_SharpElseException.prototype = {
	__class__: tokentree_walk_SharpElseException
};
var tokentree_walk_SharpEndException = function() {
};
tokentree_walk_SharpEndException.__name__ = true;
tokentree_walk_SharpEndException.prototype = {
	__class__: tokentree_walk_SharpEndException
};
var tokentree_walk_WalkStatement = function() { };
tokentree_walk_WalkStatement.__name__ = true;
tokentree_walk_WalkStatement.walkStatement = function(stream,parent) {
	tokentree_walk_WalkStatement.walkStatementWithoutSemicolon(stream,parent);
	if(stream.tokenForMatch()._hx_index == 10) {
		var semicolon = stream.consumeToken();
		var lastChild;
		var _g = parent.tok;
		if(_g._hx_index == 6) {
			switch(_g.op._hx_index) {
			case 0:case 3:case 14:case 15:
				lastChild = parent.parent.getLastChild();
				break;
			default:
				lastChild = parent.getLastChild();
			}
		} else {
			lastChild = parent.getLastChild();
		}
		if(lastChild == null) {
			lastChild = parent;
		}
		switch(lastChild.tok._hx_index) {
		case 16:case 18:case 20:
			lastChild = parent;
			break;
		default:
		}
		lastChild.addChild(semicolon);
	}
};
tokentree_walk_WalkStatement.walkStatementWithoutSemicolon = function(stream,parent) {
	while(true) {
		tokentree_walk_WalkComment.walkComment(stream,parent);
		var wantMore = true;
		tokentree_walk_WalkAt.walkAts(stream);
		var _g = stream.token();
		switch(_g._hx_index) {
		case 1:
			if(tokentree_walk_WalkStatement.walkKeyword(stream,parent)) {
				wantMore = true;
			} else {
				return;
			}
			break;
		case 2:
			var _g1 = _g.c;
			if(_g1._hx_index == 3) {
				switch(_g1.s) {
				case "final":
					if(tokentree_walk_WalkStatement.walkKeyword(stream,parent)) {
						wantMore = true;
					} else {
						return;
					}
					break;
				case "is":
					wantMore = true;
					break;
				default:
					wantMore = false;
				}
			} else {
				wantMore = false;
			}
			break;
		case 3:
			tokentree_walk_WalkSharp.walkSharp(stream,parent,tokentree_walk_WalkStatement.walkStatement);
			tokentree_walk_WalkStatement.walkStatementContinueAfterSharp(stream,parent);
			return;
		case 4:
			tokentree_walk_WalkStatement.walkDollarStatement(stream,parent);
			return;
		case 5:
			if(parent.isCIdentOrCString()) {
				var newChild = stream.consumeToken();
				parent.addChild(newChild);
				if(!stream.hasMore()) {
					return;
				}
				var _g2 = stream.token();
				switch(_g2._hx_index) {
				case 2:
					var _g3 = _g2.c;
					if(_g3._hx_index == 3) {
						if(_g3.s == "is") {
							tokentree_walk_WalkStatement.walkStatementWithoutSemicolon(stream,newChild);
						}
					}
					break;
				case 6:
					tokentree_walk_WalkStatement.walkStatementWithoutSemicolon(stream,newChild);
					break;
				case 11:
					tokentree_walk_WalkStatement.walkStatementWithoutSemicolon(stream,newChild);
					break;
				default:
				}
				return;
			}
			break;
		case 6:
			switch(_g.op._hx_index) {
			case 3:
				tokentree_walk_WalkBinopSub.walkBinopSub(stream,parent);
				return;
			case 7:
				var gtTok = stream.consumeOpGt();
				parent.addChild(gtTok);
				parent = gtTok;
				continue;
			case 9:
				if(stream.isTypedParam()) {
					tokentree_walk_WalkLtGt.walkLtGt(stream,parent);
					if(stream.tokenForMatch()._hx_index == 13) {
						tokentree_walk_WalkStatement.walkStatementWithoutSemicolon(stream,parent);
					}
					return;
				}
				wantMore = true;
				break;
			case 12:
				if(parent.parent != null && parent.parent.tok != tokentree_TokenTreeDef.Root) {
					var _g4 = parent.parent.tok;
					if(_g4._hx_index == 1) {
						if(_g4.k._hx_index == 15) {
							parent.addChild(stream.consumeToken());
							parent = parent.parent;
							continue;
						}
					}
				}
				wantMore = true;
				break;
			default:
				wantMore = true;
			}
			break;
		case 9:
			wantMore = true;
			break;
		case 10:
			return;
		case 11:
			wantMore = true;
			break;
		case 12:
			var _g5 = parent.tok;
			switch(_g5._hx_index) {
			case 1:
				if(_g5.k._hx_index == 40) {
					tokentree_walk_WalkStatement.walkDblDot(stream,parent);
					return;
				}
				break;
			case 11:
				return;
			default:
			}
			if(parent.tok._hx_index == 11) {
				return;
			}
			if(tokentree_walk_WalkQuestion.isTernary(parent)) {
				tokentree_walk_WalkStatement.walkStatementContinue(stream,parent);
				return;
			}
			wantMore = true;
			break;
		case 13:
			wantMore = true;
			break;
		case 14:
			return;
		case 15:
			tokentree_walk_WalkArrayAccess.walkArrayAccess(stream,parent);
			tokentree_walk_WalkStatement.walkStatementContinue(stream,parent);
			return;
		case 17:
			tokentree_walk_WalkBlock.walkBlock(stream,parent);
			return;
		case 16:case 18:case 20:
			return;
		case 19:
			tokentree_walk_WalkStatement.walkPOpen(stream,parent);
			return;
		case 21:
			tokentree_walk_WalkQuestion.walkQuestion(stream,parent);
			return;
		default:
			wantMore = false;
		}
		var newChild1 = stream.consumeToken();
		parent.addChild(newChild1);
		stream.applyTempStore(newChild1);
		tokentree_walk_WalkStatement.walkTrailingComment(stream,newChild1);
		if(wantMore) {
			tokentree_walk_WalkStatement.walkStatementWithoutSemicolon(stream,newChild1);
		}
		tokentree_walk_WalkStatement.walkStatementContinue(stream,newChild1);
		tokentree_walk_WalkStatement.walkTrailingComment(stream,newChild1);
		return;
	}
};
tokentree_walk_WalkStatement.walkTrailingComment = function(stream,parent) {
	if(!stream.hasMore()) {
		return;
	}
	if(stream.token()._hx_index == 8) {
		var currentPos = stream.getStreamIndex();
		var commentTok = stream.consumeToken();
		var _g = stream.tokenForMatch();
		if(!(_g._hx_index == 1 && _g.k._hx_index == 4)) {
			stream.rewindTo(currentPos);
			return;
		}
		parent.addChild(commentTok);
	}
};
tokentree_walk_WalkStatement.walkStatementContinue = function(stream,parent) {
	while(true) {
		if(!stream.hasMore()) {
			return;
		}
		var _g = stream.token();
		switch(_g._hx_index) {
		case 2:
			var _g1 = _g.c;
			if(_g1._hx_index == 3) {
				if(_g1.s == "is") {
					tokentree_walk_WalkStatement.walkStatementWithoutSemicolon(stream,parent);
				}
			}
			break;
		case 5:
			if(parent.isCIdentOrCString()) {
				tokentree_walk_WalkStatement.walkStatementWithoutSemicolon(stream,parent);
			}
			break;
		case 6:
			switch(_g.op._hx_index) {
			case 0:case 3:
				tokentree_walk_WalkStatement.walkOpAdd(stream,parent);
				break;
			case 7:
				var ltParent = parent;
				_hx_loop2: while(true) {
					var _g2 = ltParent.tok;
					switch(_g2._hx_index) {
					case 0:
						break _hx_loop2;
					case 2:
						ltParent = ltParent.parent;
						break;
					case 4:
						ltParent = ltParent.parent;
						break;
					case 6:
						switch(_g2.op._hx_index) {
						case 7:
							ltParent = ltParent.parent;
							break;
						case 9:
							return;
						default:
							break _hx_loop2;
						}
						break;
					case 11:case 12:case 13:case 14:case 15:case 17:case 19:
						ltParent = ltParent.parent;
						break;
					default:
						break _hx_loop2;
					}
				}
				tokentree_walk_WalkStatement.walkStatementWithoutSemicolon(stream,parent);
				break;
			case 14:case 15:
				tokentree_walk_WalkStatement.walkOpBool(stream,parent);
				break;
			default:
				tokentree_walk_WalkStatement.walkStatementWithoutSemicolon(stream,parent);
			}
			break;
		case 7:
			var nextTokDef = stream.peekNonCommentToken();
			if(nextTokDef == null) {
				return;
			}
			if(nextTokDef != null) {
				switch(nextTokDef._hx_index) {
				case 5:
					tokentree_walk_WalkComment.walkComment(stream,parent);
					continue;
				case 6:
					tokentree_walk_WalkComment.walkComment(stream,parent);
					continue;
				case 11:case 12:case 21:
					tokentree_walk_WalkComment.walkComment(stream,parent);
					continue;
				default:
				}
			}
			break;
		case 8:
			var nextTokDef1 = stream.peekNonCommentToken();
			if(nextTokDef1 == null) {
				return;
			}
			if(nextTokDef1 != null) {
				switch(nextTokDef1._hx_index) {
				case 5:
					tokentree_walk_WalkComment.walkComment(stream,parent);
					continue;
				case 6:
					tokentree_walk_WalkComment.walkComment(stream,parent);
					continue;
				case 11:case 12:case 21:
					tokentree_walk_WalkComment.walkComment(stream,parent);
					continue;
				default:
				}
			}
			break;
		case 10:
			return;
		case 11:
			tokentree_walk_WalkStatement.walkStatementWithoutSemicolon(stream,parent);
			break;
		case 12:
			tokentree_walk_WalkStatement.walkDblDot(stream,parent);
			break;
		case 13:
			tokentree_walk_WalkStatement.walkStatementWithoutSemicolon(stream,parent);
			break;
		case 15:
			tokentree_walk_WalkStatement.walkStatementWithoutSemicolon(stream,parent);
			break;
		case 19:
			tokentree_walk_WalkStatement.walkStatementWithoutSemicolon(stream,parent);
			break;
		case 21:
			tokentree_walk_WalkQuestion.walkQuestion(stream,parent);
			break;
		default:
		}
		return;
	}
};
tokentree_walk_WalkStatement.walkKeyword = function(stream,parent) {
	var _g = stream.token();
	if(_g._hx_index == 1) {
		switch(_g.k._hx_index) {
		case 0:
			tokentree_walk_WalkFunction.walkFunction(stream,parent);
			break;
		case 1:
			tokentree_walk_WalkClass.walkClass(stream,parent);
			break;
		case 2:
			tokentree_walk_WalkVar.walkVar(stream,parent);
			break;
		case 3:
			tokentree_walk_WalkIf.walkIf(stream,parent);
			break;
		case 5:
			var tmp;
			if(parent.tok._hx_index != 17) {
				var _g = parent.parent.tok;
				tmp = _g._hx_index == 1 && _g.k._hx_index == 6;
			} else {
				tmp = false;
			}
			if(tmp) {
				return false;
			}
			tokentree_walk_WalkWhile.walkWhile(stream,parent);
			break;
		case 6:
			tokentree_walk_WalkDoWhile.walkDoWhile(stream,parent);
			break;
		case 7:
			tokentree_walk_WalkFor.walkFor(stream,parent);
			break;
		case 10:case 40:
			return true;
		case 14:
			tokentree_walk_WalkSwitch.walkSwitch(stream,parent);
			break;
		case 15:
			return false;
		case 16:
			if(parent.tok._hx_index == 17) {
				return false;
			}
			return true;
		case 20:
			tokentree_walk_WalkTry.walkTry(stream,parent);
			break;
		case 22:
			if(parent.tok._hx_index == 11) {
				var newChild = stream.consumeToken();
				parent.addChild(newChild);
				tokentree_walk_WalkStatement.walkStatementContinue(stream,newChild);
			} else {
				tokentree_walk_WalkNew.walkNew(stream,parent);
			}
			break;
		case 23:
			var newChild = stream.consumeToken();
			parent.addChild(newChild);
			tokentree_walk_WalkStatement.walkStatementContinue(stream,newChild);
			return false;
		case 29:
			var newChild = stream.consumeToken();
			parent.addChild(newChild);
			tokentree_walk_WalkStatement.walkStatementWithoutSemicolon(stream,newChild);
			return false;
		case 36:case 37:case 38:
			var newChild = stream.consumeToken();
			parent.addChild(newChild);
			var _g = stream.token();
			switch(_g._hx_index) {
			case 6:
				switch(_g.op._hx_index) {
				case 14:case 15:
					tokentree_walk_WalkStatement.walkOpBool(stream,newChild);
					break;
				default:
					tokentree_walk_WalkStatement.walkStatementWithoutSemicolon(stream,newChild);
				}
				break;
			case 21:
				tokentree_walk_WalkQuestion.walkQuestion(stream,newChild);
				break;
			default:
			}
			return false;
		case 41:
			tokentree_walk_WalkFinal.walkFinal(stream,parent);
			break;
		default:
			return true;
		}
	} else {
		return true;
	}
	return false;
};
tokentree_walk_WalkStatement.walkDblDot = function(stream,parent) {
	if(tokentree_walk_WalkStatement.findQuestionParent(parent) != null) {
		return;
	}
	var dblDotTok = stream.consumeToken();
	parent.addChild(dblDotTok);
	if(parent.isCIdentOrCString() && parent.parent.tok._hx_index == 17) {
		tokentree_walk_WalkStatement.walkStatementWithoutSemicolon(stream,dblDotTok);
		return;
	}
	var _g = stream.tokenForMatch();
	if(_g._hx_index == 1 && _g.k._hx_index == 22) {
		tokentree_walk_WalkNew.walkNew(stream,dblDotTok);
		return;
	}
	if(!tokentree_walk_WalkStatement.walkKeyword(stream,dblDotTok)) {
		return;
	}
	tokentree_walk_WalkTypeNameDef.walkTypeNameDef(stream,dblDotTok);
	var _g = stream.tokenForMatch();
	if(_g._hx_index == 6 && _g.op._hx_index == 4) {
		tokentree_walk_WalkStatement.walkStatementWithoutSemicolon(stream,parent);
	}
	if(stream.tokenForMatch()._hx_index == 13) {
		tokentree_walk_WalkStatement.walkStatementWithoutSemicolon(stream,parent);
	}
};
tokentree_walk_WalkStatement.walkPOpen = function(stream,parent) {
	var pOpen = tokentree_walk_WalkPOpen.walkPOpen(stream,parent);
	if(parent.tok == tokentree_TokenTreeDef.Root) {
		return;
	}
	if(parent.isCIdent()) {
		tokentree_walk_WalkStatement.walkStatementContinue(stream,parent);
	} else {
		var _g = parent.tok;
		if(_g._hx_index == 1) {
			switch(_g.k._hx_index) {
			case 3:case 5:case 7:case 14:
				var _g = stream.token();
				switch(_g._hx_index) {
				case 6:
					if(_g.op._hx_index == 3) {
						return;
					}
					break;
				case 11:
					break;
				default:
					return;
				}
				break;
			default:
			}
		}
		tokentree_walk_WalkStatement.walkStatementContinue(stream,pOpen);
	}
};
tokentree_walk_WalkStatement.findQuestionParent = function(token) {
	var parent = token;
	while(parent != null && parent.tok != tokentree_TokenTreeDef.Root) {
		var _g = parent.tok;
		switch(_g._hx_index) {
		case 1:
			switch(_g.k._hx_index) {
			case 10:
				return parent;
			case 15:
				return parent;
			case 16:
				return parent;
			case 40:
				parent = tokentree_walk_WalkStatement.findQuestionParent(parent.parent);
				if(parent == null) {
					return null;
				}
				var _g1 = parent.tok;
				switch(_g1._hx_index) {
				case 1:
					switch(_g1.k._hx_index) {
					case 15:case 16:
						return parent;
					default:
						return null;
					}
					break;
				case 21:
					return parent;
				default:
					return null;
				}
				break;
			default:
			}
			break;
		case 6:
			return parent;
		case 14:
			return null;
		case 17:
			if(tokentree_TokenTreeAccessHelper.firstOf(parent,tokentree_TokenTreeDef.BrClose) == null) {
				return null;
			}
			break;
		case 19:
			if(tokentree_TokenTreeAccessHelper.firstOf(parent,tokentree_TokenTreeDef.PClose) == null) {
				return null;
			}
			break;
		case 21:
			if(tokentree_walk_WalkQuestion.isTernary(parent)) {
				return parent;
			}
			return null;
		default:
		}
		parent = parent.parent;
	}
	return null;
};
tokentree_walk_WalkStatement.walkStatementContinueAfterSharp = function(stream,parent) {
	var _g = stream.token();
	if(_g._hx_index == 1) {
		switch(_g.k._hx_index) {
		case 15:case 16:
			var lastChild = parent.getLastChild();
			if(lastChild == null) {
				lastChild = parent;
			}
			tokentree_walk_WalkSwitch.walkSwitchCases(stream,lastChild);
			break;
		default:
		}
	}
};
tokentree_walk_WalkStatement.walkOpBool = function(stream,token) {
	var parent = token.parent;
	_hx_loop1: while(parent.tok != tokentree_TokenTreeDef.Root) {
		var _g = parent.tok;
		switch(_g._hx_index) {
		case 1:
			switch(_g.k._hx_index) {
			case 0:
				break _hx_loop1;
			case 3:case 5:case 10:case 24:case 28:
				break _hx_loop1;
			case 14:case 15:case 16:
				break _hx_loop1;
			default:
				token = parent;
				parent = parent.parent;
			}
			break;
		case 6:
			switch(_g.op._hx_index) {
			case 4:
				break _hx_loop1;
			case 14:case 15:
				token = parent.parent;
				break _hx_loop1;
			case 20:
				break _hx_loop1;
			default:
				token = parent;
				parent = parent.parent;
			}
			break;
		case 12:
			token = parent;
			break _hx_loop1;
		case 19:
			if(token.tok._hx_index == 19) {
				token = parent;
			}
			break _hx_loop1;
		case 13:case 21:
			break _hx_loop1;
		default:
			token = parent;
			parent = parent.parent;
		}
	}
	tokentree_walk_WalkStatement.walkStatementWithoutSemicolon(stream,token);
};
tokentree_walk_WalkStatement.walkOpAdd = function(stream,token) {
	var parent = token.parent;
	_hx_loop1: while(parent.tok != tokentree_TokenTreeDef.Root) {
		var _g = parent.tok;
		switch(_g._hx_index) {
		case 1:
			switch(_g.k._hx_index) {
			case 0:
				break _hx_loop1;
			case 3:case 5:case 10:case 24:case 28:
				break _hx_loop1;
			default:
				token = parent;
				parent = parent.parent;
			}
			break;
		case 6:
			switch(_g.op._hx_index) {
			case 0:case 3:
				token = parent.parent;
				break _hx_loop1;
			case 1:case 2:
				token = parent;
				parent = parent.parent;
				break;
			case 4:
				break _hx_loop1;
			case 20:
				break _hx_loop1;
			default:
				break _hx_loop1;
			}
			break;
		case 9:
			break _hx_loop1;
		case 12:
			break _hx_loop1;
		case 15:case 17:
			break _hx_loop1;
		case 19:
			if(tokentree_TokenTreeAccessHelper.firstOf(parent,tokentree_TokenTreeDef.PClose) == null) {
				token = parent;
				break _hx_loop1;
			}
			token = parent;
			parent = parent.parent;
			break;
		case 13:case 21:
			break _hx_loop1;
		default:
			token = parent;
			parent = parent.parent;
		}
	}
	tokentree_walk_WalkStatement.walkStatementWithoutSemicolon(stream,token);
};
tokentree_walk_WalkStatement.walkDollarStatement = function(stream,parent) {
	var dollarTok = stream.consumeToken();
	parent.addChild(dollarTok);
	var _g = stream.token();
	switch(_g._hx_index) {
	case 2:
		var _g1 = _g.c;
		if(_g1._hx_index == 3) {
			if(_g1.s == "is") {
				tokentree_walk_WalkBlock.walkBlock(stream,dollarTok);
			}
		}
		break;
	case 6:
		tokentree_walk_WalkBlock.walkBlock(stream,dollarTok);
		break;
	case 11:case 15:case 17:case 19:
		tokentree_walk_WalkBlock.walkBlock(stream,dollarTok);
		break;
	default:
	}
};
var tokentree_walk_WalkSwitch = function() { };
tokentree_walk_WalkSwitch.__name__ = true;
tokentree_walk_WalkSwitch.walkSwitch = function(stream,parent) {
	var switchTok = stream.consumeTokenDef(tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdSwitch));
	parent.addChild(switchTok);
	stream.applyTempStore(switchTok);
	tokentree_walk_WalkComment.walkComment(stream,switchTok);
	tokentree_walk_WalkStatement.walkStatement(stream,switchTok);
	tokentree_walk_WalkComment.walkComment(stream,switchTok);
	if(stream.token()._hx_index == 3) {
		tokentree_walk_WalkSharp.walkSharp(stream,parent,tokentree_walk_WalkSwitch.walkSwitchCases);
	}
	if(stream.tokenForMatch()._hx_index == 17) {
		var brOpen = stream.consumeToken();
		switchTok.addChild(brOpen);
		tokentree_walk_WalkSwitch.walkSwitchCases(stream,brOpen);
		brOpen.addChild(stream.consumeTokenDef(tokentree_TokenTreeDef.BrClose));
	}
};
tokentree_walk_WalkSwitch.walkSwitchCases = function(stream,parent) {
	var progress = new tokentree_TokenStreamProgress(stream);
	_hx_loop1: while(progress.streamHasChanged()) {
		var _g = stream.token();
		switch(_g._hx_index) {
		case 1:
			switch(_g.k._hx_index) {
			case 15:case 16:
				tokentree_walk_WalkSwitch.walkCase(stream,parent);
				break;
			default:
				tokentree_walk_WalkStatement.walkStatement(stream,parent);
			}
			break;
		case 3:
			tokentree_walk_WalkSharp.walkSharp(stream,parent,tokentree_walk_WalkSwitch.walkSwitchCases);
			break;
		case 7:
			tokentree_walk_WalkComment.walkComment(stream,parent);
			break;
		case 8:
			tokentree_walk_WalkComment.walkComment(stream,parent);
			break;
		case 18:
			break _hx_loop1;
		default:
			tokentree_walk_WalkStatement.walkStatement(stream,parent);
		}
	}
};
tokentree_walk_WalkSwitch.walkCase = function(stream,parent) {
	tokentree_walk_WalkComment.walkComment(stream,parent);
	var caseTok = stream.consumeToken();
	parent.addChild(caseTok);
	tokentree_walk_WalkSwitch.walkCaseExpr(stream,caseTok);
	var dblDot = stream.consumeTokenDef(tokentree_TokenTreeDef.DblDot);
	caseTok.addChild(dblDot);
	var progress = new tokentree_TokenStreamProgress(stream);
	while(progress.streamHasChanged()) {
		var _g = stream.token();
		switch(_g._hx_index) {
		case 1:
			switch(_g.k._hx_index) {
			case 15:case 16:
				return;
			default:
				tokentree_walk_WalkStatement.walkStatement(stream,dblDot);
			}
			break;
		case 3:
			tokentree_walk_WalkSharp.walkSharp(stream,parent,tokentree_walk_WalkSwitch.walkSwitchCases);
			tokentree_walk_WalkSwitch.relocateSharpTree(parent,dblDot);
			break;
		case 7:
			var _g1 = stream.peekNonCommentToken();
			if(_g1 != null) {
				if(_g1._hx_index == 1) {
					switch(_g1.k._hx_index) {
					case 15:case 16:
						return;
					default:
					}
				}
			}
			tokentree_walk_WalkComment.walkComment(stream,dblDot);
			break;
		case 8:
			var _g2 = stream.peekNonCommentToken();
			if(_g2 != null) {
				if(_g2._hx_index == 1) {
					switch(_g2.k._hx_index) {
					case 15:case 16:
						return;
					default:
					}
				}
			}
			tokentree_walk_WalkComment.walkComment(stream,dblDot);
			break;
		case 17:
			tokentree_walk_WalkBlock.walkBlock(stream,dblDot);
			break;
		case 18:
			return;
		default:
			tokentree_walk_WalkStatement.walkStatement(stream,dblDot);
		}
	}
};
tokentree_walk_WalkSwitch.relocateSharpTree = function(parent,dblDot) {
	var sharp = parent.getLastChild();
	if(sharp.children.length < 2) {
		return;
	}
	var _g = sharp.children[1].tok;
	if(_g._hx_index == 1 && _g.k._hx_index == 15) {
		return;
	}
	parent.children.pop();
	dblDot.addChild(sharp);
};
tokentree_walk_WalkSwitch.walkCaseExpr = function(stream,parent) {
	var progress = new tokentree_TokenStreamProgress(stream);
	while(progress.streamHasChanged()) {
		var _g = stream.token();
		switch(_g._hx_index) {
		case 1:
			if(_g.k._hx_index == 2) {
				var varTok = stream.consumeToken();
				parent.addChild(varTok);
				tokentree_walk_WalkStatement.walkStatement(stream,varTok);
			} else {
				tokentree_walk_WalkStatement.walkStatement(stream,parent);
			}
			break;
		case 14:
			var comma = stream.consumeToken();
			var child = parent.getLastChild();
			if(child == null) {
				child = parent;
			}
			child.addChild(comma);
			break;
		case 10:case 12:case 16:case 18:case 20:
			return;
		default:
			tokentree_walk_WalkStatement.walkStatement(stream,parent);
		}
	}
};
var tokentree_walk_WalkTry = function() { };
tokentree_walk_WalkTry.__name__ = true;
tokentree_walk_WalkTry.walkTry = function(stream,parent) {
	var tryTok = stream.consumeTokenDef(tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdTry));
	parent.addChild(tryTok);
	stream.applyTempStore(tryTok);
	tokentree_walk_WalkBlock.walkBlock(stream,tryTok);
	var currentPos = stream.getStreamIndex();
	var progress = new tokentree_TokenStreamProgress(stream);
	var comments = [];
	while(stream.hasMore() && progress.streamHasChanged()) {
		var _g = stream.token();
		switch(_g._hx_index) {
		case 1:
			if(_g.k._hx_index == 21) {
				var _g1 = 0;
				while(_g1 < comments.length) tryTok.addChild(comments[_g1++]);
				comments = [];
				tokentree_walk_WalkTry.walkCatch(stream,tryTok);
				currentPos = stream.getStreamIndex();
			} else {
				stream.rewindTo(currentPos);
				return;
			}
			break;
		case 7:
			comments.push(stream.consumeToken());
			break;
		case 8:
			comments.push(stream.consumeToken());
			break;
		default:
			stream.rewindTo(currentPos);
			return;
		}
	}
};
tokentree_walk_WalkTry.walkCatch = function(stream,parent) {
	var catchTok = stream.consumeTokenDef(tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdCatch));
	parent.addChild(catchTok);
	tokentree_walk_WalkPOpen.walkPOpen(stream,catchTok);
	tokentree_walk_WalkComment.walkComment(stream,catchTok);
	tokentree_walk_WalkBlock.walkBlock(stream,catchTok);
};
var tokentree_walk_WalkType = function() { };
tokentree_walk_WalkType.__name__ = true;
tokentree_walk_WalkType.walkType = function(stream,parent) {
	var _g = stream.token();
	if(_g._hx_index == 1) {
		switch(_g.k._hx_index) {
		case 1:
			tokentree_walk_WalkClass.walkClass(stream,parent);
			break;
		case 26:
			tokentree_walk_WalkEnum.walkEnum(stream,parent);
			break;
		case 27:
			tokentree_walk_WalkInterface.walkInterface(stream,parent);
			break;
		case 31:
			tokentree_walk_WalkTypedef.walkTypedef(stream,parent);
			break;
		case 39:
			tokentree_walk_WalkAbstract.walkAbstract(stream,parent);
			break;
		default:
		}
	}
};
var tokentree_walk_WalkTypeNameDef = function() { };
tokentree_walk_WalkTypeNameDef.__name__ = true;
tokentree_walk_WalkTypeNameDef.walkTypeNameDef = function(stream,parent) {
	tokentree_walk_WalkComment.walkComment(stream,parent);
	tokentree_walk_WalkAt.walkAts(stream);
	if(stream.tokenForMatch()._hx_index == 21) {
		var questTok = stream.consumeTokenDef(tokentree_TokenTreeDef.Question);
		parent.addChild(questTok);
		parent = questTok;
		tokentree_walk_WalkComment.walkComment(stream,questTok);
	}
	var name;
	var bAdd = true;
	var _g = stream.token();
	switch(_g._hx_index) {
	case 1:
		switch(_g.k._hx_index) {
		case 22:case 25:case 40:
			name = stream.consumeToken();
			break;
		default:
			name = stream.consumeToken();
		}
		break;
	case 2:
		name = stream.consumeConst();
		break;
	case 3:
		tokentree_walk_WalkSharp.walkSharp(stream,parent,tokentree_walk_WalkStatement.walkStatement);
		if(!stream.hasMore()) {
			return parent.getFirstChild();
		}
		if(stream.token()._hx_index == 2) {
			name = stream.consumeConst();
		} else {
			return parent.getFirstChild();
		}
		break;
	case 4:
		name = stream.consumeToken();
		break;
	case 15:
		tokentree_walk_WalkArrayAccess.walkArrayAccess(stream,parent);
		return parent.getFirstChild();
	case 17:
		tokentree_walk_WalkTypedefBody.walkTypedefBody(stream,parent);
		return parent.getFirstChild();
	case 19:
		name = tokentree_walk_WalkPOpen.walkPOpen(stream,parent);
		if(stream.tokenForMatch()._hx_index == 21) {
			tokentree_walk_WalkQuestion.walkQuestion(stream,name);
		}
		bAdd = false;
		break;
	default:
		name = stream.consumeToken();
	}
	stream.applyTempStore(name);
	if(bAdd) {
		parent.addChild(name);
	}
	tokentree_walk_WalkTypeNameDef.walkTypeNameDefContinue(stream,name);
	return name;
};
tokentree_walk_WalkTypeNameDef.walkTypeNameDefContinue = function(stream,parent) {
	tokentree_walk_WalkTypeNameDef.walkTypeNameDefComment(stream,parent);
	if(stream.tokenForMatch()._hx_index == 11) {
		var dot = stream.consumeToken();
		parent.addChild(dot);
		tokentree_walk_WalkTypeNameDef.walkTypeNameDef(stream,dot);
		return;
	}
	var _g = stream.tokenForMatch();
	if(_g._hx_index == 6 && _g.op._hx_index == 9) {
		tokentree_walk_WalkLtGt.walkLtGt(stream,parent);
	}
	if(stream.tokenForMatch()._hx_index == 13) {
		var arrow = stream.consumeToken();
		parent.addChild(arrow);
		tokentree_walk_WalkTypeNameDef.walkTypeNameDef(stream,arrow);
		return;
	}
	if(stream.tokenForMatch()._hx_index == 15) {
		tokentree_walk_WalkArrayAccess.walkArrayAccess(stream,parent);
	}
	tokentree_walk_WalkTypeNameDef.walkTypeNameDefComment(stream,parent);
};
tokentree_walk_WalkTypeNameDef.walkTypeNameDefComment = function(stream,parent) {
	var currentPos = stream.getStreamIndex();
	var progress = new tokentree_TokenStreamProgress(stream);
	var comments = [];
	while(stream.hasMore() && progress.streamHasChanged()) switch(stream.token()._hx_index) {
	case 6:
		var _g = 0;
		while(_g < comments.length) parent.addChild(comments[_g++]);
		return;
	case 7:
		comments.push(stream.consumeToken());
		break;
	case 8:
		comments.push(stream.consumeToken());
		break;
	case 10:case 11:case 12:case 14:case 15:case 17:case 19:
		var _g1 = 0;
		while(_g1 < comments.length) parent.addChild(comments[_g1++]);
		return;
	default:
		stream.rewindTo(currentPos);
		return;
	}
};
var tokentree_walk_WalkTypedef = function() { };
tokentree_walk_WalkTypedef.__name__ = true;
tokentree_walk_WalkTypedef.walkTypedef = function(stream,parent) {
	var typeTok = stream.consumeToken();
	parent.addChild(typeTok);
	var name = tokentree_walk_WalkTypeNameDef.walkTypeNameDef(stream,typeTok);
	stream.applyTempStore(name);
	var _g = stream.tokenForMatch();
	if(_g._hx_index == 6 && _g.op._hx_index == 4) {
		var assign = stream.consumeTokenDef(tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpAssign));
		name.addChild(assign);
		name = assign;
	}
	tokentree_walk_WalkTypedefBody.walkTypedefBody(stream,name);
};
var tokentree_walk_WalkTypedefBody = function() { };
tokentree_walk_WalkTypedefBody.__name__ = true;
tokentree_walk_WalkTypedefBody.walkTypedefBody = function(stream,parent) {
	if(stream.tokenForMatch()._hx_index == 17) {
		var openTok = stream.consumeToken();
		parent.addChild(openTok);
		tokentree_walk_WalkTypedefBody.walkTypedefCurlyBody(stream,openTok);
		openTok.addChild(stream.consumeTokenDef(tokentree_TokenTreeDef.BrClose));
	} else {
		tokentree_walk_WalkTypedefBody.walkTypedefAlias(stream,parent);
	}
	var _g = stream.tokenForMatch();
	if(_g._hx_index == 6 && _g.op._hx_index == 11) {
		var and = stream.consumeTokenDef(tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpAnd));
		parent.getLastChild().addChild(and);
		tokentree_walk_WalkTypedefBody.walkTypedefBody(stream,parent);
	}
	if(stream.tokenForMatch()._hx_index == 13) {
		tokentree_walk_WalkStatement.walkStatement(stream,parent);
	}
};
tokentree_walk_WalkTypedefBody.walkTypedefCurlyBody = function(stream,openTok) {
	var progress = new tokentree_TokenStreamProgress(stream);
	_hx_loop1: while(progress.streamHasChanged()) {
		var _g = stream.token();
		switch(_g._hx_index) {
		case 1:
			switch(_g.k._hx_index) {
			case 0:
				tokentree_walk_WalkFunction.walkFunction(stream,openTok);
				break;
			case 2:
				tokentree_walk_WalkVar.walkVar(stream,openTok);
				break;
			case 17:case 18:case 19:case 25:case 30:case 32:case 34:case 40:
				stream.consumeToTempStore();
				break;
			case 41:
				tokentree_walk_WalkFinal.walkFinal(stream,openTok);
				break;
			default:
				tokentree_walk_WalkFieldDef.walkFieldDef(stream,openTok);
			}
			break;
		case 3:
			tokentree_walk_WalkSharp.walkSharp(stream,openTok,tokentree_walk_WalkTypedefBody.walkTypedefCurlyBody);
			break;
		case 6:
			if(_g.op._hx_index == 7) {
				tokentree_walk_WalkTypedefBody.walkStructureExtension(stream,openTok);
			} else {
				tokentree_walk_WalkFieldDef.walkFieldDef(stream,openTok);
			}
			break;
		case 7:
			if(stream.hasTempStore()) {
				stream.consumeToTempStore();
			} else {
				tokentree_walk_WalkComment.walkComment(stream,openTok);
			}
			break;
		case 8:
			if(stream.hasTempStore()) {
				stream.consumeToTempStore();
			} else {
				tokentree_walk_WalkComment.walkComment(stream,openTok);
			}
			break;
		case 18:
			break _hx_loop1;
		case 22:
			stream.addToTempStore(tokentree_walk_WalkAt.walkAt(stream));
			break;
		default:
			tokentree_walk_WalkFieldDef.walkFieldDef(stream,openTok);
		}
	}
	var tempStore = stream.getTempStore();
	if(tempStore.length > 0) {
		switch(tokentree_TokenStream.MODE._hx_index) {
		case 0:
			throw haxe_Exception.thrown("invalid token tree structure - found:" + ("" + Std.string(tempStore)));
		case 1:
			stream.applyTempStore(openTok);
			break;
		}
	}
};
tokentree_walk_WalkTypedefBody.walkTypedefAlias = function(stream,parent) {
	var newParent;
	if(stream.tokenForMatch()._hx_index == 19) {
		newParent = tokentree_walk_WalkPOpen.walkPOpen(stream,parent);
	} else {
		newParent = tokentree_walk_WalkTypeNameDef.walkTypeNameDef(stream,parent);
	}
	if(stream.tokenForMatch()._hx_index == 13) {
		var arrowTok = stream.consumeToken();
		newParent.addChild(arrowTok);
		tokentree_walk_WalkTypedefBody.walkTypedefAlias(stream,arrowTok);
	}
	if(stream.tokenForMatch()._hx_index == 10) {
		newParent.addChild(stream.consumeToken());
	}
};
tokentree_walk_WalkTypedefBody.walkStructureExtension = function(stream,parent) {
	var gt = stream.consumeTokenDef(tokentree_TokenTreeDef.Binop(haxe_macro_Binop.OpGt));
	parent.addChild(gt);
	var name = tokentree_walk_WalkTypeNameDef.walkTypeNameDef(stream,parent);
	gt.addChild(name);
	if(stream.tokenForMatch()._hx_index == 14) {
		name.addChild(stream.consumeToken());
	}
};
var tokentree_walk_WalkVar = function() { };
tokentree_walk_WalkVar.__name__ = true;
tokentree_walk_WalkVar.walkVar = function(stream,parent) {
	var name = null;
	var varTok = stream.consumeTokenDef(tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdVar));
	parent.addChild(varTok);
	tokentree_walk_WalkComment.walkComment(stream,parent);
	var progress = new tokentree_TokenStreamProgress(stream);
	while(progress.streamHasChanged()) {
		var _g = stream.tokenForMatch();
		if(_g._hx_index == 1 && _g.k._hx_index == 2) {
			return;
		}
		tokentree_walk_WalkComment.walkComment(stream,parent);
		if(stream.token()._hx_index == 22) {
			tokentree_walk_WalkAt.walkAts(stream);
		}
		tokentree_walk_WalkComment.walkComment(stream,parent);
		var nameParent = varTok;
		if(stream.tokenForMatch()._hx_index == 21) {
			nameParent = stream.consumeToken();
			varTok.addChild(nameParent);
		}
		name = stream.consumeConstIdent();
		nameParent.addChild(name);
		stream.applyTempStore(name);
		tokentree_walk_WalkComment.walkComment(stream,name);
		if(stream.tokenForMatch()._hx_index == 19) {
			tokentree_walk_WalkPOpen.walkPOpen(stream,name);
		}
		if(stream.tokenForMatch()._hx_index == 12) {
			var dblDot = stream.consumeToken();
			name.addChild(dblDot);
			tokentree_walk_WalkTypedefBody.walkTypedefAlias(stream,dblDot);
		}
		var _g1 = stream.tokenForMatch();
		if(_g1._hx_index == 6 && _g1.op._hx_index == 4) {
			tokentree_walk_WalkStatement.walkStatement(stream,name);
		}
		if(stream.tokenForMatch()._hx_index == 14) {
			name.addChild(stream.consumeToken());
			continue;
		}
		break;
	}
	if(stream.tokenForMatch()._hx_index == 10) {
		name.addChild(stream.consumeToken());
	}
};
var tokentree_walk_WalkWhile = function() { };
tokentree_walk_WalkWhile.__name__ = true;
tokentree_walk_WalkWhile.walkWhile = function(stream,parent) {
	var whileTok = stream.consumeTokenDef(tokentree_TokenTreeDef.Kwd(haxeparser_Keyword.KwdWhile));
	parent.addChild(whileTok);
	stream.applyTempStore(whileTok);
	tokentree_walk_WalkComment.walkComment(stream,whileTok);
	tokentree_walk_WalkStatement.walkStatement(stream,whileTok);
	tokentree_walk_WalkComment.walkComment(stream,whileTok);
	tokentree_walk_WalkBlock.walkBlock(stream,whileTok);
};
function $bind(o,m) { if( m == null ) return null; if( m.__id__ == null ) m.__id__ = $global.$haxeUID++; var f; if( o.hx__closures__ == null ) o.hx__closures__ = {}; else f = o.hx__closures__[m.__id__]; if( f == null ) { f = m.bind(o); o.hx__closures__[m.__id__] = f; } return f; }
$global.$haxeUID |= 0;
if(typeof(performance) != "undefined" ? typeof(performance.now) == "function" : false) {
	HxOverrides.now = performance.now.bind(performance);
}
if( String.fromCodePoint == null ) String.fromCodePoint = function(c) { return c < 0x10000 ? String.fromCharCode(c) : String.fromCharCode((c>>10)+0xD7C0)+String.fromCharCode((c&0x3FF)+0xDC00); }
String.prototype.__class__ = String;
String.__name__ = true;
Array.__name__ = true;
var Int = { };
var Dynamic = { };
var Float = Number;
var Bool = Boolean;
var Class = { };
var Enum = { };
js_Boot.__toStr = ({ }).toString;
if(ArrayBuffer.prototype.slice == null) {
	ArrayBuffer.prototype.slice = js_lib__$ArrayBuffer_ArrayBufferCompat.sliceImpl;
}
formatter_FormatStats.totalFiles = 0;
formatter_FormatStats.successFiles = 0;
formatter_FormatStats.failedFiles = 0;
formatter_FormatStats.disabledFiles = 0;
formatter_FormatStats.totalLinesOrig = 0;
formatter_FormatStats.totalLinesFormatted = 0;
hxparse_LexEngine.EMPTY = [];
hxparse_LexEngine.ALL_CHARS = [new hxparse__$LexEngine_CharRange(0,255)];
haxeparser_HaxeLexer.keywords = (function($this) {
	var $r;
	var _g = new haxe_ds_StringMap();
	_g.h["abstract"] = haxeparser_Keyword.KwdAbstract;
	_g.h["break"] = haxeparser_Keyword.KwdBreak;
	_g.h["case"] = haxeparser_Keyword.KwdCase;
	_g.h["cast"] = haxeparser_Keyword.KwdCast;
	_g.h["catch"] = haxeparser_Keyword.KwdCatch;
	_g.h["class"] = haxeparser_Keyword.KwdClass;
	_g.h["continue"] = haxeparser_Keyword.KwdContinue;
	_g.h["default"] = haxeparser_Keyword.KwdDefault;
	_g.h["do"] = haxeparser_Keyword.KwdDo;
	_g.h["dynamic"] = haxeparser_Keyword.KwdDynamic;
	_g.h["else"] = haxeparser_Keyword.KwdElse;
	_g.h["enum"] = haxeparser_Keyword.KwdEnum;
	_g.h["extends"] = haxeparser_Keyword.KwdExtends;
	_g.h["extern"] = haxeparser_Keyword.KwdExtern;
	_g.h["false"] = haxeparser_Keyword.KwdFalse;
	_g.h["final"] = haxeparser_Keyword.KwdFinal;
	_g.h["for"] = haxeparser_Keyword.KwdFor;
	_g.h["function"] = haxeparser_Keyword.KwdFunction;
	_g.h["if"] = haxeparser_Keyword.KwdIf;
	_g.h["implements"] = haxeparser_Keyword.KwdImplements;
	_g.h["import"] = haxeparser_Keyword.KwdImport;
	_g.h["inline"] = haxeparser_Keyword.KwdInline;
	_g.h["interface"] = haxeparser_Keyword.KwdInterface;
	_g.h["macro"] = haxeparser_Keyword.KwdMacro;
	_g.h["new"] = haxeparser_Keyword.KwdNew;
	_g.h["null"] = haxeparser_Keyword.KwdNull;
	_g.h["operator"] = haxeparser_Keyword.KwdOperator;
	_g.h["overload"] = haxeparser_Keyword.KwdOverload;
	_g.h["override"] = haxeparser_Keyword.KwdOverride;
	_g.h["package"] = haxeparser_Keyword.KwdPackage;
	_g.h["private"] = haxeparser_Keyword.KwdPrivate;
	_g.h["public"] = haxeparser_Keyword.KwdPublic;
	_g.h["return"] = haxeparser_Keyword.KwdReturn;
	_g.h["static"] = haxeparser_Keyword.KwdStatic;
	_g.h["switch"] = haxeparser_Keyword.KwdSwitch;
	_g.h["this"] = haxeparser_Keyword.KwdThis;
	_g.h["throw"] = haxeparser_Keyword.KwdThrow;
	_g.h["true"] = haxeparser_Keyword.KwdTrue;
	_g.h["try"] = haxeparser_Keyword.KwdTry;
	_g.h["typedef"] = haxeparser_Keyword.KwdTypedef;
	_g.h["untyped"] = haxeparser_Keyword.KwdUntyped;
	_g.h["using"] = haxeparser_Keyword.KwdUsing;
	_g.h["var"] = haxeparser_Keyword.KwdVar;
	_g.h["while"] = haxeparser_Keyword.KwdWhile;
	$r = _g;
	return $r;
}(this));
haxeparser_HaxeLexer.buf = new StringBuf();
haxeparser_HaxeLexer.tok = hxparse_Lexer.buildRuleset([{ rule : "", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Eof);
}},{ rule : "[\r\n\t ]+", func : function(lexer) {
	return lexer.token(haxeparser_HaxeLexer.tok);
}},{ rule : "0x[0-9a-fA-F]+", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Const(haxe_macro_Constant.CInt(lexer.current)));
}},{ rule : "([1-9][0-9]*)|0", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Const(haxe_macro_Constant.CInt(lexer.current)));
}},{ rule : "(([1-9][0-9]*)|0)(\\.[0-9]+)", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Const(haxe_macro_Constant.CFloat(lexer.current)));
}},{ rule : "\\.[0-9]+", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Const(haxe_macro_Constant.CFloat(lexer.current)));
}},{ rule : "(([1-9][0-9]*)|0)([eE][\\+\\-]?[0-9]+)", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Const(haxe_macro_Constant.CFloat(lexer.current)));
}},{ rule : "(([1-9][0-9]*)|0)(\\.[0-9]*[eE][\\+\\-]?[0-9]+)", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Const(haxe_macro_Constant.CFloat(lexer.current)));
}},{ rule : "(([1-9][0-9]*)|0)(\\.\\.\\.)", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.IntInterval(HxOverrides.substr(lexer.current,0,-3)));
}},{ rule : "//[^\n\r]*", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.CommentLine(HxOverrides.substr(lexer.current,2,null)));
}},{ rule : "+\\+", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Unop(haxe_macro_Unop.OpIncrement));
}},{ rule : "--", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Unop(haxe_macro_Unop.OpDecrement));
}},{ rule : "~", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Unop(haxe_macro_Unop.OpNegBits));
}},{ rule : "%=", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Binop(haxe_macro_Binop.OpAssignOp(haxe_macro_Binop.OpMod)));
}},{ rule : "&=", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Binop(haxe_macro_Binop.OpAssignOp(haxe_macro_Binop.OpAnd)));
}},{ rule : "|=", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Binop(haxe_macro_Binop.OpAssignOp(haxe_macro_Binop.OpOr)));
}},{ rule : "^=", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Binop(haxe_macro_Binop.OpAssignOp(haxe_macro_Binop.OpXor)));
}},{ rule : "+=", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Binop(haxe_macro_Binop.OpAssignOp(haxe_macro_Binop.OpAdd)));
}},{ rule : "-=", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Binop(haxe_macro_Binop.OpAssignOp(haxe_macro_Binop.OpSub)));
}},{ rule : "*=", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Binop(haxe_macro_Binop.OpAssignOp(haxe_macro_Binop.OpMult)));
}},{ rule : "/=", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Binop(haxe_macro_Binop.OpAssignOp(haxe_macro_Binop.OpDiv)));
}},{ rule : "<<=", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Binop(haxe_macro_Binop.OpAssignOp(haxe_macro_Binop.OpShl)));
}},{ rule : "==", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Binop(haxe_macro_Binop.OpEq));
}},{ rule : "!=", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Binop(haxe_macro_Binop.OpNotEq));
}},{ rule : "<=", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Binop(haxe_macro_Binop.OpLte));
}},{ rule : "&&", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Binop(haxe_macro_Binop.OpBoolAnd));
}},{ rule : "|\\|", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Binop(haxe_macro_Binop.OpBoolOr));
}},{ rule : "<<", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Binop(haxe_macro_Binop.OpShl));
}},{ rule : "->", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Arrow);
}},{ rule : "\\.\\.\\.", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Binop(haxe_macro_Binop.OpInterval));
}},{ rule : "=>", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Binop(haxe_macro_Binop.OpArrow));
}},{ rule : "!", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Unop(haxe_macro_Unop.OpNot));
}},{ rule : "<", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Binop(haxe_macro_Binop.OpLt));
}},{ rule : ">", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Binop(haxe_macro_Binop.OpGt));
}},{ rule : ";", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Semicolon);
}},{ rule : ":", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.DblDot);
}},{ rule : ",", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Comma);
}},{ rule : "\\.", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Dot);
}},{ rule : "%", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Binop(haxe_macro_Binop.OpMod));
}},{ rule : "&", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Binop(haxe_macro_Binop.OpAnd));
}},{ rule : "|", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Binop(haxe_macro_Binop.OpOr));
}},{ rule : "^", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Binop(haxe_macro_Binop.OpXor));
}},{ rule : "+", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Binop(haxe_macro_Binop.OpAdd));
}},{ rule : "*", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Binop(haxe_macro_Binop.OpMult));
}},{ rule : "/", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Binop(haxe_macro_Binop.OpDiv));
}},{ rule : "-", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Binop(haxe_macro_Binop.OpSub));
}},{ rule : "=", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Binop(haxe_macro_Binop.OpAssign));
}},{ rule : "in", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Binop(haxe_macro_Binop.OpIn));
}},{ rule : "[", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.BkOpen);
}},{ rule : "]", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.BkClose);
}},{ rule : "{", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.BrOpen);
}},{ rule : "}", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.BrClose);
}},{ rule : "\\(", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.POpen);
}},{ rule : "\\)", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.PClose);
}},{ rule : "?", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Question);
}},{ rule : "@", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.At);
}},{ rule : "\"", func : function(lexer) {
	haxeparser_HaxeLexer.buf = new StringBuf();
	var pmin = new hxparse_Position(lexer.source,lexer.pos - lexer.current.length,lexer.pos);
	try {
		lexer.token(haxeparser_HaxeLexer.string);
	} catch( _g ) {
		haxe_NativeStackTrace.lastError = _g;
		if(((haxe_Exception.caught(_g).unwrap()) instanceof haxe_io_Eof)) {
			throw haxe_Exception.thrown(new haxeparser_LexerError(haxeparser_LexerErrorMsg.UnterminatedString,haxeparser_HaxeLexer.mkPos(pmin)));
		} else {
			throw _g;
		}
	}
	var token = haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Const(haxe_macro_Constant.CString(haxeparser_HaxeLexer.unescape(haxeparser_HaxeLexer.buf.b,haxeparser_HaxeLexer.mkPos(pmin)),haxe_macro_StringLiteralKind.DoubleQuotes)));
	token.pos.min = pmin.pmin;
	return token;
}},{ rule : "'", func : function(lexer) {
	haxeparser_HaxeLexer.buf = new StringBuf();
	var pmin = new hxparse_Position(lexer.source,lexer.pos - lexer.current.length,lexer.pos);
	try {
		lexer.token(haxeparser_HaxeLexer.string2);
	} catch( _g ) {
		haxe_NativeStackTrace.lastError = _g;
		if(((haxe_Exception.caught(_g).unwrap()) instanceof haxe_io_Eof)) {
			throw haxe_Exception.thrown(new haxeparser_LexerError(haxeparser_LexerErrorMsg.UnterminatedString,haxeparser_HaxeLexer.mkPos(pmin)));
		} else {
			throw _g;
		}
	}
	var token = haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Const(haxe_macro_Constant.CString(haxeparser_HaxeLexer.unescape(haxeparser_HaxeLexer.buf.b,haxeparser_HaxeLexer.mkPos(pmin)),haxe_macro_StringLiteralKind.SingleQuotes)));
	token.pos.min = pmin.pmin;
	return token;
}},{ rule : "~/", func : function(lexer) {
	haxeparser_HaxeLexer.buf = new StringBuf();
	var pmin = new hxparse_Position(lexer.source,lexer.pos - lexer.current.length,lexer.pos);
	var info;
	try {
		info = lexer.token(haxeparser_HaxeLexer.regexp);
	} catch( _g ) {
		haxe_NativeStackTrace.lastError = _g;
		if(((haxe_Exception.caught(_g).unwrap()) instanceof haxe_io_Eof)) {
			throw haxe_Exception.thrown(new haxeparser_LexerError(haxeparser_LexerErrorMsg.UnterminatedRegExp,haxeparser_HaxeLexer.mkPos(pmin)));
		} else {
			throw _g;
		}
	}
	var token = haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Const(haxe_macro_Constant.CRegexp(haxeparser_HaxeLexer.buf.b,info.opt)));
	token.pos.min = pmin.pmin;
	return token;
}},{ rule : "/\\*", func : function(lexer) {
	haxeparser_HaxeLexer.buf = new StringBuf();
	var pmin = new hxparse_Position(lexer.source,lexer.pos - lexer.current.length,lexer.pos);
	try {
		lexer.token(haxeparser_HaxeLexer.comment);
	} catch( _g ) {
		haxe_NativeStackTrace.lastError = _g;
		if(((haxe_Exception.caught(_g).unwrap()) instanceof haxe_io_Eof)) {
			throw haxe_Exception.thrown(new haxeparser_LexerError(haxeparser_LexerErrorMsg.UnclosedComment,haxeparser_HaxeLexer.mkPos(pmin)));
		} else {
			throw _g;
		}
	}
	var token = haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Comment(haxeparser_HaxeLexer.buf.b));
	token.pos.min = pmin.pmin;
	return token;
}},{ rule : "(#)(_*[a-z][a-zA-Z0-9_]*|_+|_+[0-9][_a-zA-Z0-9]*)", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Sharp(HxOverrides.substr(lexer.current,1,null)));
}},{ rule : "$[_a-zA-Z0-9]*", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Dollar(HxOverrides.substr(lexer.current,1,null)));
}},{ rule : "_*[a-z][a-zA-Z0-9_]*|_+|_+[0-9][_a-zA-Z0-9]*", func : function(lexer) {
	var kwd = haxeparser_HaxeLexer.keywords.h[lexer.current];
	if(kwd != null) {
		return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Kwd(kwd));
	} else {
		return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Const(haxe_macro_Constant.CIdent(lexer.current)));
	}
}},{ rule : "_*[A-Z][a-zA-Z0-9_]*", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Const(haxe_macro_Constant.CIdent(lexer.current)));
}}],"tok");
haxeparser_HaxeLexer.string = hxparse_Lexer.buildRuleset([{ rule : "\\\\\\\\", func : function(lexer) {
	haxeparser_HaxeLexer.buf.b += "\\\\";
	return lexer.token(haxeparser_HaxeLexer.string);
}},{ rule : "\\\\", func : function(lexer) {
	haxeparser_HaxeLexer.buf.b += "\\";
	return lexer.token(haxeparser_HaxeLexer.string);
}},{ rule : "\\\\\"", func : function(lexer) {
	haxeparser_HaxeLexer.buf.b += "\"";
	return lexer.token(haxeparser_HaxeLexer.string);
}},{ rule : "\"", func : function(lexer) {
	return new hxparse_Position(lexer.source,lexer.pos - lexer.current.length,lexer.pos).pmax;
}},{ rule : "[^\\\\\"]+", func : function(lexer) {
	haxeparser_HaxeLexer.buf.b += Std.string(lexer.current);
	return lexer.token(haxeparser_HaxeLexer.string);
}}],"string");
haxeparser_HaxeLexer.string2 = hxparse_Lexer.buildRuleset([{ rule : "\\\\\\\\", func : function(lexer) {
	haxeparser_HaxeLexer.buf.b += "\\\\";
	return lexer.token(haxeparser_HaxeLexer.string2);
}},{ rule : "\\\\", func : function(lexer) {
	haxeparser_HaxeLexer.buf.b += "\\";
	return lexer.token(haxeparser_HaxeLexer.string2);
}},{ rule : "\\\\'", func : function(lexer) {
	haxeparser_HaxeLexer.buf.b += "'";
	return lexer.token(haxeparser_HaxeLexer.string2);
}},{ rule : "'", func : function(lexer) {
	return new hxparse_Position(lexer.source,lexer.pos - lexer.current.length,lexer.pos).pmax;
}},{ rule : "($$)|(\\$)|$", func : function(lexer) {
	haxeparser_HaxeLexer.buf.b += "$";
	return lexer.token(haxeparser_HaxeLexer.string2);
}},{ rule : "${", func : function(lexer) {
	var pmin = new hxparse_Position(lexer.source,lexer.pos - lexer.current.length,lexer.pos);
	haxeparser_HaxeLexer.buf.b += Std.string(lexer.current);
	try {
		lexer.token(haxeparser_HaxeLexer.codeString);
	} catch( _g ) {
		haxe_NativeStackTrace.lastError = _g;
		if(((haxe_Exception.caught(_g).unwrap()) instanceof haxe_io_Eof)) {
			throw haxe_Exception.thrown(new haxeparser_LexerError(haxeparser_LexerErrorMsg.UnclosedCode,haxeparser_HaxeLexer.mkPos(pmin)));
		} else {
			throw _g;
		}
	}
	return lexer.token(haxeparser_HaxeLexer.string2);
}},{ rule : "[^$\\\\']+", func : function(lexer) {
	haxeparser_HaxeLexer.buf.b += Std.string(lexer.current);
	return lexer.token(haxeparser_HaxeLexer.string2);
}}],"string2");
haxeparser_HaxeLexer.codeString = hxparse_Lexer.buildRuleset([{ rule : "{|/", func : function(lexer) {
	haxeparser_HaxeLexer.buf.b += Std.string(lexer.current);
	lexer.token(haxeparser_HaxeLexer.codeString);
}},{ rule : "}", func : function(lexer) {
	haxeparser_HaxeLexer.buf.b += Std.string(lexer.current);
}},{ rule : "\"", func : function(lexer) {
	haxeparser_HaxeLexer.buf.b += String.fromCodePoint(34);
	var pmin = new hxparse_Position(lexer.source,lexer.pos - lexer.current.length,lexer.pos);
	try {
		lexer.token(haxeparser_HaxeLexer.string);
	} catch( _g ) {
		haxe_NativeStackTrace.lastError = _g;
		if(((haxe_Exception.caught(_g).unwrap()) instanceof haxe_io_Eof)) {
			throw haxe_Exception.thrown(new haxeparser_LexerError(haxeparser_LexerErrorMsg.UnterminatedString,haxeparser_HaxeLexer.mkPos(pmin)));
		} else {
			throw _g;
		}
	}
	haxeparser_HaxeLexer.buf.b += String.fromCodePoint(34);
	lexer.token(haxeparser_HaxeLexer.codeString);
}},{ rule : "'", func : function(lexer) {
	haxeparser_HaxeLexer.buf.b += String.fromCodePoint(39);
	var pmin = new hxparse_Position(lexer.source,lexer.pos - lexer.current.length,lexer.pos);
	try {
		lexer.token(haxeparser_HaxeLexer.string2);
	} catch( _g ) {
		haxe_NativeStackTrace.lastError = _g;
		if(((haxe_Exception.caught(_g).unwrap()) instanceof haxe_io_Eof)) {
			throw haxe_Exception.thrown(new haxeparser_LexerError(haxeparser_LexerErrorMsg.UnterminatedString,haxeparser_HaxeLexer.mkPos(pmin)));
		} else {
			throw _g;
		}
	}
	haxeparser_HaxeLexer.buf.b += String.fromCodePoint(39);
	lexer.token(haxeparser_HaxeLexer.codeString);
}},{ rule : "/\\*", func : function(lexer) {
	var pmin = new hxparse_Position(lexer.source,lexer.pos - lexer.current.length,lexer.pos);
	try {
		lexer.token(haxeparser_HaxeLexer.comment);
	} catch( _g ) {
		haxe_NativeStackTrace.lastError = _g;
		if(((haxe_Exception.caught(_g).unwrap()) instanceof haxe_io_Eof)) {
			throw haxe_Exception.thrown(new haxeparser_LexerError(haxeparser_LexerErrorMsg.UnclosedComment,haxeparser_HaxeLexer.mkPos(pmin)));
		} else {
			throw _g;
		}
	}
	lexer.token(haxeparser_HaxeLexer.codeString);
}},{ rule : "//[^\n\r]*", func : function(lexer) {
	haxeparser_HaxeLexer.buf.b += Std.string(lexer.current);
	lexer.token(haxeparser_HaxeLexer.codeString);
}},{ rule : "[^/\"'{}\n\r]+", func : function(lexer) {
	haxeparser_HaxeLexer.buf.b += Std.string(lexer.current);
	lexer.token(haxeparser_HaxeLexer.codeString);
}},{ rule : "[\r\n\t ]+", func : function(lexer) {
	haxeparser_HaxeLexer.buf.b += Std.string(lexer.current);
	lexer.token(haxeparser_HaxeLexer.codeString);
}}],"codeString");
haxeparser_HaxeLexer.comment = hxparse_Lexer.buildRuleset([{ rule : "*/", func : function(lexer) {
	return new hxparse_Position(lexer.source,lexer.pos - lexer.current.length,lexer.pos).pmax;
}},{ rule : "*", func : function(lexer) {
	haxeparser_HaxeLexer.buf.b += "*";
	return lexer.token(haxeparser_HaxeLexer.comment);
}},{ rule : "[^\\*]+", func : function(lexer) {
	haxeparser_HaxeLexer.buf.b += Std.string(lexer.current);
	return lexer.token(haxeparser_HaxeLexer.comment);
}}],"comment");
haxeparser_HaxeLexer.regexp = hxparse_Lexer.buildRuleset([{ rule : "\\\\/", func : function(lexer) {
	haxeparser_HaxeLexer.buf.b += "/";
	return lexer.token(haxeparser_HaxeLexer.regexp);
}},{ rule : "\\\\r", func : function(lexer) {
	haxeparser_HaxeLexer.buf.b += "\r";
	return lexer.token(haxeparser_HaxeLexer.regexp);
}},{ rule : "\\\\n", func : function(lexer) {
	haxeparser_HaxeLexer.buf.b += "\n";
	return lexer.token(haxeparser_HaxeLexer.regexp);
}},{ rule : "\\\\t", func : function(lexer) {
	haxeparser_HaxeLexer.buf.b += "\t";
	return lexer.token(haxeparser_HaxeLexer.regexp);
}},{ rule : "\\\\[\\\\$\\.*+\\^|{}\\[\\]()?\\-0-9]", func : function(lexer) {
	haxeparser_HaxeLexer.buf.b += Std.string(lexer.current);
	return lexer.token(haxeparser_HaxeLexer.regexp);
}},{ rule : "\\\\[wWbBsSdDx]", func : function(lexer) {
	haxeparser_HaxeLexer.buf.b += Std.string(lexer.current);
	return lexer.token(haxeparser_HaxeLexer.regexp);
}},{ rule : "/", func : function(lexer) {
	return lexer.token(haxeparser_HaxeLexer.regexp_options);
}},{ rule : "[^\\\\/\r\n]+", func : function(lexer) {
	haxeparser_HaxeLexer.buf.b += Std.string(lexer.current);
	return lexer.token(haxeparser_HaxeLexer.regexp);
}}],"regexp");
haxeparser_HaxeLexer.regexp_options = hxparse_Lexer.buildRuleset([{ rule : "[gimsu]*", func : function(lexer) {
	return { pmax : new hxparse_Position(lexer.source,lexer.pos - lexer.current.length,lexer.pos).pmax, opt : lexer.current};
}}],"regexp_options");
tokentree_TokenStream.MODE = tokentree_TokenStreamMode.Strict;
formatter_Cli.main();
})(typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this);
